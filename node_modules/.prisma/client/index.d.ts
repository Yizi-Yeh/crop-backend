
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Crop
 * 
 */
export type Crop = $Result.DefaultSelection<Prisma.$CropPayload>
/**
 * Model IndicatorCategory
 * 
 */
export type IndicatorCategory = $Result.DefaultSelection<Prisma.$IndicatorCategoryPayload>
/**
 * Model Indicator
 * 
 */
export type Indicator = $Result.DefaultSelection<Prisma.$IndicatorPayload>
/**
 * Model Zone
 * 
 */
export type Zone = $Result.DefaultSelection<Prisma.$ZonePayload>
/**
 * Model City
 * 
 */
export type City = $Result.DefaultSelection<Prisma.$CityPayload>
/**
 * Model District
 * 
 */
export type District = $Result.DefaultSelection<Prisma.$DistrictPayload>
/**
 * Model ZoneDistrict
 * 
 */
export type ZoneDistrict = $Result.DefaultSelection<Prisma.$ZoneDistrictPayload>
/**
 * Model Calendar
 * 
 */
export type Calendar = $Result.DefaultSelection<Prisma.$CalendarPayload>
/**
 * Model CalendarZone
 * 
 */
export type CalendarZone = $Result.DefaultSelection<Prisma.$CalendarZonePayload>
/**
 * Model CalendarZoneDistrict
 * 
 */
export type CalendarZoneDistrict = $Result.DefaultSelection<Prisma.$CalendarZoneDistrictPayload>
/**
 * Model CalendarIndicator
 * 
 */
export type CalendarIndicator = $Result.DefaultSelection<Prisma.$CalendarIndicatorPayload>
/**
 * Model Stage
 * 
 */
export type Stage = $Result.DefaultSelection<Prisma.$StagePayload>
/**
 * Model StageImage
 * 
 */
export type StageImage = $Result.DefaultSelection<Prisma.$StageImagePayload>
/**
 * Model StageThreshold
 * 
 */
export type StageThreshold = $Result.DefaultSelection<Prisma.$StageThresholdPayload>
/**
 * Model Gwl
 * 
 */
export type Gwl = $Result.DefaultSelection<Prisma.$GwlPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const CalendarFileType: {
  ORIGINAL: 'ORIGINAL',
  COPY: 'COPY'
};

export type CalendarFileType = (typeof CalendarFileType)[keyof typeof CalendarFileType]


export const StageStatus: {
  DRAFT: 'DRAFT',
  COMPLETE: 'COMPLETE'
};

export type StageStatus = (typeof StageStatus)[keyof typeof StageStatus]


export const TenDay: {
  FIRST: 'FIRST',
  MIDDLE: 'MIDDLE',
  LAST: 'LAST'
};

export type TenDay = (typeof TenDay)[keyof typeof TenDay]


export const StageImageType: {
  COVER: 'COVER',
  ALBUM: 'ALBUM'
};

export type StageImageType = (typeof StageImageType)[keyof typeof StageImageType]


export const ThresholdOperator: {
  GT: 'GT',
  LT: 'LT',
  GTE: 'GTE',
  LTE: 'LTE'
};

export type ThresholdOperator = (typeof ThresholdOperator)[keyof typeof ThresholdOperator]

}

export type CalendarFileType = $Enums.CalendarFileType

export const CalendarFileType: typeof $Enums.CalendarFileType

export type StageStatus = $Enums.StageStatus

export const StageStatus: typeof $Enums.StageStatus

export type TenDay = $Enums.TenDay

export const TenDay: typeof $Enums.TenDay

export type StageImageType = $Enums.StageImageType

export const StageImageType: typeof $Enums.StageImageType

export type ThresholdOperator = $Enums.ThresholdOperator

export const ThresholdOperator: typeof $Enums.ThresholdOperator

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Crops
 * const crops = await prisma.crop.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Crops
   * const crops = await prisma.crop.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.crop`: Exposes CRUD operations for the **Crop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Crops
    * const crops = await prisma.crop.findMany()
    * ```
    */
  get crop(): Prisma.CropDelegate<ExtArgs>;

  /**
   * `prisma.indicatorCategory`: Exposes CRUD operations for the **IndicatorCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IndicatorCategories
    * const indicatorCategories = await prisma.indicatorCategory.findMany()
    * ```
    */
  get indicatorCategory(): Prisma.IndicatorCategoryDelegate<ExtArgs>;

  /**
   * `prisma.indicator`: Exposes CRUD operations for the **Indicator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Indicators
    * const indicators = await prisma.indicator.findMany()
    * ```
    */
  get indicator(): Prisma.IndicatorDelegate<ExtArgs>;

  /**
   * `prisma.zone`: Exposes CRUD operations for the **Zone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Zones
    * const zones = await prisma.zone.findMany()
    * ```
    */
  get zone(): Prisma.ZoneDelegate<ExtArgs>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<ExtArgs>;

  /**
   * `prisma.district`: Exposes CRUD operations for the **District** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Districts
    * const districts = await prisma.district.findMany()
    * ```
    */
  get district(): Prisma.DistrictDelegate<ExtArgs>;

  /**
   * `prisma.zoneDistrict`: Exposes CRUD operations for the **ZoneDistrict** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ZoneDistricts
    * const zoneDistricts = await prisma.zoneDistrict.findMany()
    * ```
    */
  get zoneDistrict(): Prisma.ZoneDistrictDelegate<ExtArgs>;

  /**
   * `prisma.calendar`: Exposes CRUD operations for the **Calendar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Calendars
    * const calendars = await prisma.calendar.findMany()
    * ```
    */
  get calendar(): Prisma.CalendarDelegate<ExtArgs>;

  /**
   * `prisma.calendarZone`: Exposes CRUD operations for the **CalendarZone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CalendarZones
    * const calendarZones = await prisma.calendarZone.findMany()
    * ```
    */
  get calendarZone(): Prisma.CalendarZoneDelegate<ExtArgs>;

  /**
   * `prisma.calendarZoneDistrict`: Exposes CRUD operations for the **CalendarZoneDistrict** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CalendarZoneDistricts
    * const calendarZoneDistricts = await prisma.calendarZoneDistrict.findMany()
    * ```
    */
  get calendarZoneDistrict(): Prisma.CalendarZoneDistrictDelegate<ExtArgs>;

  /**
   * `prisma.calendarIndicator`: Exposes CRUD operations for the **CalendarIndicator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CalendarIndicators
    * const calendarIndicators = await prisma.calendarIndicator.findMany()
    * ```
    */
  get calendarIndicator(): Prisma.CalendarIndicatorDelegate<ExtArgs>;

  /**
   * `prisma.stage`: Exposes CRUD operations for the **Stage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stages
    * const stages = await prisma.stage.findMany()
    * ```
    */
  get stage(): Prisma.StageDelegate<ExtArgs>;

  /**
   * `prisma.stageImage`: Exposes CRUD operations for the **StageImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StageImages
    * const stageImages = await prisma.stageImage.findMany()
    * ```
    */
  get stageImage(): Prisma.StageImageDelegate<ExtArgs>;

  /**
   * `prisma.stageThreshold`: Exposes CRUD operations for the **StageThreshold** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StageThresholds
    * const stageThresholds = await prisma.stageThreshold.findMany()
    * ```
    */
  get stageThreshold(): Prisma.StageThresholdDelegate<ExtArgs>;

  /**
   * `prisma.gwl`: Exposes CRUD operations for the **Gwl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gwls
    * const gwls = await prisma.gwl.findMany()
    * ```
    */
  get gwl(): Prisma.GwlDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Crop: 'Crop',
    IndicatorCategory: 'IndicatorCategory',
    Indicator: 'Indicator',
    Zone: 'Zone',
    City: 'City',
    District: 'District',
    ZoneDistrict: 'ZoneDistrict',
    Calendar: 'Calendar',
    CalendarZone: 'CalendarZone',
    CalendarZoneDistrict: 'CalendarZoneDistrict',
    CalendarIndicator: 'CalendarIndicator',
    Stage: 'Stage',
    StageImage: 'StageImage',
    StageThreshold: 'StageThreshold',
    Gwl: 'Gwl'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "crop" | "indicatorCategory" | "indicator" | "zone" | "city" | "district" | "zoneDistrict" | "calendar" | "calendarZone" | "calendarZoneDistrict" | "calendarIndicator" | "stage" | "stageImage" | "stageThreshold" | "gwl"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Crop: {
        payload: Prisma.$CropPayload<ExtArgs>
        fields: Prisma.CropFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CropFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CropFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>
          }
          findFirst: {
            args: Prisma.CropFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CropFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>
          }
          findMany: {
            args: Prisma.CropFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>[]
          }
          create: {
            args: Prisma.CropCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>
          }
          createMany: {
            args: Prisma.CropCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CropCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>[]
          }
          delete: {
            args: Prisma.CropDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>
          }
          update: {
            args: Prisma.CropUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>
          }
          deleteMany: {
            args: Prisma.CropDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CropUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CropUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>
          }
          aggregate: {
            args: Prisma.CropAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrop>
          }
          groupBy: {
            args: Prisma.CropGroupByArgs<ExtArgs>
            result: $Utils.Optional<CropGroupByOutputType>[]
          }
          count: {
            args: Prisma.CropCountArgs<ExtArgs>
            result: $Utils.Optional<CropCountAggregateOutputType> | number
          }
        }
      }
      IndicatorCategory: {
        payload: Prisma.$IndicatorCategoryPayload<ExtArgs>
        fields: Prisma.IndicatorCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IndicatorCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IndicatorCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCategoryPayload>
          }
          findFirst: {
            args: Prisma.IndicatorCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IndicatorCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCategoryPayload>
          }
          findMany: {
            args: Prisma.IndicatorCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCategoryPayload>[]
          }
          create: {
            args: Prisma.IndicatorCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCategoryPayload>
          }
          createMany: {
            args: Prisma.IndicatorCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IndicatorCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCategoryPayload>[]
          }
          delete: {
            args: Prisma.IndicatorCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCategoryPayload>
          }
          update: {
            args: Prisma.IndicatorCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCategoryPayload>
          }
          deleteMany: {
            args: Prisma.IndicatorCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IndicatorCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IndicatorCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCategoryPayload>
          }
          aggregate: {
            args: Prisma.IndicatorCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIndicatorCategory>
          }
          groupBy: {
            args: Prisma.IndicatorCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<IndicatorCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.IndicatorCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<IndicatorCategoryCountAggregateOutputType> | number
          }
        }
      }
      Indicator: {
        payload: Prisma.$IndicatorPayload<ExtArgs>
        fields: Prisma.IndicatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IndicatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IndicatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>
          }
          findFirst: {
            args: Prisma.IndicatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IndicatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>
          }
          findMany: {
            args: Prisma.IndicatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>[]
          }
          create: {
            args: Prisma.IndicatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>
          }
          createMany: {
            args: Prisma.IndicatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IndicatorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>[]
          }
          delete: {
            args: Prisma.IndicatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>
          }
          update: {
            args: Prisma.IndicatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>
          }
          deleteMany: {
            args: Prisma.IndicatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IndicatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IndicatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>
          }
          aggregate: {
            args: Prisma.IndicatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIndicator>
          }
          groupBy: {
            args: Prisma.IndicatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<IndicatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.IndicatorCountArgs<ExtArgs>
            result: $Utils.Optional<IndicatorCountAggregateOutputType> | number
          }
        }
      }
      Zone: {
        payload: Prisma.$ZonePayload<ExtArgs>
        fields: Prisma.ZoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ZoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ZoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          findFirst: {
            args: Prisma.ZoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ZoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          findMany: {
            args: Prisma.ZoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          create: {
            args: Prisma.ZoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          createMany: {
            args: Prisma.ZoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ZoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          delete: {
            args: Prisma.ZoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          update: {
            args: Prisma.ZoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          deleteMany: {
            args: Prisma.ZoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ZoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ZoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          aggregate: {
            args: Prisma.ZoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZone>
          }
          groupBy: {
            args: Prisma.ZoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.ZoneCountArgs<ExtArgs>
            result: $Utils.Optional<ZoneCountAggregateOutputType> | number
          }
        }
      }
      City: {
        payload: Prisma.$CityPayload<ExtArgs>
        fields: Prisma.CityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findFirst: {
            args: Prisma.CityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findMany: {
            args: Prisma.CityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          create: {
            args: Prisma.CityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          createMany: {
            args: Prisma.CityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          delete: {
            args: Prisma.CityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          update: {
            args: Prisma.CityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          deleteMany: {
            args: Prisma.CityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          aggregate: {
            args: Prisma.CityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCity>
          }
          groupBy: {
            args: Prisma.CityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CityCountArgs<ExtArgs>
            result: $Utils.Optional<CityCountAggregateOutputType> | number
          }
        }
      }
      District: {
        payload: Prisma.$DistrictPayload<ExtArgs>
        fields: Prisma.DistrictFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DistrictFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DistrictFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          findFirst: {
            args: Prisma.DistrictFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DistrictFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          findMany: {
            args: Prisma.DistrictFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>[]
          }
          create: {
            args: Prisma.DistrictCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          createMany: {
            args: Prisma.DistrictCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DistrictCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>[]
          }
          delete: {
            args: Prisma.DistrictDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          update: {
            args: Prisma.DistrictUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          deleteMany: {
            args: Prisma.DistrictDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DistrictUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DistrictUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          aggregate: {
            args: Prisma.DistrictAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDistrict>
          }
          groupBy: {
            args: Prisma.DistrictGroupByArgs<ExtArgs>
            result: $Utils.Optional<DistrictGroupByOutputType>[]
          }
          count: {
            args: Prisma.DistrictCountArgs<ExtArgs>
            result: $Utils.Optional<DistrictCountAggregateOutputType> | number
          }
        }
      }
      ZoneDistrict: {
        payload: Prisma.$ZoneDistrictPayload<ExtArgs>
        fields: Prisma.ZoneDistrictFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ZoneDistrictFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneDistrictPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ZoneDistrictFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneDistrictPayload>
          }
          findFirst: {
            args: Prisma.ZoneDistrictFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneDistrictPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ZoneDistrictFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneDistrictPayload>
          }
          findMany: {
            args: Prisma.ZoneDistrictFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneDistrictPayload>[]
          }
          create: {
            args: Prisma.ZoneDistrictCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneDistrictPayload>
          }
          createMany: {
            args: Prisma.ZoneDistrictCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ZoneDistrictCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneDistrictPayload>[]
          }
          delete: {
            args: Prisma.ZoneDistrictDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneDistrictPayload>
          }
          update: {
            args: Prisma.ZoneDistrictUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneDistrictPayload>
          }
          deleteMany: {
            args: Prisma.ZoneDistrictDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ZoneDistrictUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ZoneDistrictUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoneDistrictPayload>
          }
          aggregate: {
            args: Prisma.ZoneDistrictAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZoneDistrict>
          }
          groupBy: {
            args: Prisma.ZoneDistrictGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZoneDistrictGroupByOutputType>[]
          }
          count: {
            args: Prisma.ZoneDistrictCountArgs<ExtArgs>
            result: $Utils.Optional<ZoneDistrictCountAggregateOutputType> | number
          }
        }
      }
      Calendar: {
        payload: Prisma.$CalendarPayload<ExtArgs>
        fields: Prisma.CalendarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalendarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalendarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>
          }
          findFirst: {
            args: Prisma.CalendarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalendarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>
          }
          findMany: {
            args: Prisma.CalendarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>[]
          }
          create: {
            args: Prisma.CalendarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>
          }
          createMany: {
            args: Prisma.CalendarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CalendarCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>[]
          }
          delete: {
            args: Prisma.CalendarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>
          }
          update: {
            args: Prisma.CalendarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>
          }
          deleteMany: {
            args: Prisma.CalendarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalendarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CalendarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>
          }
          aggregate: {
            args: Prisma.CalendarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalendar>
          }
          groupBy: {
            args: Prisma.CalendarGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalendarGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalendarCountArgs<ExtArgs>
            result: $Utils.Optional<CalendarCountAggregateOutputType> | number
          }
        }
      }
      CalendarZone: {
        payload: Prisma.$CalendarZonePayload<ExtArgs>
        fields: Prisma.CalendarZoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalendarZoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarZonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalendarZoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarZonePayload>
          }
          findFirst: {
            args: Prisma.CalendarZoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarZonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalendarZoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarZonePayload>
          }
          findMany: {
            args: Prisma.CalendarZoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarZonePayload>[]
          }
          create: {
            args: Prisma.CalendarZoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarZonePayload>
          }
          createMany: {
            args: Prisma.CalendarZoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CalendarZoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarZonePayload>[]
          }
          delete: {
            args: Prisma.CalendarZoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarZonePayload>
          }
          update: {
            args: Prisma.CalendarZoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarZonePayload>
          }
          deleteMany: {
            args: Prisma.CalendarZoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalendarZoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CalendarZoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarZonePayload>
          }
          aggregate: {
            args: Prisma.CalendarZoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalendarZone>
          }
          groupBy: {
            args: Prisma.CalendarZoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalendarZoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalendarZoneCountArgs<ExtArgs>
            result: $Utils.Optional<CalendarZoneCountAggregateOutputType> | number
          }
        }
      }
      CalendarZoneDistrict: {
        payload: Prisma.$CalendarZoneDistrictPayload<ExtArgs>
        fields: Prisma.CalendarZoneDistrictFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalendarZoneDistrictFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarZoneDistrictPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalendarZoneDistrictFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarZoneDistrictPayload>
          }
          findFirst: {
            args: Prisma.CalendarZoneDistrictFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarZoneDistrictPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalendarZoneDistrictFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarZoneDistrictPayload>
          }
          findMany: {
            args: Prisma.CalendarZoneDistrictFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarZoneDistrictPayload>[]
          }
          create: {
            args: Prisma.CalendarZoneDistrictCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarZoneDistrictPayload>
          }
          createMany: {
            args: Prisma.CalendarZoneDistrictCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CalendarZoneDistrictCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarZoneDistrictPayload>[]
          }
          delete: {
            args: Prisma.CalendarZoneDistrictDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarZoneDistrictPayload>
          }
          update: {
            args: Prisma.CalendarZoneDistrictUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarZoneDistrictPayload>
          }
          deleteMany: {
            args: Prisma.CalendarZoneDistrictDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalendarZoneDistrictUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CalendarZoneDistrictUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarZoneDistrictPayload>
          }
          aggregate: {
            args: Prisma.CalendarZoneDistrictAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalendarZoneDistrict>
          }
          groupBy: {
            args: Prisma.CalendarZoneDistrictGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalendarZoneDistrictGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalendarZoneDistrictCountArgs<ExtArgs>
            result: $Utils.Optional<CalendarZoneDistrictCountAggregateOutputType> | number
          }
        }
      }
      CalendarIndicator: {
        payload: Prisma.$CalendarIndicatorPayload<ExtArgs>
        fields: Prisma.CalendarIndicatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalendarIndicatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarIndicatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalendarIndicatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarIndicatorPayload>
          }
          findFirst: {
            args: Prisma.CalendarIndicatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarIndicatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalendarIndicatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarIndicatorPayload>
          }
          findMany: {
            args: Prisma.CalendarIndicatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarIndicatorPayload>[]
          }
          create: {
            args: Prisma.CalendarIndicatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarIndicatorPayload>
          }
          createMany: {
            args: Prisma.CalendarIndicatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CalendarIndicatorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarIndicatorPayload>[]
          }
          delete: {
            args: Prisma.CalendarIndicatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarIndicatorPayload>
          }
          update: {
            args: Prisma.CalendarIndicatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarIndicatorPayload>
          }
          deleteMany: {
            args: Prisma.CalendarIndicatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalendarIndicatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CalendarIndicatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarIndicatorPayload>
          }
          aggregate: {
            args: Prisma.CalendarIndicatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalendarIndicator>
          }
          groupBy: {
            args: Prisma.CalendarIndicatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalendarIndicatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalendarIndicatorCountArgs<ExtArgs>
            result: $Utils.Optional<CalendarIndicatorCountAggregateOutputType> | number
          }
        }
      }
      Stage: {
        payload: Prisma.$StagePayload<ExtArgs>
        fields: Prisma.StageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>
          }
          findFirst: {
            args: Prisma.StageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>
          }
          findMany: {
            args: Prisma.StageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>[]
          }
          create: {
            args: Prisma.StageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>
          }
          createMany: {
            args: Prisma.StageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>[]
          }
          delete: {
            args: Prisma.StageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>
          }
          update: {
            args: Prisma.StageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>
          }
          deleteMany: {
            args: Prisma.StageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>
          }
          aggregate: {
            args: Prisma.StageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStage>
          }
          groupBy: {
            args: Prisma.StageGroupByArgs<ExtArgs>
            result: $Utils.Optional<StageGroupByOutputType>[]
          }
          count: {
            args: Prisma.StageCountArgs<ExtArgs>
            result: $Utils.Optional<StageCountAggregateOutputType> | number
          }
        }
      }
      StageImage: {
        payload: Prisma.$StageImagePayload<ExtArgs>
        fields: Prisma.StageImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StageImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StageImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageImagePayload>
          }
          findFirst: {
            args: Prisma.StageImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StageImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageImagePayload>
          }
          findMany: {
            args: Prisma.StageImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageImagePayload>[]
          }
          create: {
            args: Prisma.StageImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageImagePayload>
          }
          createMany: {
            args: Prisma.StageImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StageImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageImagePayload>[]
          }
          delete: {
            args: Prisma.StageImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageImagePayload>
          }
          update: {
            args: Prisma.StageImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageImagePayload>
          }
          deleteMany: {
            args: Prisma.StageImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StageImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StageImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageImagePayload>
          }
          aggregate: {
            args: Prisma.StageImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStageImage>
          }
          groupBy: {
            args: Prisma.StageImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<StageImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.StageImageCountArgs<ExtArgs>
            result: $Utils.Optional<StageImageCountAggregateOutputType> | number
          }
        }
      }
      StageThreshold: {
        payload: Prisma.$StageThresholdPayload<ExtArgs>
        fields: Prisma.StageThresholdFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StageThresholdFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageThresholdPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StageThresholdFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageThresholdPayload>
          }
          findFirst: {
            args: Prisma.StageThresholdFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageThresholdPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StageThresholdFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageThresholdPayload>
          }
          findMany: {
            args: Prisma.StageThresholdFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageThresholdPayload>[]
          }
          create: {
            args: Prisma.StageThresholdCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageThresholdPayload>
          }
          createMany: {
            args: Prisma.StageThresholdCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StageThresholdCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageThresholdPayload>[]
          }
          delete: {
            args: Prisma.StageThresholdDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageThresholdPayload>
          }
          update: {
            args: Prisma.StageThresholdUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageThresholdPayload>
          }
          deleteMany: {
            args: Prisma.StageThresholdDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StageThresholdUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StageThresholdUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageThresholdPayload>
          }
          aggregate: {
            args: Prisma.StageThresholdAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStageThreshold>
          }
          groupBy: {
            args: Prisma.StageThresholdGroupByArgs<ExtArgs>
            result: $Utils.Optional<StageThresholdGroupByOutputType>[]
          }
          count: {
            args: Prisma.StageThresholdCountArgs<ExtArgs>
            result: $Utils.Optional<StageThresholdCountAggregateOutputType> | number
          }
        }
      }
      Gwl: {
        payload: Prisma.$GwlPayload<ExtArgs>
        fields: Prisma.GwlFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GwlFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GwlPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GwlFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GwlPayload>
          }
          findFirst: {
            args: Prisma.GwlFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GwlPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GwlFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GwlPayload>
          }
          findMany: {
            args: Prisma.GwlFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GwlPayload>[]
          }
          create: {
            args: Prisma.GwlCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GwlPayload>
          }
          createMany: {
            args: Prisma.GwlCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GwlCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GwlPayload>[]
          }
          delete: {
            args: Prisma.GwlDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GwlPayload>
          }
          update: {
            args: Prisma.GwlUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GwlPayload>
          }
          deleteMany: {
            args: Prisma.GwlDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GwlUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GwlUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GwlPayload>
          }
          aggregate: {
            args: Prisma.GwlAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGwl>
          }
          groupBy: {
            args: Prisma.GwlGroupByArgs<ExtArgs>
            result: $Utils.Optional<GwlGroupByOutputType>[]
          }
          count: {
            args: Prisma.GwlCountArgs<ExtArgs>
            result: $Utils.Optional<GwlCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CropCountOutputType
   */

  export type CropCountOutputType = {
    calendars: number
  }

  export type CropCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calendars?: boolean | CropCountOutputTypeCountCalendarsArgs
  }

  // Custom InputTypes
  /**
   * CropCountOutputType without action
   */
  export type CropCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropCountOutputType
     */
    select?: CropCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CropCountOutputType without action
   */
  export type CropCountOutputTypeCountCalendarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarWhereInput
  }


  /**
   * Count Type IndicatorCategoryCountOutputType
   */

  export type IndicatorCategoryCountOutputType = {
    indicators: number
  }

  export type IndicatorCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicators?: boolean | IndicatorCategoryCountOutputTypeCountIndicatorsArgs
  }

  // Custom InputTypes
  /**
   * IndicatorCategoryCountOutputType without action
   */
  export type IndicatorCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCategoryCountOutputType
     */
    select?: IndicatorCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IndicatorCategoryCountOutputType without action
   */
  export type IndicatorCategoryCountOutputTypeCountIndicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicatorWhereInput
  }


  /**
   * Count Type IndicatorCountOutputType
   */

  export type IndicatorCountOutputType = {
    thresholds: number
    calendarIndicators: number
  }

  export type IndicatorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thresholds?: boolean | IndicatorCountOutputTypeCountThresholdsArgs
    calendarIndicators?: boolean | IndicatorCountOutputTypeCountCalendarIndicatorsArgs
  }

  // Custom InputTypes
  /**
   * IndicatorCountOutputType without action
   */
  export type IndicatorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCountOutputType
     */
    select?: IndicatorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IndicatorCountOutputType without action
   */
  export type IndicatorCountOutputTypeCountThresholdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StageThresholdWhereInput
  }

  /**
   * IndicatorCountOutputType without action
   */
  export type IndicatorCountOutputTypeCountCalendarIndicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarIndicatorWhereInput
  }


  /**
   * Count Type ZoneCountOutputType
   */

  export type ZoneCountOutputType = {
    zoneDistricts: number
    calendarZones: number
  }

  export type ZoneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zoneDistricts?: boolean | ZoneCountOutputTypeCountZoneDistrictsArgs
    calendarZones?: boolean | ZoneCountOutputTypeCountCalendarZonesArgs
  }

  // Custom InputTypes
  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneCountOutputType
     */
    select?: ZoneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountZoneDistrictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoneDistrictWhereInput
  }

  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountCalendarZonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarZoneWhereInput
  }


  /**
   * Count Type CityCountOutputType
   */

  export type CityCountOutputType = {
    districts: number
  }

  export type CityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    districts?: boolean | CityCountOutputTypeCountDistrictsArgs
  }

  // Custom InputTypes
  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityCountOutputType
     */
    select?: CityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountDistrictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DistrictWhereInput
  }


  /**
   * Count Type DistrictCountOutputType
   */

  export type DistrictCountOutputType = {
    zoneDistricts: number
    calendarZoneDistricts: number
  }

  export type DistrictCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zoneDistricts?: boolean | DistrictCountOutputTypeCountZoneDistrictsArgs
    calendarZoneDistricts?: boolean | DistrictCountOutputTypeCountCalendarZoneDistrictsArgs
  }

  // Custom InputTypes
  /**
   * DistrictCountOutputType without action
   */
  export type DistrictCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistrictCountOutputType
     */
    select?: DistrictCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DistrictCountOutputType without action
   */
  export type DistrictCountOutputTypeCountZoneDistrictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoneDistrictWhereInput
  }

  /**
   * DistrictCountOutputType without action
   */
  export type DistrictCountOutputTypeCountCalendarZoneDistrictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarZoneDistrictWhereInput
  }


  /**
   * Count Type CalendarCountOutputType
   */

  export type CalendarCountOutputType = {
    stages: number
    calendarZones: number
    calendarIndicators: number
  }

  export type CalendarCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stages?: boolean | CalendarCountOutputTypeCountStagesArgs
    calendarZones?: boolean | CalendarCountOutputTypeCountCalendarZonesArgs
    calendarIndicators?: boolean | CalendarCountOutputTypeCountCalendarIndicatorsArgs
  }

  // Custom InputTypes
  /**
   * CalendarCountOutputType without action
   */
  export type CalendarCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarCountOutputType
     */
    select?: CalendarCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CalendarCountOutputType without action
   */
  export type CalendarCountOutputTypeCountStagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StageWhereInput
  }

  /**
   * CalendarCountOutputType without action
   */
  export type CalendarCountOutputTypeCountCalendarZonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarZoneWhereInput
  }

  /**
   * CalendarCountOutputType without action
   */
  export type CalendarCountOutputTypeCountCalendarIndicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarIndicatorWhereInput
  }


  /**
   * Count Type CalendarZoneCountOutputType
   */

  export type CalendarZoneCountOutputType = {
    districts: number
  }

  export type CalendarZoneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    districts?: boolean | CalendarZoneCountOutputTypeCountDistrictsArgs
  }

  // Custom InputTypes
  /**
   * CalendarZoneCountOutputType without action
   */
  export type CalendarZoneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarZoneCountOutputType
     */
    select?: CalendarZoneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CalendarZoneCountOutputType without action
   */
  export type CalendarZoneCountOutputTypeCountDistrictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarZoneDistrictWhereInput
  }


  /**
   * Count Type StageCountOutputType
   */

  export type StageCountOutputType = {
    images: number
    thresholds: number
  }

  export type StageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | StageCountOutputTypeCountImagesArgs
    thresholds?: boolean | StageCountOutputTypeCountThresholdsArgs
  }

  // Custom InputTypes
  /**
   * StageCountOutputType without action
   */
  export type StageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageCountOutputType
     */
    select?: StageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StageCountOutputType without action
   */
  export type StageCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StageImageWhereInput
  }

  /**
   * StageCountOutputType without action
   */
  export type StageCountOutputTypeCountThresholdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StageThresholdWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Crop
   */

  export type AggregateCrop = {
    _count: CropCountAggregateOutputType | null
    _min: CropMinAggregateOutputType | null
    _max: CropMaxAggregateOutputType | null
  }

  export type CropMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CropMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CropCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CropMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CropMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CropCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CropAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Crop to aggregate.
     */
    where?: CropWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crops to fetch.
     */
    orderBy?: CropOrderByWithRelationInput | CropOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CropWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Crops
    **/
    _count?: true | CropCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CropMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CropMaxAggregateInputType
  }

  export type GetCropAggregateType<T extends CropAggregateArgs> = {
        [P in keyof T & keyof AggregateCrop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrop[P]>
      : GetScalarType<T[P], AggregateCrop[P]>
  }




  export type CropGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CropWhereInput
    orderBy?: CropOrderByWithAggregationInput | CropOrderByWithAggregationInput[]
    by: CropScalarFieldEnum[] | CropScalarFieldEnum
    having?: CropScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CropCountAggregateInputType | true
    _min?: CropMinAggregateInputType
    _max?: CropMaxAggregateInputType
  }

  export type CropGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: CropCountAggregateOutputType | null
    _min: CropMinAggregateOutputType | null
    _max: CropMaxAggregateOutputType | null
  }

  type GetCropGroupByPayload<T extends CropGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CropGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CropGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CropGroupByOutputType[P]>
            : GetScalarType<T[P], CropGroupByOutputType[P]>
        }
      >
    >


  export type CropSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    calendars?: boolean | Crop$calendarsArgs<ExtArgs>
    _count?: boolean | CropCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crop"]>

  export type CropSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["crop"]>

  export type CropSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CropInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calendars?: boolean | Crop$calendarsArgs<ExtArgs>
    _count?: boolean | CropCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CropIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CropPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Crop"
    objects: {
      calendars: Prisma.$CalendarPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["crop"]>
    composites: {}
  }

  type CropGetPayload<S extends boolean | null | undefined | CropDefaultArgs> = $Result.GetResult<Prisma.$CropPayload, S>

  type CropCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CropFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CropCountAggregateInputType | true
    }

  export interface CropDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Crop'], meta: { name: 'Crop' } }
    /**
     * Find zero or one Crop that matches the filter.
     * @param {CropFindUniqueArgs} args - Arguments to find a Crop
     * @example
     * // Get one Crop
     * const crop = await prisma.crop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CropFindUniqueArgs>(args: SelectSubset<T, CropFindUniqueArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Crop that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CropFindUniqueOrThrowArgs} args - Arguments to find a Crop
     * @example
     * // Get one Crop
     * const crop = await prisma.crop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CropFindUniqueOrThrowArgs>(args: SelectSubset<T, CropFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Crop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropFindFirstArgs} args - Arguments to find a Crop
     * @example
     * // Get one Crop
     * const crop = await prisma.crop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CropFindFirstArgs>(args?: SelectSubset<T, CropFindFirstArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Crop that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropFindFirstOrThrowArgs} args - Arguments to find a Crop
     * @example
     * // Get one Crop
     * const crop = await prisma.crop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CropFindFirstOrThrowArgs>(args?: SelectSubset<T, CropFindFirstOrThrowArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Crops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Crops
     * const crops = await prisma.crop.findMany()
     * 
     * // Get first 10 Crops
     * const crops = await prisma.crop.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cropWithIdOnly = await prisma.crop.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CropFindManyArgs>(args?: SelectSubset<T, CropFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Crop.
     * @param {CropCreateArgs} args - Arguments to create a Crop.
     * @example
     * // Create one Crop
     * const Crop = await prisma.crop.create({
     *   data: {
     *     // ... data to create a Crop
     *   }
     * })
     * 
     */
    create<T extends CropCreateArgs>(args: SelectSubset<T, CropCreateArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Crops.
     * @param {CropCreateManyArgs} args - Arguments to create many Crops.
     * @example
     * // Create many Crops
     * const crop = await prisma.crop.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CropCreateManyArgs>(args?: SelectSubset<T, CropCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Crops and returns the data saved in the database.
     * @param {CropCreateManyAndReturnArgs} args - Arguments to create many Crops.
     * @example
     * // Create many Crops
     * const crop = await prisma.crop.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Crops and only return the `id`
     * const cropWithIdOnly = await prisma.crop.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CropCreateManyAndReturnArgs>(args?: SelectSubset<T, CropCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Crop.
     * @param {CropDeleteArgs} args - Arguments to delete one Crop.
     * @example
     * // Delete one Crop
     * const Crop = await prisma.crop.delete({
     *   where: {
     *     // ... filter to delete one Crop
     *   }
     * })
     * 
     */
    delete<T extends CropDeleteArgs>(args: SelectSubset<T, CropDeleteArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Crop.
     * @param {CropUpdateArgs} args - Arguments to update one Crop.
     * @example
     * // Update one Crop
     * const crop = await prisma.crop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CropUpdateArgs>(args: SelectSubset<T, CropUpdateArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Crops.
     * @param {CropDeleteManyArgs} args - Arguments to filter Crops to delete.
     * @example
     * // Delete a few Crops
     * const { count } = await prisma.crop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CropDeleteManyArgs>(args?: SelectSubset<T, CropDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Crops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Crops
     * const crop = await prisma.crop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CropUpdateManyArgs>(args: SelectSubset<T, CropUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Crop.
     * @param {CropUpsertArgs} args - Arguments to update or create a Crop.
     * @example
     * // Update or create a Crop
     * const crop = await prisma.crop.upsert({
     *   create: {
     *     // ... data to create a Crop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Crop we want to update
     *   }
     * })
     */
    upsert<T extends CropUpsertArgs>(args: SelectSubset<T, CropUpsertArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Crops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropCountArgs} args - Arguments to filter Crops to count.
     * @example
     * // Count the number of Crops
     * const count = await prisma.crop.count({
     *   where: {
     *     // ... the filter for the Crops we want to count
     *   }
     * })
    **/
    count<T extends CropCountArgs>(
      args?: Subset<T, CropCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CropCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Crop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CropAggregateArgs>(args: Subset<T, CropAggregateArgs>): Prisma.PrismaPromise<GetCropAggregateType<T>>

    /**
     * Group by Crop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CropGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CropGroupByArgs['orderBy'] }
        : { orderBy?: CropGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CropGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCropGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Crop model
   */
  readonly fields: CropFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Crop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CropClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    calendars<T extends Crop$calendarsArgs<ExtArgs> = {}>(args?: Subset<T, Crop$calendarsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Crop model
   */ 
  interface CropFieldRefs {
    readonly id: FieldRef<"Crop", 'String'>
    readonly name: FieldRef<"Crop", 'String'>
    readonly description: FieldRef<"Crop", 'String'>
    readonly createdAt: FieldRef<"Crop", 'DateTime'>
    readonly updatedAt: FieldRef<"Crop", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Crop findUnique
   */
  export type CropFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * Filter, which Crop to fetch.
     */
    where: CropWhereUniqueInput
  }

  /**
   * Crop findUniqueOrThrow
   */
  export type CropFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * Filter, which Crop to fetch.
     */
    where: CropWhereUniqueInput
  }

  /**
   * Crop findFirst
   */
  export type CropFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * Filter, which Crop to fetch.
     */
    where?: CropWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crops to fetch.
     */
    orderBy?: CropOrderByWithRelationInput | CropOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Crops.
     */
    cursor?: CropWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Crops.
     */
    distinct?: CropScalarFieldEnum | CropScalarFieldEnum[]
  }

  /**
   * Crop findFirstOrThrow
   */
  export type CropFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * Filter, which Crop to fetch.
     */
    where?: CropWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crops to fetch.
     */
    orderBy?: CropOrderByWithRelationInput | CropOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Crops.
     */
    cursor?: CropWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Crops.
     */
    distinct?: CropScalarFieldEnum | CropScalarFieldEnum[]
  }

  /**
   * Crop findMany
   */
  export type CropFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * Filter, which Crops to fetch.
     */
    where?: CropWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crops to fetch.
     */
    orderBy?: CropOrderByWithRelationInput | CropOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Crops.
     */
    cursor?: CropWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crops.
     */
    skip?: number
    distinct?: CropScalarFieldEnum | CropScalarFieldEnum[]
  }

  /**
   * Crop create
   */
  export type CropCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * The data needed to create a Crop.
     */
    data: XOR<CropCreateInput, CropUncheckedCreateInput>
  }

  /**
   * Crop createMany
   */
  export type CropCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Crops.
     */
    data: CropCreateManyInput | CropCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Crop createManyAndReturn
   */
  export type CropCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Crops.
     */
    data: CropCreateManyInput | CropCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Crop update
   */
  export type CropUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * The data needed to update a Crop.
     */
    data: XOR<CropUpdateInput, CropUncheckedUpdateInput>
    /**
     * Choose, which Crop to update.
     */
    where: CropWhereUniqueInput
  }

  /**
   * Crop updateMany
   */
  export type CropUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Crops.
     */
    data: XOR<CropUpdateManyMutationInput, CropUncheckedUpdateManyInput>
    /**
     * Filter which Crops to update
     */
    where?: CropWhereInput
  }

  /**
   * Crop upsert
   */
  export type CropUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * The filter to search for the Crop to update in case it exists.
     */
    where: CropWhereUniqueInput
    /**
     * In case the Crop found by the `where` argument doesn't exist, create a new Crop with this data.
     */
    create: XOR<CropCreateInput, CropUncheckedCreateInput>
    /**
     * In case the Crop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CropUpdateInput, CropUncheckedUpdateInput>
  }

  /**
   * Crop delete
   */
  export type CropDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * Filter which Crop to delete.
     */
    where: CropWhereUniqueInput
  }

  /**
   * Crop deleteMany
   */
  export type CropDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Crops to delete
     */
    where?: CropWhereInput
  }

  /**
   * Crop.calendars
   */
  export type Crop$calendarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    where?: CalendarWhereInput
    orderBy?: CalendarOrderByWithRelationInput | CalendarOrderByWithRelationInput[]
    cursor?: CalendarWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarScalarFieldEnum | CalendarScalarFieldEnum[]
  }

  /**
   * Crop without action
   */
  export type CropDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
  }


  /**
   * Model IndicatorCategory
   */

  export type AggregateIndicatorCategory = {
    _count: IndicatorCategoryCountAggregateOutputType | null
    _avg: IndicatorCategoryAvgAggregateOutputType | null
    _sum: IndicatorCategorySumAggregateOutputType | null
    _min: IndicatorCategoryMinAggregateOutputType | null
    _max: IndicatorCategoryMaxAggregateOutputType | null
  }

  export type IndicatorCategoryAvgAggregateOutputType = {
    order: number | null
  }

  export type IndicatorCategorySumAggregateOutputType = {
    order: number | null
  }

  export type IndicatorCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IndicatorCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IndicatorCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IndicatorCategoryAvgAggregateInputType = {
    order?: true
  }

  export type IndicatorCategorySumAggregateInputType = {
    order?: true
  }

  export type IndicatorCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IndicatorCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IndicatorCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IndicatorCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IndicatorCategory to aggregate.
     */
    where?: IndicatorCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicatorCategories to fetch.
     */
    orderBy?: IndicatorCategoryOrderByWithRelationInput | IndicatorCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IndicatorCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicatorCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicatorCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IndicatorCategories
    **/
    _count?: true | IndicatorCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IndicatorCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IndicatorCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndicatorCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndicatorCategoryMaxAggregateInputType
  }

  export type GetIndicatorCategoryAggregateType<T extends IndicatorCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateIndicatorCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndicatorCategory[P]>
      : GetScalarType<T[P], AggregateIndicatorCategory[P]>
  }




  export type IndicatorCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicatorCategoryWhereInput
    orderBy?: IndicatorCategoryOrderByWithAggregationInput | IndicatorCategoryOrderByWithAggregationInput[]
    by: IndicatorCategoryScalarFieldEnum[] | IndicatorCategoryScalarFieldEnum
    having?: IndicatorCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndicatorCategoryCountAggregateInputType | true
    _avg?: IndicatorCategoryAvgAggregateInputType
    _sum?: IndicatorCategorySumAggregateInputType
    _min?: IndicatorCategoryMinAggregateInputType
    _max?: IndicatorCategoryMaxAggregateInputType
  }

  export type IndicatorCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    order: number
    createdAt: Date
    updatedAt: Date
    _count: IndicatorCategoryCountAggregateOutputType | null
    _avg: IndicatorCategoryAvgAggregateOutputType | null
    _sum: IndicatorCategorySumAggregateOutputType | null
    _min: IndicatorCategoryMinAggregateOutputType | null
    _max: IndicatorCategoryMaxAggregateOutputType | null
  }

  type GetIndicatorCategoryGroupByPayload<T extends IndicatorCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndicatorCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndicatorCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndicatorCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], IndicatorCategoryGroupByOutputType[P]>
        }
      >
    >


  export type IndicatorCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    indicators?: boolean | IndicatorCategory$indicatorsArgs<ExtArgs>
    _count?: boolean | IndicatorCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["indicatorCategory"]>

  export type IndicatorCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["indicatorCategory"]>

  export type IndicatorCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IndicatorCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicators?: boolean | IndicatorCategory$indicatorsArgs<ExtArgs>
    _count?: boolean | IndicatorCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IndicatorCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $IndicatorCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IndicatorCategory"
    objects: {
      indicators: Prisma.$IndicatorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["indicatorCategory"]>
    composites: {}
  }

  type IndicatorCategoryGetPayload<S extends boolean | null | undefined | IndicatorCategoryDefaultArgs> = $Result.GetResult<Prisma.$IndicatorCategoryPayload, S>

  type IndicatorCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IndicatorCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IndicatorCategoryCountAggregateInputType | true
    }

  export interface IndicatorCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IndicatorCategory'], meta: { name: 'IndicatorCategory' } }
    /**
     * Find zero or one IndicatorCategory that matches the filter.
     * @param {IndicatorCategoryFindUniqueArgs} args - Arguments to find a IndicatorCategory
     * @example
     * // Get one IndicatorCategory
     * const indicatorCategory = await prisma.indicatorCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IndicatorCategoryFindUniqueArgs>(args: SelectSubset<T, IndicatorCategoryFindUniqueArgs<ExtArgs>>): Prisma__IndicatorCategoryClient<$Result.GetResult<Prisma.$IndicatorCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IndicatorCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IndicatorCategoryFindUniqueOrThrowArgs} args - Arguments to find a IndicatorCategory
     * @example
     * // Get one IndicatorCategory
     * const indicatorCategory = await prisma.indicatorCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IndicatorCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, IndicatorCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IndicatorCategoryClient<$Result.GetResult<Prisma.$IndicatorCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IndicatorCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorCategoryFindFirstArgs} args - Arguments to find a IndicatorCategory
     * @example
     * // Get one IndicatorCategory
     * const indicatorCategory = await prisma.indicatorCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IndicatorCategoryFindFirstArgs>(args?: SelectSubset<T, IndicatorCategoryFindFirstArgs<ExtArgs>>): Prisma__IndicatorCategoryClient<$Result.GetResult<Prisma.$IndicatorCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IndicatorCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorCategoryFindFirstOrThrowArgs} args - Arguments to find a IndicatorCategory
     * @example
     * // Get one IndicatorCategory
     * const indicatorCategory = await prisma.indicatorCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IndicatorCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, IndicatorCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__IndicatorCategoryClient<$Result.GetResult<Prisma.$IndicatorCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IndicatorCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IndicatorCategories
     * const indicatorCategories = await prisma.indicatorCategory.findMany()
     * 
     * // Get first 10 IndicatorCategories
     * const indicatorCategories = await prisma.indicatorCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const indicatorCategoryWithIdOnly = await prisma.indicatorCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IndicatorCategoryFindManyArgs>(args?: SelectSubset<T, IndicatorCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IndicatorCategory.
     * @param {IndicatorCategoryCreateArgs} args - Arguments to create a IndicatorCategory.
     * @example
     * // Create one IndicatorCategory
     * const IndicatorCategory = await prisma.indicatorCategory.create({
     *   data: {
     *     // ... data to create a IndicatorCategory
     *   }
     * })
     * 
     */
    create<T extends IndicatorCategoryCreateArgs>(args: SelectSubset<T, IndicatorCategoryCreateArgs<ExtArgs>>): Prisma__IndicatorCategoryClient<$Result.GetResult<Prisma.$IndicatorCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IndicatorCategories.
     * @param {IndicatorCategoryCreateManyArgs} args - Arguments to create many IndicatorCategories.
     * @example
     * // Create many IndicatorCategories
     * const indicatorCategory = await prisma.indicatorCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IndicatorCategoryCreateManyArgs>(args?: SelectSubset<T, IndicatorCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IndicatorCategories and returns the data saved in the database.
     * @param {IndicatorCategoryCreateManyAndReturnArgs} args - Arguments to create many IndicatorCategories.
     * @example
     * // Create many IndicatorCategories
     * const indicatorCategory = await prisma.indicatorCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IndicatorCategories and only return the `id`
     * const indicatorCategoryWithIdOnly = await prisma.indicatorCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IndicatorCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, IndicatorCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IndicatorCategory.
     * @param {IndicatorCategoryDeleteArgs} args - Arguments to delete one IndicatorCategory.
     * @example
     * // Delete one IndicatorCategory
     * const IndicatorCategory = await prisma.indicatorCategory.delete({
     *   where: {
     *     // ... filter to delete one IndicatorCategory
     *   }
     * })
     * 
     */
    delete<T extends IndicatorCategoryDeleteArgs>(args: SelectSubset<T, IndicatorCategoryDeleteArgs<ExtArgs>>): Prisma__IndicatorCategoryClient<$Result.GetResult<Prisma.$IndicatorCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IndicatorCategory.
     * @param {IndicatorCategoryUpdateArgs} args - Arguments to update one IndicatorCategory.
     * @example
     * // Update one IndicatorCategory
     * const indicatorCategory = await prisma.indicatorCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IndicatorCategoryUpdateArgs>(args: SelectSubset<T, IndicatorCategoryUpdateArgs<ExtArgs>>): Prisma__IndicatorCategoryClient<$Result.GetResult<Prisma.$IndicatorCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IndicatorCategories.
     * @param {IndicatorCategoryDeleteManyArgs} args - Arguments to filter IndicatorCategories to delete.
     * @example
     * // Delete a few IndicatorCategories
     * const { count } = await prisma.indicatorCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IndicatorCategoryDeleteManyArgs>(args?: SelectSubset<T, IndicatorCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IndicatorCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IndicatorCategories
     * const indicatorCategory = await prisma.indicatorCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IndicatorCategoryUpdateManyArgs>(args: SelectSubset<T, IndicatorCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IndicatorCategory.
     * @param {IndicatorCategoryUpsertArgs} args - Arguments to update or create a IndicatorCategory.
     * @example
     * // Update or create a IndicatorCategory
     * const indicatorCategory = await prisma.indicatorCategory.upsert({
     *   create: {
     *     // ... data to create a IndicatorCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IndicatorCategory we want to update
     *   }
     * })
     */
    upsert<T extends IndicatorCategoryUpsertArgs>(args: SelectSubset<T, IndicatorCategoryUpsertArgs<ExtArgs>>): Prisma__IndicatorCategoryClient<$Result.GetResult<Prisma.$IndicatorCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IndicatorCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorCategoryCountArgs} args - Arguments to filter IndicatorCategories to count.
     * @example
     * // Count the number of IndicatorCategories
     * const count = await prisma.indicatorCategory.count({
     *   where: {
     *     // ... the filter for the IndicatorCategories we want to count
     *   }
     * })
    **/
    count<T extends IndicatorCategoryCountArgs>(
      args?: Subset<T, IndicatorCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndicatorCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IndicatorCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndicatorCategoryAggregateArgs>(args: Subset<T, IndicatorCategoryAggregateArgs>): Prisma.PrismaPromise<GetIndicatorCategoryAggregateType<T>>

    /**
     * Group by IndicatorCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IndicatorCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndicatorCategoryGroupByArgs['orderBy'] }
        : { orderBy?: IndicatorCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IndicatorCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndicatorCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IndicatorCategory model
   */
  readonly fields: IndicatorCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IndicatorCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IndicatorCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    indicators<T extends IndicatorCategory$indicatorsArgs<ExtArgs> = {}>(args?: Subset<T, IndicatorCategory$indicatorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IndicatorCategory model
   */ 
  interface IndicatorCategoryFieldRefs {
    readonly id: FieldRef<"IndicatorCategory", 'String'>
    readonly name: FieldRef<"IndicatorCategory", 'String'>
    readonly description: FieldRef<"IndicatorCategory", 'String'>
    readonly order: FieldRef<"IndicatorCategory", 'Int'>
    readonly createdAt: FieldRef<"IndicatorCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"IndicatorCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IndicatorCategory findUnique
   */
  export type IndicatorCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCategory
     */
    select?: IndicatorCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorCategory to fetch.
     */
    where: IndicatorCategoryWhereUniqueInput
  }

  /**
   * IndicatorCategory findUniqueOrThrow
   */
  export type IndicatorCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCategory
     */
    select?: IndicatorCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorCategory to fetch.
     */
    where: IndicatorCategoryWhereUniqueInput
  }

  /**
   * IndicatorCategory findFirst
   */
  export type IndicatorCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCategory
     */
    select?: IndicatorCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorCategory to fetch.
     */
    where?: IndicatorCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicatorCategories to fetch.
     */
    orderBy?: IndicatorCategoryOrderByWithRelationInput | IndicatorCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IndicatorCategories.
     */
    cursor?: IndicatorCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicatorCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicatorCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IndicatorCategories.
     */
    distinct?: IndicatorCategoryScalarFieldEnum | IndicatorCategoryScalarFieldEnum[]
  }

  /**
   * IndicatorCategory findFirstOrThrow
   */
  export type IndicatorCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCategory
     */
    select?: IndicatorCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorCategory to fetch.
     */
    where?: IndicatorCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicatorCategories to fetch.
     */
    orderBy?: IndicatorCategoryOrderByWithRelationInput | IndicatorCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IndicatorCategories.
     */
    cursor?: IndicatorCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicatorCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicatorCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IndicatorCategories.
     */
    distinct?: IndicatorCategoryScalarFieldEnum | IndicatorCategoryScalarFieldEnum[]
  }

  /**
   * IndicatorCategory findMany
   */
  export type IndicatorCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCategory
     */
    select?: IndicatorCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorCategories to fetch.
     */
    where?: IndicatorCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicatorCategories to fetch.
     */
    orderBy?: IndicatorCategoryOrderByWithRelationInput | IndicatorCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IndicatorCategories.
     */
    cursor?: IndicatorCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicatorCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicatorCategories.
     */
    skip?: number
    distinct?: IndicatorCategoryScalarFieldEnum | IndicatorCategoryScalarFieldEnum[]
  }

  /**
   * IndicatorCategory create
   */
  export type IndicatorCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCategory
     */
    select?: IndicatorCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a IndicatorCategory.
     */
    data: XOR<IndicatorCategoryCreateInput, IndicatorCategoryUncheckedCreateInput>
  }

  /**
   * IndicatorCategory createMany
   */
  export type IndicatorCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IndicatorCategories.
     */
    data: IndicatorCategoryCreateManyInput | IndicatorCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IndicatorCategory createManyAndReturn
   */
  export type IndicatorCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCategory
     */
    select?: IndicatorCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IndicatorCategories.
     */
    data: IndicatorCategoryCreateManyInput | IndicatorCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IndicatorCategory update
   */
  export type IndicatorCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCategory
     */
    select?: IndicatorCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a IndicatorCategory.
     */
    data: XOR<IndicatorCategoryUpdateInput, IndicatorCategoryUncheckedUpdateInput>
    /**
     * Choose, which IndicatorCategory to update.
     */
    where: IndicatorCategoryWhereUniqueInput
  }

  /**
   * IndicatorCategory updateMany
   */
  export type IndicatorCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IndicatorCategories.
     */
    data: XOR<IndicatorCategoryUpdateManyMutationInput, IndicatorCategoryUncheckedUpdateManyInput>
    /**
     * Filter which IndicatorCategories to update
     */
    where?: IndicatorCategoryWhereInput
  }

  /**
   * IndicatorCategory upsert
   */
  export type IndicatorCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCategory
     */
    select?: IndicatorCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the IndicatorCategory to update in case it exists.
     */
    where: IndicatorCategoryWhereUniqueInput
    /**
     * In case the IndicatorCategory found by the `where` argument doesn't exist, create a new IndicatorCategory with this data.
     */
    create: XOR<IndicatorCategoryCreateInput, IndicatorCategoryUncheckedCreateInput>
    /**
     * In case the IndicatorCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IndicatorCategoryUpdateInput, IndicatorCategoryUncheckedUpdateInput>
  }

  /**
   * IndicatorCategory delete
   */
  export type IndicatorCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCategory
     */
    select?: IndicatorCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCategoryInclude<ExtArgs> | null
    /**
     * Filter which IndicatorCategory to delete.
     */
    where: IndicatorCategoryWhereUniqueInput
  }

  /**
   * IndicatorCategory deleteMany
   */
  export type IndicatorCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IndicatorCategories to delete
     */
    where?: IndicatorCategoryWhereInput
  }

  /**
   * IndicatorCategory.indicators
   */
  export type IndicatorCategory$indicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    where?: IndicatorWhereInput
    orderBy?: IndicatorOrderByWithRelationInput | IndicatorOrderByWithRelationInput[]
    cursor?: IndicatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IndicatorScalarFieldEnum | IndicatorScalarFieldEnum[]
  }

  /**
   * IndicatorCategory without action
   */
  export type IndicatorCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCategory
     */
    select?: IndicatorCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Indicator
   */

  export type AggregateIndicator = {
    _count: IndicatorCountAggregateOutputType | null
    _avg: IndicatorAvgAggregateOutputType | null
    _sum: IndicatorSumAggregateOutputType | null
    _min: IndicatorMinAggregateOutputType | null
    _max: IndicatorMaxAggregateOutputType | null
  }

  export type IndicatorAvgAggregateOutputType = {
    defaultMin: number | null
    defaultMax: number | null
  }

  export type IndicatorSumAggregateOutputType = {
    defaultMin: number | null
    defaultMax: number | null
  }

  export type IndicatorMinAggregateOutputType = {
    id: string | null
    categoryId: string | null
    name: string | null
    unit: string | null
    description: string | null
    source: string | null
    defaultMin: number | null
    defaultMax: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IndicatorMaxAggregateOutputType = {
    id: string | null
    categoryId: string | null
    name: string | null
    unit: string | null
    description: string | null
    source: string | null
    defaultMin: number | null
    defaultMax: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IndicatorCountAggregateOutputType = {
    id: number
    categoryId: number
    name: number
    unit: number
    description: number
    source: number
    defaultMin: number
    defaultMax: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IndicatorAvgAggregateInputType = {
    defaultMin?: true
    defaultMax?: true
  }

  export type IndicatorSumAggregateInputType = {
    defaultMin?: true
    defaultMax?: true
  }

  export type IndicatorMinAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    unit?: true
    description?: true
    source?: true
    defaultMin?: true
    defaultMax?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IndicatorMaxAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    unit?: true
    description?: true
    source?: true
    defaultMin?: true
    defaultMax?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IndicatorCountAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    unit?: true
    description?: true
    source?: true
    defaultMin?: true
    defaultMax?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IndicatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Indicator to aggregate.
     */
    where?: IndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Indicators to fetch.
     */
    orderBy?: IndicatorOrderByWithRelationInput | IndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Indicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Indicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Indicators
    **/
    _count?: true | IndicatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IndicatorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IndicatorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndicatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndicatorMaxAggregateInputType
  }

  export type GetIndicatorAggregateType<T extends IndicatorAggregateArgs> = {
        [P in keyof T & keyof AggregateIndicator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndicator[P]>
      : GetScalarType<T[P], AggregateIndicator[P]>
  }




  export type IndicatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicatorWhereInput
    orderBy?: IndicatorOrderByWithAggregationInput | IndicatorOrderByWithAggregationInput[]
    by: IndicatorScalarFieldEnum[] | IndicatorScalarFieldEnum
    having?: IndicatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndicatorCountAggregateInputType | true
    _avg?: IndicatorAvgAggregateInputType
    _sum?: IndicatorSumAggregateInputType
    _min?: IndicatorMinAggregateInputType
    _max?: IndicatorMaxAggregateInputType
  }

  export type IndicatorGroupByOutputType = {
    id: string
    categoryId: string
    name: string
    unit: string
    description: string | null
    source: string
    defaultMin: number | null
    defaultMax: number | null
    createdAt: Date
    updatedAt: Date
    _count: IndicatorCountAggregateOutputType | null
    _avg: IndicatorAvgAggregateOutputType | null
    _sum: IndicatorSumAggregateOutputType | null
    _min: IndicatorMinAggregateOutputType | null
    _max: IndicatorMaxAggregateOutputType | null
  }

  type GetIndicatorGroupByPayload<T extends IndicatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndicatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndicatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndicatorGroupByOutputType[P]>
            : GetScalarType<T[P], IndicatorGroupByOutputType[P]>
        }
      >
    >


  export type IndicatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    name?: boolean
    unit?: boolean
    description?: boolean
    source?: boolean
    defaultMin?: boolean
    defaultMax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | IndicatorCategoryDefaultArgs<ExtArgs>
    thresholds?: boolean | Indicator$thresholdsArgs<ExtArgs>
    calendarIndicators?: boolean | Indicator$calendarIndicatorsArgs<ExtArgs>
    _count?: boolean | IndicatorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["indicator"]>

  export type IndicatorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    name?: boolean
    unit?: boolean
    description?: boolean
    source?: boolean
    defaultMin?: boolean
    defaultMax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | IndicatorCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["indicator"]>

  export type IndicatorSelectScalar = {
    id?: boolean
    categoryId?: boolean
    name?: boolean
    unit?: boolean
    description?: boolean
    source?: boolean
    defaultMin?: boolean
    defaultMax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IndicatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | IndicatorCategoryDefaultArgs<ExtArgs>
    thresholds?: boolean | Indicator$thresholdsArgs<ExtArgs>
    calendarIndicators?: boolean | Indicator$calendarIndicatorsArgs<ExtArgs>
    _count?: boolean | IndicatorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IndicatorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | IndicatorCategoryDefaultArgs<ExtArgs>
  }

  export type $IndicatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Indicator"
    objects: {
      category: Prisma.$IndicatorCategoryPayload<ExtArgs>
      thresholds: Prisma.$StageThresholdPayload<ExtArgs>[]
      calendarIndicators: Prisma.$CalendarIndicatorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      categoryId: string
      name: string
      unit: string
      description: string | null
      source: string
      defaultMin: number | null
      defaultMax: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["indicator"]>
    composites: {}
  }

  type IndicatorGetPayload<S extends boolean | null | undefined | IndicatorDefaultArgs> = $Result.GetResult<Prisma.$IndicatorPayload, S>

  type IndicatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IndicatorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IndicatorCountAggregateInputType | true
    }

  export interface IndicatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Indicator'], meta: { name: 'Indicator' } }
    /**
     * Find zero or one Indicator that matches the filter.
     * @param {IndicatorFindUniqueArgs} args - Arguments to find a Indicator
     * @example
     * // Get one Indicator
     * const indicator = await prisma.indicator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IndicatorFindUniqueArgs>(args: SelectSubset<T, IndicatorFindUniqueArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Indicator that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IndicatorFindUniqueOrThrowArgs} args - Arguments to find a Indicator
     * @example
     * // Get one Indicator
     * const indicator = await prisma.indicator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IndicatorFindUniqueOrThrowArgs>(args: SelectSubset<T, IndicatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Indicator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorFindFirstArgs} args - Arguments to find a Indicator
     * @example
     * // Get one Indicator
     * const indicator = await prisma.indicator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IndicatorFindFirstArgs>(args?: SelectSubset<T, IndicatorFindFirstArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Indicator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorFindFirstOrThrowArgs} args - Arguments to find a Indicator
     * @example
     * // Get one Indicator
     * const indicator = await prisma.indicator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IndicatorFindFirstOrThrowArgs>(args?: SelectSubset<T, IndicatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Indicators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Indicators
     * const indicators = await prisma.indicator.findMany()
     * 
     * // Get first 10 Indicators
     * const indicators = await prisma.indicator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const indicatorWithIdOnly = await prisma.indicator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IndicatorFindManyArgs>(args?: SelectSubset<T, IndicatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Indicator.
     * @param {IndicatorCreateArgs} args - Arguments to create a Indicator.
     * @example
     * // Create one Indicator
     * const Indicator = await prisma.indicator.create({
     *   data: {
     *     // ... data to create a Indicator
     *   }
     * })
     * 
     */
    create<T extends IndicatorCreateArgs>(args: SelectSubset<T, IndicatorCreateArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Indicators.
     * @param {IndicatorCreateManyArgs} args - Arguments to create many Indicators.
     * @example
     * // Create many Indicators
     * const indicator = await prisma.indicator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IndicatorCreateManyArgs>(args?: SelectSubset<T, IndicatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Indicators and returns the data saved in the database.
     * @param {IndicatorCreateManyAndReturnArgs} args - Arguments to create many Indicators.
     * @example
     * // Create many Indicators
     * const indicator = await prisma.indicator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Indicators and only return the `id`
     * const indicatorWithIdOnly = await prisma.indicator.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IndicatorCreateManyAndReturnArgs>(args?: SelectSubset<T, IndicatorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Indicator.
     * @param {IndicatorDeleteArgs} args - Arguments to delete one Indicator.
     * @example
     * // Delete one Indicator
     * const Indicator = await prisma.indicator.delete({
     *   where: {
     *     // ... filter to delete one Indicator
     *   }
     * })
     * 
     */
    delete<T extends IndicatorDeleteArgs>(args: SelectSubset<T, IndicatorDeleteArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Indicator.
     * @param {IndicatorUpdateArgs} args - Arguments to update one Indicator.
     * @example
     * // Update one Indicator
     * const indicator = await prisma.indicator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IndicatorUpdateArgs>(args: SelectSubset<T, IndicatorUpdateArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Indicators.
     * @param {IndicatorDeleteManyArgs} args - Arguments to filter Indicators to delete.
     * @example
     * // Delete a few Indicators
     * const { count } = await prisma.indicator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IndicatorDeleteManyArgs>(args?: SelectSubset<T, IndicatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Indicators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Indicators
     * const indicator = await prisma.indicator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IndicatorUpdateManyArgs>(args: SelectSubset<T, IndicatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Indicator.
     * @param {IndicatorUpsertArgs} args - Arguments to update or create a Indicator.
     * @example
     * // Update or create a Indicator
     * const indicator = await prisma.indicator.upsert({
     *   create: {
     *     // ... data to create a Indicator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Indicator we want to update
     *   }
     * })
     */
    upsert<T extends IndicatorUpsertArgs>(args: SelectSubset<T, IndicatorUpsertArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Indicators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorCountArgs} args - Arguments to filter Indicators to count.
     * @example
     * // Count the number of Indicators
     * const count = await prisma.indicator.count({
     *   where: {
     *     // ... the filter for the Indicators we want to count
     *   }
     * })
    **/
    count<T extends IndicatorCountArgs>(
      args?: Subset<T, IndicatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndicatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Indicator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndicatorAggregateArgs>(args: Subset<T, IndicatorAggregateArgs>): Prisma.PrismaPromise<GetIndicatorAggregateType<T>>

    /**
     * Group by Indicator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IndicatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndicatorGroupByArgs['orderBy'] }
        : { orderBy?: IndicatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IndicatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndicatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Indicator model
   */
  readonly fields: IndicatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Indicator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IndicatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends IndicatorCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IndicatorCategoryDefaultArgs<ExtArgs>>): Prisma__IndicatorCategoryClient<$Result.GetResult<Prisma.$IndicatorCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    thresholds<T extends Indicator$thresholdsArgs<ExtArgs> = {}>(args?: Subset<T, Indicator$thresholdsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StageThresholdPayload<ExtArgs>, T, "findMany"> | Null>
    calendarIndicators<T extends Indicator$calendarIndicatorsArgs<ExtArgs> = {}>(args?: Subset<T, Indicator$calendarIndicatorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarIndicatorPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Indicator model
   */ 
  interface IndicatorFieldRefs {
    readonly id: FieldRef<"Indicator", 'String'>
    readonly categoryId: FieldRef<"Indicator", 'String'>
    readonly name: FieldRef<"Indicator", 'String'>
    readonly unit: FieldRef<"Indicator", 'String'>
    readonly description: FieldRef<"Indicator", 'String'>
    readonly source: FieldRef<"Indicator", 'String'>
    readonly defaultMin: FieldRef<"Indicator", 'Float'>
    readonly defaultMax: FieldRef<"Indicator", 'Float'>
    readonly createdAt: FieldRef<"Indicator", 'DateTime'>
    readonly updatedAt: FieldRef<"Indicator", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Indicator findUnique
   */
  export type IndicatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * Filter, which Indicator to fetch.
     */
    where: IndicatorWhereUniqueInput
  }

  /**
   * Indicator findUniqueOrThrow
   */
  export type IndicatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * Filter, which Indicator to fetch.
     */
    where: IndicatorWhereUniqueInput
  }

  /**
   * Indicator findFirst
   */
  export type IndicatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * Filter, which Indicator to fetch.
     */
    where?: IndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Indicators to fetch.
     */
    orderBy?: IndicatorOrderByWithRelationInput | IndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Indicators.
     */
    cursor?: IndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Indicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Indicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Indicators.
     */
    distinct?: IndicatorScalarFieldEnum | IndicatorScalarFieldEnum[]
  }

  /**
   * Indicator findFirstOrThrow
   */
  export type IndicatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * Filter, which Indicator to fetch.
     */
    where?: IndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Indicators to fetch.
     */
    orderBy?: IndicatorOrderByWithRelationInput | IndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Indicators.
     */
    cursor?: IndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Indicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Indicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Indicators.
     */
    distinct?: IndicatorScalarFieldEnum | IndicatorScalarFieldEnum[]
  }

  /**
   * Indicator findMany
   */
  export type IndicatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * Filter, which Indicators to fetch.
     */
    where?: IndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Indicators to fetch.
     */
    orderBy?: IndicatorOrderByWithRelationInput | IndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Indicators.
     */
    cursor?: IndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Indicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Indicators.
     */
    skip?: number
    distinct?: IndicatorScalarFieldEnum | IndicatorScalarFieldEnum[]
  }

  /**
   * Indicator create
   */
  export type IndicatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * The data needed to create a Indicator.
     */
    data: XOR<IndicatorCreateInput, IndicatorUncheckedCreateInput>
  }

  /**
   * Indicator createMany
   */
  export type IndicatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Indicators.
     */
    data: IndicatorCreateManyInput | IndicatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Indicator createManyAndReturn
   */
  export type IndicatorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Indicators.
     */
    data: IndicatorCreateManyInput | IndicatorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Indicator update
   */
  export type IndicatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * The data needed to update a Indicator.
     */
    data: XOR<IndicatorUpdateInput, IndicatorUncheckedUpdateInput>
    /**
     * Choose, which Indicator to update.
     */
    where: IndicatorWhereUniqueInput
  }

  /**
   * Indicator updateMany
   */
  export type IndicatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Indicators.
     */
    data: XOR<IndicatorUpdateManyMutationInput, IndicatorUncheckedUpdateManyInput>
    /**
     * Filter which Indicators to update
     */
    where?: IndicatorWhereInput
  }

  /**
   * Indicator upsert
   */
  export type IndicatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * The filter to search for the Indicator to update in case it exists.
     */
    where: IndicatorWhereUniqueInput
    /**
     * In case the Indicator found by the `where` argument doesn't exist, create a new Indicator with this data.
     */
    create: XOR<IndicatorCreateInput, IndicatorUncheckedCreateInput>
    /**
     * In case the Indicator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IndicatorUpdateInput, IndicatorUncheckedUpdateInput>
  }

  /**
   * Indicator delete
   */
  export type IndicatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * Filter which Indicator to delete.
     */
    where: IndicatorWhereUniqueInput
  }

  /**
   * Indicator deleteMany
   */
  export type IndicatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Indicators to delete
     */
    where?: IndicatorWhereInput
  }

  /**
   * Indicator.thresholds
   */
  export type Indicator$thresholdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageThreshold
     */
    select?: StageThresholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageThresholdInclude<ExtArgs> | null
    where?: StageThresholdWhereInput
    orderBy?: StageThresholdOrderByWithRelationInput | StageThresholdOrderByWithRelationInput[]
    cursor?: StageThresholdWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StageThresholdScalarFieldEnum | StageThresholdScalarFieldEnum[]
  }

  /**
   * Indicator.calendarIndicators
   */
  export type Indicator$calendarIndicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarIndicator
     */
    select?: CalendarIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarIndicatorInclude<ExtArgs> | null
    where?: CalendarIndicatorWhereInput
    orderBy?: CalendarIndicatorOrderByWithRelationInput | CalendarIndicatorOrderByWithRelationInput[]
    cursor?: CalendarIndicatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarIndicatorScalarFieldEnum | CalendarIndicatorScalarFieldEnum[]
  }

  /**
   * Indicator without action
   */
  export type IndicatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
  }


  /**
   * Model Zone
   */

  export type AggregateZone = {
    _count: ZoneCountAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  export type ZoneMinAggregateOutputType = {
    id: string | null
    zoneName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ZoneMaxAggregateOutputType = {
    id: string | null
    zoneName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ZoneCountAggregateOutputType = {
    id: number
    zoneName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ZoneMinAggregateInputType = {
    id?: true
    zoneName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ZoneMaxAggregateInputType = {
    id?: true
    zoneName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ZoneCountAggregateInputType = {
    id?: true
    zoneName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ZoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Zone to aggregate.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Zones
    **/
    _count?: true | ZoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZoneMaxAggregateInputType
  }

  export type GetZoneAggregateType<T extends ZoneAggregateArgs> = {
        [P in keyof T & keyof AggregateZone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZone[P]>
      : GetScalarType<T[P], AggregateZone[P]>
  }




  export type ZoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoneWhereInput
    orderBy?: ZoneOrderByWithAggregationInput | ZoneOrderByWithAggregationInput[]
    by: ZoneScalarFieldEnum[] | ZoneScalarFieldEnum
    having?: ZoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZoneCountAggregateInputType | true
    _min?: ZoneMinAggregateInputType
    _max?: ZoneMaxAggregateInputType
  }

  export type ZoneGroupByOutputType = {
    id: string
    zoneName: string
    createdAt: Date
    updatedAt: Date
    _count: ZoneCountAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  type GetZoneGroupByPayload<T extends ZoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZoneGroupByOutputType[P]>
            : GetScalarType<T[P], ZoneGroupByOutputType[P]>
        }
      >
    >


  export type ZoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zoneName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    zoneDistricts?: boolean | Zone$zoneDistrictsArgs<ExtArgs>
    calendarZones?: boolean | Zone$calendarZonesArgs<ExtArgs>
    _count?: boolean | ZoneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zoneName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectScalar = {
    id?: boolean
    zoneName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ZoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zoneDistricts?: boolean | Zone$zoneDistrictsArgs<ExtArgs>
    calendarZones?: boolean | Zone$calendarZonesArgs<ExtArgs>
    _count?: boolean | ZoneCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ZoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ZonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Zone"
    objects: {
      zoneDistricts: Prisma.$ZoneDistrictPayload<ExtArgs>[]
      calendarZones: Prisma.$CalendarZonePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      zoneName: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["zone"]>
    composites: {}
  }

  type ZoneGetPayload<S extends boolean | null | undefined | ZoneDefaultArgs> = $Result.GetResult<Prisma.$ZonePayload, S>

  type ZoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ZoneFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ZoneCountAggregateInputType | true
    }

  export interface ZoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Zone'], meta: { name: 'Zone' } }
    /**
     * Find zero or one Zone that matches the filter.
     * @param {ZoneFindUniqueArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ZoneFindUniqueArgs>(args: SelectSubset<T, ZoneFindUniqueArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Zone that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ZoneFindUniqueOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ZoneFindUniqueOrThrowArgs>(args: SelectSubset<T, ZoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Zone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindFirstArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ZoneFindFirstArgs>(args?: SelectSubset<T, ZoneFindFirstArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Zone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindFirstOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ZoneFindFirstOrThrowArgs>(args?: SelectSubset<T, ZoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Zones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Zones
     * const zones = await prisma.zone.findMany()
     * 
     * // Get first 10 Zones
     * const zones = await prisma.zone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zoneWithIdOnly = await prisma.zone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ZoneFindManyArgs>(args?: SelectSubset<T, ZoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Zone.
     * @param {ZoneCreateArgs} args - Arguments to create a Zone.
     * @example
     * // Create one Zone
     * const Zone = await prisma.zone.create({
     *   data: {
     *     // ... data to create a Zone
     *   }
     * })
     * 
     */
    create<T extends ZoneCreateArgs>(args: SelectSubset<T, ZoneCreateArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Zones.
     * @param {ZoneCreateManyArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zone = await prisma.zone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ZoneCreateManyArgs>(args?: SelectSubset<T, ZoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Zones and returns the data saved in the database.
     * @param {ZoneCreateManyAndReturnArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zone = await prisma.zone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Zones and only return the `id`
     * const zoneWithIdOnly = await prisma.zone.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ZoneCreateManyAndReturnArgs>(args?: SelectSubset<T, ZoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Zone.
     * @param {ZoneDeleteArgs} args - Arguments to delete one Zone.
     * @example
     * // Delete one Zone
     * const Zone = await prisma.zone.delete({
     *   where: {
     *     // ... filter to delete one Zone
     *   }
     * })
     * 
     */
    delete<T extends ZoneDeleteArgs>(args: SelectSubset<T, ZoneDeleteArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Zone.
     * @param {ZoneUpdateArgs} args - Arguments to update one Zone.
     * @example
     * // Update one Zone
     * const zone = await prisma.zone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ZoneUpdateArgs>(args: SelectSubset<T, ZoneUpdateArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Zones.
     * @param {ZoneDeleteManyArgs} args - Arguments to filter Zones to delete.
     * @example
     * // Delete a few Zones
     * const { count } = await prisma.zone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ZoneDeleteManyArgs>(args?: SelectSubset<T, ZoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Zones
     * const zone = await prisma.zone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ZoneUpdateManyArgs>(args: SelectSubset<T, ZoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Zone.
     * @param {ZoneUpsertArgs} args - Arguments to update or create a Zone.
     * @example
     * // Update or create a Zone
     * const zone = await prisma.zone.upsert({
     *   create: {
     *     // ... data to create a Zone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Zone we want to update
     *   }
     * })
     */
    upsert<T extends ZoneUpsertArgs>(args: SelectSubset<T, ZoneUpsertArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneCountArgs} args - Arguments to filter Zones to count.
     * @example
     * // Count the number of Zones
     * const count = await prisma.zone.count({
     *   where: {
     *     // ... the filter for the Zones we want to count
     *   }
     * })
    **/
    count<T extends ZoneCountArgs>(
      args?: Subset<T, ZoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZoneAggregateArgs>(args: Subset<T, ZoneAggregateArgs>): Prisma.PrismaPromise<GetZoneAggregateType<T>>

    /**
     * Group by Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZoneGroupByArgs['orderBy'] }
        : { orderBy?: ZoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Zone model
   */
  readonly fields: ZoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Zone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ZoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    zoneDistricts<T extends Zone$zoneDistrictsArgs<ExtArgs> = {}>(args?: Subset<T, Zone$zoneDistrictsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZoneDistrictPayload<ExtArgs>, T, "findMany"> | Null>
    calendarZones<T extends Zone$calendarZonesArgs<ExtArgs> = {}>(args?: Subset<T, Zone$calendarZonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarZonePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Zone model
   */ 
  interface ZoneFieldRefs {
    readonly id: FieldRef<"Zone", 'String'>
    readonly zoneName: FieldRef<"Zone", 'String'>
    readonly createdAt: FieldRef<"Zone", 'DateTime'>
    readonly updatedAt: FieldRef<"Zone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Zone findUnique
   */
  export type ZoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone findUniqueOrThrow
   */
  export type ZoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone findFirst
   */
  export type ZoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone findFirstOrThrow
   */
  export type ZoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone findMany
   */
  export type ZoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zones to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone create
   */
  export type ZoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The data needed to create a Zone.
     */
    data: XOR<ZoneCreateInput, ZoneUncheckedCreateInput>
  }

  /**
   * Zone createMany
   */
  export type ZoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Zones.
     */
    data: ZoneCreateManyInput | ZoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Zone createManyAndReturn
   */
  export type ZoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Zones.
     */
    data: ZoneCreateManyInput | ZoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Zone update
   */
  export type ZoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The data needed to update a Zone.
     */
    data: XOR<ZoneUpdateInput, ZoneUncheckedUpdateInput>
    /**
     * Choose, which Zone to update.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone updateMany
   */
  export type ZoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Zones.
     */
    data: XOR<ZoneUpdateManyMutationInput, ZoneUncheckedUpdateManyInput>
    /**
     * Filter which Zones to update
     */
    where?: ZoneWhereInput
  }

  /**
   * Zone upsert
   */
  export type ZoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The filter to search for the Zone to update in case it exists.
     */
    where: ZoneWhereUniqueInput
    /**
     * In case the Zone found by the `where` argument doesn't exist, create a new Zone with this data.
     */
    create: XOR<ZoneCreateInput, ZoneUncheckedCreateInput>
    /**
     * In case the Zone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ZoneUpdateInput, ZoneUncheckedUpdateInput>
  }

  /**
   * Zone delete
   */
  export type ZoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter which Zone to delete.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone deleteMany
   */
  export type ZoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Zones to delete
     */
    where?: ZoneWhereInput
  }

  /**
   * Zone.zoneDistricts
   */
  export type Zone$zoneDistrictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneDistrict
     */
    select?: ZoneDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneDistrictInclude<ExtArgs> | null
    where?: ZoneDistrictWhereInput
    orderBy?: ZoneDistrictOrderByWithRelationInput | ZoneDistrictOrderByWithRelationInput[]
    cursor?: ZoneDistrictWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZoneDistrictScalarFieldEnum | ZoneDistrictScalarFieldEnum[]
  }

  /**
   * Zone.calendarZones
   */
  export type Zone$calendarZonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarZone
     */
    select?: CalendarZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarZoneInclude<ExtArgs> | null
    where?: CalendarZoneWhereInput
    orderBy?: CalendarZoneOrderByWithRelationInput | CalendarZoneOrderByWithRelationInput[]
    cursor?: CalendarZoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarZoneScalarFieldEnum | CalendarZoneScalarFieldEnum[]
  }

  /**
   * Zone without action
   */
  export type ZoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
  }


  /**
   * Model City
   */

  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityAvgAggregateOutputType = {
    id: number | null
  }

  export type CitySumAggregateOutputType = {
    id: number | null
  }

  export type CityMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CityMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CityAvgAggregateInputType = {
    id?: true
  }

  export type CitySumAggregateInputType = {
    id?: true
  }

  export type CityMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which City to aggregate.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
    orderBy?: CityOrderByWithAggregationInput | CityOrderByWithAggregationInput[]
    by: CityScalarFieldEnum[] | CityScalarFieldEnum
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _avg?: CityAvgAggregateInputType
    _sum?: CitySumAggregateInputType
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }

  export type CityGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type CitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    districts?: boolean | City$districtsArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["city"]>

  export type CitySelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    districts?: boolean | City$districtsArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "City"
    objects: {
      districts: Prisma.$DistrictPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["city"]>
    composites: {}
  }

  type CityGetPayload<S extends boolean | null | undefined | CityDefaultArgs> = $Result.GetResult<Prisma.$CityPayload, S>

  type CityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CityCountAggregateInputType | true
    }

  export interface CityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['City'], meta: { name: 'City' } }
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CityFindUniqueArgs>(args: SelectSubset<T, CityFindUniqueArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one City that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CityFindUniqueOrThrowArgs>(args: SelectSubset<T, CityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CityFindFirstArgs>(args?: SelectSubset<T, CityFindFirstArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first City that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CityFindFirstOrThrowArgs>(args?: SelectSubset<T, CityFindFirstOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CityFindManyArgs>(args?: SelectSubset<T, CityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
     */
    create<T extends CityCreateArgs>(args: SelectSubset<T, CityCreateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cities.
     * @param {CityCreateManyArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CityCreateManyArgs>(args?: SelectSubset<T, CityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cities and returns the data saved in the database.
     * @param {CityCreateManyAndReturnArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cities and only return the `id`
     * const cityWithIdOnly = await prisma.city.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CityCreateManyAndReturnArgs>(args?: SelectSubset<T, CityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
     */
    delete<T extends CityDeleteArgs>(args: SelectSubset<T, CityDeleteArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CityUpdateArgs>(args: SelectSubset<T, CityUpdateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CityDeleteManyArgs>(args?: SelectSubset<T, CityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CityUpdateManyArgs>(args: SelectSubset<T, CityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
     */
    upsert<T extends CityUpsertArgs>(args: SelectSubset<T, CityUpsertArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): Prisma.PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the City model
   */
  readonly fields: CityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    districts<T extends City$districtsArgs<ExtArgs> = {}>(args?: Subset<T, City$districtsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the City model
   */ 
  interface CityFieldRefs {
    readonly id: FieldRef<"City", 'Int'>
    readonly name: FieldRef<"City", 'String'>
    readonly createdAt: FieldRef<"City", 'DateTime'>
    readonly updatedAt: FieldRef<"City", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * City findUnique
   */
  export type CityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findUniqueOrThrow
   */
  export type CityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findFirst
   */
  export type CityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findFirstOrThrow
   */
  export type CityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findMany
   */
  export type CityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which Cities to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City create
   */
  export type CityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to create a City.
     */
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }

  /**
   * City createMany
   */
  export type CityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * City createManyAndReturn
   */
  export type CityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * City update
   */
  export type CityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to update a City.
     */
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City updateMany
   */
  export type CityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
  }

  /**
   * City upsert
   */
  export type CityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The filter to search for the City to update in case it exists.
     */
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     */
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }

  /**
   * City delete
   */
  export type CityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter which City to delete.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cities to delete
     */
    where?: CityWhereInput
  }

  /**
   * City.districts
   */
  export type City$districtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    where?: DistrictWhereInput
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    cursor?: DistrictWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DistrictScalarFieldEnum | DistrictScalarFieldEnum[]
  }

  /**
   * City without action
   */
  export type CityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
  }


  /**
   * Model District
   */

  export type AggregateDistrict = {
    _count: DistrictCountAggregateOutputType | null
    _avg: DistrictAvgAggregateOutputType | null
    _sum: DistrictSumAggregateOutputType | null
    _min: DistrictMinAggregateOutputType | null
    _max: DistrictMaxAggregateOutputType | null
  }

  export type DistrictAvgAggregateOutputType = {
    id: number | null
    cityId: number | null
  }

  export type DistrictSumAggregateOutputType = {
    id: number | null
    cityId: number | null
  }

  export type DistrictMinAggregateOutputType = {
    id: number | null
    name: string | null
    cityId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DistrictMaxAggregateOutputType = {
    id: number | null
    name: string | null
    cityId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DistrictCountAggregateOutputType = {
    id: number
    name: number
    cityId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DistrictAvgAggregateInputType = {
    id?: true
    cityId?: true
  }

  export type DistrictSumAggregateInputType = {
    id?: true
    cityId?: true
  }

  export type DistrictMinAggregateInputType = {
    id?: true
    name?: true
    cityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DistrictMaxAggregateInputType = {
    id?: true
    name?: true
    cityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DistrictCountAggregateInputType = {
    id?: true
    name?: true
    cityId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DistrictAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which District to aggregate.
     */
    where?: DistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Districts to fetch.
     */
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Districts
    **/
    _count?: true | DistrictCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DistrictAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DistrictSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DistrictMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DistrictMaxAggregateInputType
  }

  export type GetDistrictAggregateType<T extends DistrictAggregateArgs> = {
        [P in keyof T & keyof AggregateDistrict]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDistrict[P]>
      : GetScalarType<T[P], AggregateDistrict[P]>
  }




  export type DistrictGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DistrictWhereInput
    orderBy?: DistrictOrderByWithAggregationInput | DistrictOrderByWithAggregationInput[]
    by: DistrictScalarFieldEnum[] | DistrictScalarFieldEnum
    having?: DistrictScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DistrictCountAggregateInputType | true
    _avg?: DistrictAvgAggregateInputType
    _sum?: DistrictSumAggregateInputType
    _min?: DistrictMinAggregateInputType
    _max?: DistrictMaxAggregateInputType
  }

  export type DistrictGroupByOutputType = {
    id: number
    name: string
    cityId: number
    createdAt: Date
    updatedAt: Date
    _count: DistrictCountAggregateOutputType | null
    _avg: DistrictAvgAggregateOutputType | null
    _sum: DistrictSumAggregateOutputType | null
    _min: DistrictMinAggregateOutputType | null
    _max: DistrictMaxAggregateOutputType | null
  }

  type GetDistrictGroupByPayload<T extends DistrictGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DistrictGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DistrictGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DistrictGroupByOutputType[P]>
            : GetScalarType<T[P], DistrictGroupByOutputType[P]>
        }
      >
    >


  export type DistrictSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
    zoneDistricts?: boolean | District$zoneDistrictsArgs<ExtArgs>
    calendarZoneDistricts?: boolean | District$calendarZoneDistrictsArgs<ExtArgs>
    _count?: boolean | DistrictCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["district"]>

  export type DistrictSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["district"]>

  export type DistrictSelectScalar = {
    id?: boolean
    name?: boolean
    cityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DistrictInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
    zoneDistricts?: boolean | District$zoneDistrictsArgs<ExtArgs>
    calendarZoneDistricts?: boolean | District$calendarZoneDistrictsArgs<ExtArgs>
    _count?: boolean | DistrictCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DistrictIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
  }

  export type $DistrictPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "District"
    objects: {
      city: Prisma.$CityPayload<ExtArgs>
      zoneDistricts: Prisma.$ZoneDistrictPayload<ExtArgs>[]
      calendarZoneDistricts: Prisma.$CalendarZoneDistrictPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      cityId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["district"]>
    composites: {}
  }

  type DistrictGetPayload<S extends boolean | null | undefined | DistrictDefaultArgs> = $Result.GetResult<Prisma.$DistrictPayload, S>

  type DistrictCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DistrictFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DistrictCountAggregateInputType | true
    }

  export interface DistrictDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['District'], meta: { name: 'District' } }
    /**
     * Find zero or one District that matches the filter.
     * @param {DistrictFindUniqueArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DistrictFindUniqueArgs>(args: SelectSubset<T, DistrictFindUniqueArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one District that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DistrictFindUniqueOrThrowArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DistrictFindUniqueOrThrowArgs>(args: SelectSubset<T, DistrictFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first District that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictFindFirstArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DistrictFindFirstArgs>(args?: SelectSubset<T, DistrictFindFirstArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first District that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictFindFirstOrThrowArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DistrictFindFirstOrThrowArgs>(args?: SelectSubset<T, DistrictFindFirstOrThrowArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Districts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Districts
     * const districts = await prisma.district.findMany()
     * 
     * // Get first 10 Districts
     * const districts = await prisma.district.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const districtWithIdOnly = await prisma.district.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DistrictFindManyArgs>(args?: SelectSubset<T, DistrictFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a District.
     * @param {DistrictCreateArgs} args - Arguments to create a District.
     * @example
     * // Create one District
     * const District = await prisma.district.create({
     *   data: {
     *     // ... data to create a District
     *   }
     * })
     * 
     */
    create<T extends DistrictCreateArgs>(args: SelectSubset<T, DistrictCreateArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Districts.
     * @param {DistrictCreateManyArgs} args - Arguments to create many Districts.
     * @example
     * // Create many Districts
     * const district = await prisma.district.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DistrictCreateManyArgs>(args?: SelectSubset<T, DistrictCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Districts and returns the data saved in the database.
     * @param {DistrictCreateManyAndReturnArgs} args - Arguments to create many Districts.
     * @example
     * // Create many Districts
     * const district = await prisma.district.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Districts and only return the `id`
     * const districtWithIdOnly = await prisma.district.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DistrictCreateManyAndReturnArgs>(args?: SelectSubset<T, DistrictCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a District.
     * @param {DistrictDeleteArgs} args - Arguments to delete one District.
     * @example
     * // Delete one District
     * const District = await prisma.district.delete({
     *   where: {
     *     // ... filter to delete one District
     *   }
     * })
     * 
     */
    delete<T extends DistrictDeleteArgs>(args: SelectSubset<T, DistrictDeleteArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one District.
     * @param {DistrictUpdateArgs} args - Arguments to update one District.
     * @example
     * // Update one District
     * const district = await prisma.district.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DistrictUpdateArgs>(args: SelectSubset<T, DistrictUpdateArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Districts.
     * @param {DistrictDeleteManyArgs} args - Arguments to filter Districts to delete.
     * @example
     * // Delete a few Districts
     * const { count } = await prisma.district.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DistrictDeleteManyArgs>(args?: SelectSubset<T, DistrictDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Districts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Districts
     * const district = await prisma.district.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DistrictUpdateManyArgs>(args: SelectSubset<T, DistrictUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one District.
     * @param {DistrictUpsertArgs} args - Arguments to update or create a District.
     * @example
     * // Update or create a District
     * const district = await prisma.district.upsert({
     *   create: {
     *     // ... data to create a District
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the District we want to update
     *   }
     * })
     */
    upsert<T extends DistrictUpsertArgs>(args: SelectSubset<T, DistrictUpsertArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Districts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictCountArgs} args - Arguments to filter Districts to count.
     * @example
     * // Count the number of Districts
     * const count = await prisma.district.count({
     *   where: {
     *     // ... the filter for the Districts we want to count
     *   }
     * })
    **/
    count<T extends DistrictCountArgs>(
      args?: Subset<T, DistrictCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DistrictCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a District.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DistrictAggregateArgs>(args: Subset<T, DistrictAggregateArgs>): Prisma.PrismaPromise<GetDistrictAggregateType<T>>

    /**
     * Group by District.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DistrictGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DistrictGroupByArgs['orderBy'] }
        : { orderBy?: DistrictGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DistrictGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDistrictGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the District model
   */
  readonly fields: DistrictFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for District.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DistrictClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    zoneDistricts<T extends District$zoneDistrictsArgs<ExtArgs> = {}>(args?: Subset<T, District$zoneDistrictsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZoneDistrictPayload<ExtArgs>, T, "findMany"> | Null>
    calendarZoneDistricts<T extends District$calendarZoneDistrictsArgs<ExtArgs> = {}>(args?: Subset<T, District$calendarZoneDistrictsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarZoneDistrictPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the District model
   */ 
  interface DistrictFieldRefs {
    readonly id: FieldRef<"District", 'Int'>
    readonly name: FieldRef<"District", 'String'>
    readonly cityId: FieldRef<"District", 'Int'>
    readonly createdAt: FieldRef<"District", 'DateTime'>
    readonly updatedAt: FieldRef<"District", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * District findUnique
   */
  export type DistrictFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which District to fetch.
     */
    where: DistrictWhereUniqueInput
  }

  /**
   * District findUniqueOrThrow
   */
  export type DistrictFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which District to fetch.
     */
    where: DistrictWhereUniqueInput
  }

  /**
   * District findFirst
   */
  export type DistrictFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which District to fetch.
     */
    where?: DistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Districts to fetch.
     */
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Districts.
     */
    cursor?: DistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Districts.
     */
    distinct?: DistrictScalarFieldEnum | DistrictScalarFieldEnum[]
  }

  /**
   * District findFirstOrThrow
   */
  export type DistrictFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which District to fetch.
     */
    where?: DistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Districts to fetch.
     */
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Districts.
     */
    cursor?: DistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Districts.
     */
    distinct?: DistrictScalarFieldEnum | DistrictScalarFieldEnum[]
  }

  /**
   * District findMany
   */
  export type DistrictFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which Districts to fetch.
     */
    where?: DistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Districts to fetch.
     */
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Districts.
     */
    cursor?: DistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Districts.
     */
    skip?: number
    distinct?: DistrictScalarFieldEnum | DistrictScalarFieldEnum[]
  }

  /**
   * District create
   */
  export type DistrictCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * The data needed to create a District.
     */
    data: XOR<DistrictCreateInput, DistrictUncheckedCreateInput>
  }

  /**
   * District createMany
   */
  export type DistrictCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Districts.
     */
    data: DistrictCreateManyInput | DistrictCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * District createManyAndReturn
   */
  export type DistrictCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Districts.
     */
    data: DistrictCreateManyInput | DistrictCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * District update
   */
  export type DistrictUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * The data needed to update a District.
     */
    data: XOR<DistrictUpdateInput, DistrictUncheckedUpdateInput>
    /**
     * Choose, which District to update.
     */
    where: DistrictWhereUniqueInput
  }

  /**
   * District updateMany
   */
  export type DistrictUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Districts.
     */
    data: XOR<DistrictUpdateManyMutationInput, DistrictUncheckedUpdateManyInput>
    /**
     * Filter which Districts to update
     */
    where?: DistrictWhereInput
  }

  /**
   * District upsert
   */
  export type DistrictUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * The filter to search for the District to update in case it exists.
     */
    where: DistrictWhereUniqueInput
    /**
     * In case the District found by the `where` argument doesn't exist, create a new District with this data.
     */
    create: XOR<DistrictCreateInput, DistrictUncheckedCreateInput>
    /**
     * In case the District was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DistrictUpdateInput, DistrictUncheckedUpdateInput>
  }

  /**
   * District delete
   */
  export type DistrictDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter which District to delete.
     */
    where: DistrictWhereUniqueInput
  }

  /**
   * District deleteMany
   */
  export type DistrictDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Districts to delete
     */
    where?: DistrictWhereInput
  }

  /**
   * District.zoneDistricts
   */
  export type District$zoneDistrictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneDistrict
     */
    select?: ZoneDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneDistrictInclude<ExtArgs> | null
    where?: ZoneDistrictWhereInput
    orderBy?: ZoneDistrictOrderByWithRelationInput | ZoneDistrictOrderByWithRelationInput[]
    cursor?: ZoneDistrictWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZoneDistrictScalarFieldEnum | ZoneDistrictScalarFieldEnum[]
  }

  /**
   * District.calendarZoneDistricts
   */
  export type District$calendarZoneDistrictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarZoneDistrict
     */
    select?: CalendarZoneDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarZoneDistrictInclude<ExtArgs> | null
    where?: CalendarZoneDistrictWhereInput
    orderBy?: CalendarZoneDistrictOrderByWithRelationInput | CalendarZoneDistrictOrderByWithRelationInput[]
    cursor?: CalendarZoneDistrictWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarZoneDistrictScalarFieldEnum | CalendarZoneDistrictScalarFieldEnum[]
  }

  /**
   * District without action
   */
  export type DistrictDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
  }


  /**
   * Model ZoneDistrict
   */

  export type AggregateZoneDistrict = {
    _count: ZoneDistrictCountAggregateOutputType | null
    _avg: ZoneDistrictAvgAggregateOutputType | null
    _sum: ZoneDistrictSumAggregateOutputType | null
    _min: ZoneDistrictMinAggregateOutputType | null
    _max: ZoneDistrictMaxAggregateOutputType | null
  }

  export type ZoneDistrictAvgAggregateOutputType = {
    districtId: number | null
  }

  export type ZoneDistrictSumAggregateOutputType = {
    districtId: number | null
  }

  export type ZoneDistrictMinAggregateOutputType = {
    zoneId: string | null
    districtId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ZoneDistrictMaxAggregateOutputType = {
    zoneId: string | null
    districtId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ZoneDistrictCountAggregateOutputType = {
    zoneId: number
    districtId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ZoneDistrictAvgAggregateInputType = {
    districtId?: true
  }

  export type ZoneDistrictSumAggregateInputType = {
    districtId?: true
  }

  export type ZoneDistrictMinAggregateInputType = {
    zoneId?: true
    districtId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ZoneDistrictMaxAggregateInputType = {
    zoneId?: true
    districtId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ZoneDistrictCountAggregateInputType = {
    zoneId?: true
    districtId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ZoneDistrictAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZoneDistrict to aggregate.
     */
    where?: ZoneDistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZoneDistricts to fetch.
     */
    orderBy?: ZoneDistrictOrderByWithRelationInput | ZoneDistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ZoneDistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZoneDistricts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZoneDistricts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ZoneDistricts
    **/
    _count?: true | ZoneDistrictCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ZoneDistrictAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ZoneDistrictSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZoneDistrictMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZoneDistrictMaxAggregateInputType
  }

  export type GetZoneDistrictAggregateType<T extends ZoneDistrictAggregateArgs> = {
        [P in keyof T & keyof AggregateZoneDistrict]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZoneDistrict[P]>
      : GetScalarType<T[P], AggregateZoneDistrict[P]>
  }




  export type ZoneDistrictGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoneDistrictWhereInput
    orderBy?: ZoneDistrictOrderByWithAggregationInput | ZoneDistrictOrderByWithAggregationInput[]
    by: ZoneDistrictScalarFieldEnum[] | ZoneDistrictScalarFieldEnum
    having?: ZoneDistrictScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZoneDistrictCountAggregateInputType | true
    _avg?: ZoneDistrictAvgAggregateInputType
    _sum?: ZoneDistrictSumAggregateInputType
    _min?: ZoneDistrictMinAggregateInputType
    _max?: ZoneDistrictMaxAggregateInputType
  }

  export type ZoneDistrictGroupByOutputType = {
    zoneId: string
    districtId: number
    createdAt: Date
    updatedAt: Date
    _count: ZoneDistrictCountAggregateOutputType | null
    _avg: ZoneDistrictAvgAggregateOutputType | null
    _sum: ZoneDistrictSumAggregateOutputType | null
    _min: ZoneDistrictMinAggregateOutputType | null
    _max: ZoneDistrictMaxAggregateOutputType | null
  }

  type GetZoneDistrictGroupByPayload<T extends ZoneDistrictGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZoneDistrictGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZoneDistrictGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZoneDistrictGroupByOutputType[P]>
            : GetScalarType<T[P], ZoneDistrictGroupByOutputType[P]>
        }
      >
    >


  export type ZoneDistrictSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    zoneId?: boolean
    districtId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    district?: boolean | DistrictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zoneDistrict"]>

  export type ZoneDistrictSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    zoneId?: boolean
    districtId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    district?: boolean | DistrictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zoneDistrict"]>

  export type ZoneDistrictSelectScalar = {
    zoneId?: boolean
    districtId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ZoneDistrictInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    district?: boolean | DistrictDefaultArgs<ExtArgs>
  }
  export type ZoneDistrictIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    district?: boolean | DistrictDefaultArgs<ExtArgs>
  }

  export type $ZoneDistrictPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ZoneDistrict"
    objects: {
      zone: Prisma.$ZonePayload<ExtArgs>
      district: Prisma.$DistrictPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      zoneId: string
      districtId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["zoneDistrict"]>
    composites: {}
  }

  type ZoneDistrictGetPayload<S extends boolean | null | undefined | ZoneDistrictDefaultArgs> = $Result.GetResult<Prisma.$ZoneDistrictPayload, S>

  type ZoneDistrictCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ZoneDistrictFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ZoneDistrictCountAggregateInputType | true
    }

  export interface ZoneDistrictDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ZoneDistrict'], meta: { name: 'ZoneDistrict' } }
    /**
     * Find zero or one ZoneDistrict that matches the filter.
     * @param {ZoneDistrictFindUniqueArgs} args - Arguments to find a ZoneDistrict
     * @example
     * // Get one ZoneDistrict
     * const zoneDistrict = await prisma.zoneDistrict.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ZoneDistrictFindUniqueArgs>(args: SelectSubset<T, ZoneDistrictFindUniqueArgs<ExtArgs>>): Prisma__ZoneDistrictClient<$Result.GetResult<Prisma.$ZoneDistrictPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ZoneDistrict that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ZoneDistrictFindUniqueOrThrowArgs} args - Arguments to find a ZoneDistrict
     * @example
     * // Get one ZoneDistrict
     * const zoneDistrict = await prisma.zoneDistrict.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ZoneDistrictFindUniqueOrThrowArgs>(args: SelectSubset<T, ZoneDistrictFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ZoneDistrictClient<$Result.GetResult<Prisma.$ZoneDistrictPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ZoneDistrict that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneDistrictFindFirstArgs} args - Arguments to find a ZoneDistrict
     * @example
     * // Get one ZoneDistrict
     * const zoneDistrict = await prisma.zoneDistrict.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ZoneDistrictFindFirstArgs>(args?: SelectSubset<T, ZoneDistrictFindFirstArgs<ExtArgs>>): Prisma__ZoneDistrictClient<$Result.GetResult<Prisma.$ZoneDistrictPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ZoneDistrict that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneDistrictFindFirstOrThrowArgs} args - Arguments to find a ZoneDistrict
     * @example
     * // Get one ZoneDistrict
     * const zoneDistrict = await prisma.zoneDistrict.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ZoneDistrictFindFirstOrThrowArgs>(args?: SelectSubset<T, ZoneDistrictFindFirstOrThrowArgs<ExtArgs>>): Prisma__ZoneDistrictClient<$Result.GetResult<Prisma.$ZoneDistrictPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ZoneDistricts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneDistrictFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ZoneDistricts
     * const zoneDistricts = await prisma.zoneDistrict.findMany()
     * 
     * // Get first 10 ZoneDistricts
     * const zoneDistricts = await prisma.zoneDistrict.findMany({ take: 10 })
     * 
     * // Only select the `zoneId`
     * const zoneDistrictWithZoneIdOnly = await prisma.zoneDistrict.findMany({ select: { zoneId: true } })
     * 
     */
    findMany<T extends ZoneDistrictFindManyArgs>(args?: SelectSubset<T, ZoneDistrictFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZoneDistrictPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ZoneDistrict.
     * @param {ZoneDistrictCreateArgs} args - Arguments to create a ZoneDistrict.
     * @example
     * // Create one ZoneDistrict
     * const ZoneDistrict = await prisma.zoneDistrict.create({
     *   data: {
     *     // ... data to create a ZoneDistrict
     *   }
     * })
     * 
     */
    create<T extends ZoneDistrictCreateArgs>(args: SelectSubset<T, ZoneDistrictCreateArgs<ExtArgs>>): Prisma__ZoneDistrictClient<$Result.GetResult<Prisma.$ZoneDistrictPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ZoneDistricts.
     * @param {ZoneDistrictCreateManyArgs} args - Arguments to create many ZoneDistricts.
     * @example
     * // Create many ZoneDistricts
     * const zoneDistrict = await prisma.zoneDistrict.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ZoneDistrictCreateManyArgs>(args?: SelectSubset<T, ZoneDistrictCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ZoneDistricts and returns the data saved in the database.
     * @param {ZoneDistrictCreateManyAndReturnArgs} args - Arguments to create many ZoneDistricts.
     * @example
     * // Create many ZoneDistricts
     * const zoneDistrict = await prisma.zoneDistrict.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ZoneDistricts and only return the `zoneId`
     * const zoneDistrictWithZoneIdOnly = await prisma.zoneDistrict.createManyAndReturn({ 
     *   select: { zoneId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ZoneDistrictCreateManyAndReturnArgs>(args?: SelectSubset<T, ZoneDistrictCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZoneDistrictPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ZoneDistrict.
     * @param {ZoneDistrictDeleteArgs} args - Arguments to delete one ZoneDistrict.
     * @example
     * // Delete one ZoneDistrict
     * const ZoneDistrict = await prisma.zoneDistrict.delete({
     *   where: {
     *     // ... filter to delete one ZoneDistrict
     *   }
     * })
     * 
     */
    delete<T extends ZoneDistrictDeleteArgs>(args: SelectSubset<T, ZoneDistrictDeleteArgs<ExtArgs>>): Prisma__ZoneDistrictClient<$Result.GetResult<Prisma.$ZoneDistrictPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ZoneDistrict.
     * @param {ZoneDistrictUpdateArgs} args - Arguments to update one ZoneDistrict.
     * @example
     * // Update one ZoneDistrict
     * const zoneDistrict = await prisma.zoneDistrict.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ZoneDistrictUpdateArgs>(args: SelectSubset<T, ZoneDistrictUpdateArgs<ExtArgs>>): Prisma__ZoneDistrictClient<$Result.GetResult<Prisma.$ZoneDistrictPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ZoneDistricts.
     * @param {ZoneDistrictDeleteManyArgs} args - Arguments to filter ZoneDistricts to delete.
     * @example
     * // Delete a few ZoneDistricts
     * const { count } = await prisma.zoneDistrict.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ZoneDistrictDeleteManyArgs>(args?: SelectSubset<T, ZoneDistrictDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ZoneDistricts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneDistrictUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ZoneDistricts
     * const zoneDistrict = await prisma.zoneDistrict.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ZoneDistrictUpdateManyArgs>(args: SelectSubset<T, ZoneDistrictUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ZoneDistrict.
     * @param {ZoneDistrictUpsertArgs} args - Arguments to update or create a ZoneDistrict.
     * @example
     * // Update or create a ZoneDistrict
     * const zoneDistrict = await prisma.zoneDistrict.upsert({
     *   create: {
     *     // ... data to create a ZoneDistrict
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ZoneDistrict we want to update
     *   }
     * })
     */
    upsert<T extends ZoneDistrictUpsertArgs>(args: SelectSubset<T, ZoneDistrictUpsertArgs<ExtArgs>>): Prisma__ZoneDistrictClient<$Result.GetResult<Prisma.$ZoneDistrictPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ZoneDistricts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneDistrictCountArgs} args - Arguments to filter ZoneDistricts to count.
     * @example
     * // Count the number of ZoneDistricts
     * const count = await prisma.zoneDistrict.count({
     *   where: {
     *     // ... the filter for the ZoneDistricts we want to count
     *   }
     * })
    **/
    count<T extends ZoneDistrictCountArgs>(
      args?: Subset<T, ZoneDistrictCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZoneDistrictCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ZoneDistrict.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneDistrictAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZoneDistrictAggregateArgs>(args: Subset<T, ZoneDistrictAggregateArgs>): Prisma.PrismaPromise<GetZoneDistrictAggregateType<T>>

    /**
     * Group by ZoneDistrict.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneDistrictGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZoneDistrictGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZoneDistrictGroupByArgs['orderBy'] }
        : { orderBy?: ZoneDistrictGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZoneDistrictGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZoneDistrictGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ZoneDistrict model
   */
  readonly fields: ZoneDistrictFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ZoneDistrict.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ZoneDistrictClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    zone<T extends ZoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ZoneDefaultArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    district<T extends DistrictDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DistrictDefaultArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ZoneDistrict model
   */ 
  interface ZoneDistrictFieldRefs {
    readonly zoneId: FieldRef<"ZoneDistrict", 'String'>
    readonly districtId: FieldRef<"ZoneDistrict", 'Int'>
    readonly createdAt: FieldRef<"ZoneDistrict", 'DateTime'>
    readonly updatedAt: FieldRef<"ZoneDistrict", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ZoneDistrict findUnique
   */
  export type ZoneDistrictFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneDistrict
     */
    select?: ZoneDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneDistrictInclude<ExtArgs> | null
    /**
     * Filter, which ZoneDistrict to fetch.
     */
    where: ZoneDistrictWhereUniqueInput
  }

  /**
   * ZoneDistrict findUniqueOrThrow
   */
  export type ZoneDistrictFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneDistrict
     */
    select?: ZoneDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneDistrictInclude<ExtArgs> | null
    /**
     * Filter, which ZoneDistrict to fetch.
     */
    where: ZoneDistrictWhereUniqueInput
  }

  /**
   * ZoneDistrict findFirst
   */
  export type ZoneDistrictFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneDistrict
     */
    select?: ZoneDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneDistrictInclude<ExtArgs> | null
    /**
     * Filter, which ZoneDistrict to fetch.
     */
    where?: ZoneDistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZoneDistricts to fetch.
     */
    orderBy?: ZoneDistrictOrderByWithRelationInput | ZoneDistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZoneDistricts.
     */
    cursor?: ZoneDistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZoneDistricts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZoneDistricts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZoneDistricts.
     */
    distinct?: ZoneDistrictScalarFieldEnum | ZoneDistrictScalarFieldEnum[]
  }

  /**
   * ZoneDistrict findFirstOrThrow
   */
  export type ZoneDistrictFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneDistrict
     */
    select?: ZoneDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneDistrictInclude<ExtArgs> | null
    /**
     * Filter, which ZoneDistrict to fetch.
     */
    where?: ZoneDistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZoneDistricts to fetch.
     */
    orderBy?: ZoneDistrictOrderByWithRelationInput | ZoneDistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZoneDistricts.
     */
    cursor?: ZoneDistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZoneDistricts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZoneDistricts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZoneDistricts.
     */
    distinct?: ZoneDistrictScalarFieldEnum | ZoneDistrictScalarFieldEnum[]
  }

  /**
   * ZoneDistrict findMany
   */
  export type ZoneDistrictFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneDistrict
     */
    select?: ZoneDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneDistrictInclude<ExtArgs> | null
    /**
     * Filter, which ZoneDistricts to fetch.
     */
    where?: ZoneDistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZoneDistricts to fetch.
     */
    orderBy?: ZoneDistrictOrderByWithRelationInput | ZoneDistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ZoneDistricts.
     */
    cursor?: ZoneDistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZoneDistricts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZoneDistricts.
     */
    skip?: number
    distinct?: ZoneDistrictScalarFieldEnum | ZoneDistrictScalarFieldEnum[]
  }

  /**
   * ZoneDistrict create
   */
  export type ZoneDistrictCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneDistrict
     */
    select?: ZoneDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneDistrictInclude<ExtArgs> | null
    /**
     * The data needed to create a ZoneDistrict.
     */
    data: XOR<ZoneDistrictCreateInput, ZoneDistrictUncheckedCreateInput>
  }

  /**
   * ZoneDistrict createMany
   */
  export type ZoneDistrictCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ZoneDistricts.
     */
    data: ZoneDistrictCreateManyInput | ZoneDistrictCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ZoneDistrict createManyAndReturn
   */
  export type ZoneDistrictCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneDistrict
     */
    select?: ZoneDistrictSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ZoneDistricts.
     */
    data: ZoneDistrictCreateManyInput | ZoneDistrictCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneDistrictIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ZoneDistrict update
   */
  export type ZoneDistrictUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneDistrict
     */
    select?: ZoneDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneDistrictInclude<ExtArgs> | null
    /**
     * The data needed to update a ZoneDistrict.
     */
    data: XOR<ZoneDistrictUpdateInput, ZoneDistrictUncheckedUpdateInput>
    /**
     * Choose, which ZoneDistrict to update.
     */
    where: ZoneDistrictWhereUniqueInput
  }

  /**
   * ZoneDistrict updateMany
   */
  export type ZoneDistrictUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ZoneDistricts.
     */
    data: XOR<ZoneDistrictUpdateManyMutationInput, ZoneDistrictUncheckedUpdateManyInput>
    /**
     * Filter which ZoneDistricts to update
     */
    where?: ZoneDistrictWhereInput
  }

  /**
   * ZoneDistrict upsert
   */
  export type ZoneDistrictUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneDistrict
     */
    select?: ZoneDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneDistrictInclude<ExtArgs> | null
    /**
     * The filter to search for the ZoneDistrict to update in case it exists.
     */
    where: ZoneDistrictWhereUniqueInput
    /**
     * In case the ZoneDistrict found by the `where` argument doesn't exist, create a new ZoneDistrict with this data.
     */
    create: XOR<ZoneDistrictCreateInput, ZoneDistrictUncheckedCreateInput>
    /**
     * In case the ZoneDistrict was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ZoneDistrictUpdateInput, ZoneDistrictUncheckedUpdateInput>
  }

  /**
   * ZoneDistrict delete
   */
  export type ZoneDistrictDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneDistrict
     */
    select?: ZoneDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneDistrictInclude<ExtArgs> | null
    /**
     * Filter which ZoneDistrict to delete.
     */
    where: ZoneDistrictWhereUniqueInput
  }

  /**
   * ZoneDistrict deleteMany
   */
  export type ZoneDistrictDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZoneDistricts to delete
     */
    where?: ZoneDistrictWhereInput
  }

  /**
   * ZoneDistrict without action
   */
  export type ZoneDistrictDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneDistrict
     */
    select?: ZoneDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneDistrictInclude<ExtArgs> | null
  }


  /**
   * Model Calendar
   */

  export type AggregateCalendar = {
    _count: CalendarCountAggregateOutputType | null
    _min: CalendarMinAggregateOutputType | null
    _max: CalendarMaxAggregateOutputType | null
  }

  export type CalendarMinAggregateOutputType = {
    id: string | null
    cropId: string | null
    title: string | null
    creatorId: string | null
    creatorName: string | null
    isShared: boolean | null
    isPublished: boolean | null
    fileType: $Enums.CalendarFileType | null
    allowCenterUse: boolean | null
    publishedAt: Date | null
    lastEditedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalendarMaxAggregateOutputType = {
    id: string | null
    cropId: string | null
    title: string | null
    creatorId: string | null
    creatorName: string | null
    isShared: boolean | null
    isPublished: boolean | null
    fileType: $Enums.CalendarFileType | null
    allowCenterUse: boolean | null
    publishedAt: Date | null
    lastEditedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalendarCountAggregateOutputType = {
    id: number
    cropId: number
    title: number
    creatorId: number
    creatorName: number
    isShared: number
    isPublished: number
    fileType: number
    allowCenterUse: number
    publishedAt: number
    lastEditedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CalendarMinAggregateInputType = {
    id?: true
    cropId?: true
    title?: true
    creatorId?: true
    creatorName?: true
    isShared?: true
    isPublished?: true
    fileType?: true
    allowCenterUse?: true
    publishedAt?: true
    lastEditedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalendarMaxAggregateInputType = {
    id?: true
    cropId?: true
    title?: true
    creatorId?: true
    creatorName?: true
    isShared?: true
    isPublished?: true
    fileType?: true
    allowCenterUse?: true
    publishedAt?: true
    lastEditedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalendarCountAggregateInputType = {
    id?: true
    cropId?: true
    title?: true
    creatorId?: true
    creatorName?: true
    isShared?: true
    isPublished?: true
    fileType?: true
    allowCenterUse?: true
    publishedAt?: true
    lastEditedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CalendarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Calendar to aggregate.
     */
    where?: CalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calendars to fetch.
     */
    orderBy?: CalendarOrderByWithRelationInput | CalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Calendars
    **/
    _count?: true | CalendarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarMaxAggregateInputType
  }

  export type GetCalendarAggregateType<T extends CalendarAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendar[P]>
      : GetScalarType<T[P], AggregateCalendar[P]>
  }




  export type CalendarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarWhereInput
    orderBy?: CalendarOrderByWithAggregationInput | CalendarOrderByWithAggregationInput[]
    by: CalendarScalarFieldEnum[] | CalendarScalarFieldEnum
    having?: CalendarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarCountAggregateInputType | true
    _min?: CalendarMinAggregateInputType
    _max?: CalendarMaxAggregateInputType
  }

  export type CalendarGroupByOutputType = {
    id: string
    cropId: string
    title: string
    creatorId: string
    creatorName: string
    isShared: boolean
    isPublished: boolean
    fileType: $Enums.CalendarFileType
    allowCenterUse: boolean
    publishedAt: Date | null
    lastEditedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: CalendarCountAggregateOutputType | null
    _min: CalendarMinAggregateOutputType | null
    _max: CalendarMaxAggregateOutputType | null
  }

  type GetCalendarGroupByPayload<T extends CalendarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarGroupByOutputType[P]>
        }
      >
    >


  export type CalendarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cropId?: boolean
    title?: boolean
    creatorId?: boolean
    creatorName?: boolean
    isShared?: boolean
    isPublished?: boolean
    fileType?: boolean
    allowCenterUse?: boolean
    publishedAt?: boolean
    lastEditedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    crop?: boolean | CropDefaultArgs<ExtArgs>
    stages?: boolean | Calendar$stagesArgs<ExtArgs>
    calendarZones?: boolean | Calendar$calendarZonesArgs<ExtArgs>
    calendarIndicators?: boolean | Calendar$calendarIndicatorsArgs<ExtArgs>
    _count?: boolean | CalendarCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendar"]>

  export type CalendarSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cropId?: boolean
    title?: boolean
    creatorId?: boolean
    creatorName?: boolean
    isShared?: boolean
    isPublished?: boolean
    fileType?: boolean
    allowCenterUse?: boolean
    publishedAt?: boolean
    lastEditedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    crop?: boolean | CropDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendar"]>

  export type CalendarSelectScalar = {
    id?: boolean
    cropId?: boolean
    title?: boolean
    creatorId?: boolean
    creatorName?: boolean
    isShared?: boolean
    isPublished?: boolean
    fileType?: boolean
    allowCenterUse?: boolean
    publishedAt?: boolean
    lastEditedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CalendarInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crop?: boolean | CropDefaultArgs<ExtArgs>
    stages?: boolean | Calendar$stagesArgs<ExtArgs>
    calendarZones?: boolean | Calendar$calendarZonesArgs<ExtArgs>
    calendarIndicators?: boolean | Calendar$calendarIndicatorsArgs<ExtArgs>
    _count?: boolean | CalendarCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CalendarIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crop?: boolean | CropDefaultArgs<ExtArgs>
  }

  export type $CalendarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Calendar"
    objects: {
      crop: Prisma.$CropPayload<ExtArgs>
      stages: Prisma.$StagePayload<ExtArgs>[]
      calendarZones: Prisma.$CalendarZonePayload<ExtArgs>[]
      calendarIndicators: Prisma.$CalendarIndicatorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cropId: string
      title: string
      creatorId: string
      creatorName: string
      isShared: boolean
      isPublished: boolean
      fileType: $Enums.CalendarFileType
      allowCenterUse: boolean
      publishedAt: Date | null
      lastEditedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["calendar"]>
    composites: {}
  }

  type CalendarGetPayload<S extends boolean | null | undefined | CalendarDefaultArgs> = $Result.GetResult<Prisma.$CalendarPayload, S>

  type CalendarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CalendarFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CalendarCountAggregateInputType | true
    }

  export interface CalendarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Calendar'], meta: { name: 'Calendar' } }
    /**
     * Find zero or one Calendar that matches the filter.
     * @param {CalendarFindUniqueArgs} args - Arguments to find a Calendar
     * @example
     * // Get one Calendar
     * const calendar = await prisma.calendar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalendarFindUniqueArgs>(args: SelectSubset<T, CalendarFindUniqueArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Calendar that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CalendarFindUniqueOrThrowArgs} args - Arguments to find a Calendar
     * @example
     * // Get one Calendar
     * const calendar = await prisma.calendar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalendarFindUniqueOrThrowArgs>(args: SelectSubset<T, CalendarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Calendar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarFindFirstArgs} args - Arguments to find a Calendar
     * @example
     * // Get one Calendar
     * const calendar = await prisma.calendar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalendarFindFirstArgs>(args?: SelectSubset<T, CalendarFindFirstArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Calendar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarFindFirstOrThrowArgs} args - Arguments to find a Calendar
     * @example
     * // Get one Calendar
     * const calendar = await prisma.calendar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalendarFindFirstOrThrowArgs>(args?: SelectSubset<T, CalendarFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Calendars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Calendars
     * const calendars = await prisma.calendar.findMany()
     * 
     * // Get first 10 Calendars
     * const calendars = await prisma.calendar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarWithIdOnly = await prisma.calendar.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalendarFindManyArgs>(args?: SelectSubset<T, CalendarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Calendar.
     * @param {CalendarCreateArgs} args - Arguments to create a Calendar.
     * @example
     * // Create one Calendar
     * const Calendar = await prisma.calendar.create({
     *   data: {
     *     // ... data to create a Calendar
     *   }
     * })
     * 
     */
    create<T extends CalendarCreateArgs>(args: SelectSubset<T, CalendarCreateArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Calendars.
     * @param {CalendarCreateManyArgs} args - Arguments to create many Calendars.
     * @example
     * // Create many Calendars
     * const calendar = await prisma.calendar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalendarCreateManyArgs>(args?: SelectSubset<T, CalendarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Calendars and returns the data saved in the database.
     * @param {CalendarCreateManyAndReturnArgs} args - Arguments to create many Calendars.
     * @example
     * // Create many Calendars
     * const calendar = await prisma.calendar.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Calendars and only return the `id`
     * const calendarWithIdOnly = await prisma.calendar.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CalendarCreateManyAndReturnArgs>(args?: SelectSubset<T, CalendarCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Calendar.
     * @param {CalendarDeleteArgs} args - Arguments to delete one Calendar.
     * @example
     * // Delete one Calendar
     * const Calendar = await prisma.calendar.delete({
     *   where: {
     *     // ... filter to delete one Calendar
     *   }
     * })
     * 
     */
    delete<T extends CalendarDeleteArgs>(args: SelectSubset<T, CalendarDeleteArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Calendar.
     * @param {CalendarUpdateArgs} args - Arguments to update one Calendar.
     * @example
     * // Update one Calendar
     * const calendar = await prisma.calendar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalendarUpdateArgs>(args: SelectSubset<T, CalendarUpdateArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Calendars.
     * @param {CalendarDeleteManyArgs} args - Arguments to filter Calendars to delete.
     * @example
     * // Delete a few Calendars
     * const { count } = await prisma.calendar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalendarDeleteManyArgs>(args?: SelectSubset<T, CalendarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Calendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Calendars
     * const calendar = await prisma.calendar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalendarUpdateManyArgs>(args: SelectSubset<T, CalendarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Calendar.
     * @param {CalendarUpsertArgs} args - Arguments to update or create a Calendar.
     * @example
     * // Update or create a Calendar
     * const calendar = await prisma.calendar.upsert({
     *   create: {
     *     // ... data to create a Calendar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Calendar we want to update
     *   }
     * })
     */
    upsert<T extends CalendarUpsertArgs>(args: SelectSubset<T, CalendarUpsertArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Calendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarCountArgs} args - Arguments to filter Calendars to count.
     * @example
     * // Count the number of Calendars
     * const count = await prisma.calendar.count({
     *   where: {
     *     // ... the filter for the Calendars we want to count
     *   }
     * })
    **/
    count<T extends CalendarCountArgs>(
      args?: Subset<T, CalendarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Calendar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarAggregateArgs>(args: Subset<T, CalendarAggregateArgs>): Prisma.PrismaPromise<GetCalendarAggregateType<T>>

    /**
     * Group by Calendar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarGroupByArgs['orderBy'] }
        : { orderBy?: CalendarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Calendar model
   */
  readonly fields: CalendarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Calendar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalendarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    crop<T extends CropDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CropDefaultArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    stages<T extends Calendar$stagesArgs<ExtArgs> = {}>(args?: Subset<T, Calendar$stagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findMany"> | Null>
    calendarZones<T extends Calendar$calendarZonesArgs<ExtArgs> = {}>(args?: Subset<T, Calendar$calendarZonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarZonePayload<ExtArgs>, T, "findMany"> | Null>
    calendarIndicators<T extends Calendar$calendarIndicatorsArgs<ExtArgs> = {}>(args?: Subset<T, Calendar$calendarIndicatorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarIndicatorPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Calendar model
   */ 
  interface CalendarFieldRefs {
    readonly id: FieldRef<"Calendar", 'String'>
    readonly cropId: FieldRef<"Calendar", 'String'>
    readonly title: FieldRef<"Calendar", 'String'>
    readonly creatorId: FieldRef<"Calendar", 'String'>
    readonly creatorName: FieldRef<"Calendar", 'String'>
    readonly isShared: FieldRef<"Calendar", 'Boolean'>
    readonly isPublished: FieldRef<"Calendar", 'Boolean'>
    readonly fileType: FieldRef<"Calendar", 'CalendarFileType'>
    readonly allowCenterUse: FieldRef<"Calendar", 'Boolean'>
    readonly publishedAt: FieldRef<"Calendar", 'DateTime'>
    readonly lastEditedAt: FieldRef<"Calendar", 'DateTime'>
    readonly createdAt: FieldRef<"Calendar", 'DateTime'>
    readonly updatedAt: FieldRef<"Calendar", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Calendar findUnique
   */
  export type CalendarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * Filter, which Calendar to fetch.
     */
    where: CalendarWhereUniqueInput
  }

  /**
   * Calendar findUniqueOrThrow
   */
  export type CalendarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * Filter, which Calendar to fetch.
     */
    where: CalendarWhereUniqueInput
  }

  /**
   * Calendar findFirst
   */
  export type CalendarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * Filter, which Calendar to fetch.
     */
    where?: CalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calendars to fetch.
     */
    orderBy?: CalendarOrderByWithRelationInput | CalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Calendars.
     */
    cursor?: CalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Calendars.
     */
    distinct?: CalendarScalarFieldEnum | CalendarScalarFieldEnum[]
  }

  /**
   * Calendar findFirstOrThrow
   */
  export type CalendarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * Filter, which Calendar to fetch.
     */
    where?: CalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calendars to fetch.
     */
    orderBy?: CalendarOrderByWithRelationInput | CalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Calendars.
     */
    cursor?: CalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Calendars.
     */
    distinct?: CalendarScalarFieldEnum | CalendarScalarFieldEnum[]
  }

  /**
   * Calendar findMany
   */
  export type CalendarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * Filter, which Calendars to fetch.
     */
    where?: CalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calendars to fetch.
     */
    orderBy?: CalendarOrderByWithRelationInput | CalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Calendars.
     */
    cursor?: CalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calendars.
     */
    skip?: number
    distinct?: CalendarScalarFieldEnum | CalendarScalarFieldEnum[]
  }

  /**
   * Calendar create
   */
  export type CalendarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * The data needed to create a Calendar.
     */
    data: XOR<CalendarCreateInput, CalendarUncheckedCreateInput>
  }

  /**
   * Calendar createMany
   */
  export type CalendarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Calendars.
     */
    data: CalendarCreateManyInput | CalendarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Calendar createManyAndReturn
   */
  export type CalendarCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Calendars.
     */
    data: CalendarCreateManyInput | CalendarCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Calendar update
   */
  export type CalendarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * The data needed to update a Calendar.
     */
    data: XOR<CalendarUpdateInput, CalendarUncheckedUpdateInput>
    /**
     * Choose, which Calendar to update.
     */
    where: CalendarWhereUniqueInput
  }

  /**
   * Calendar updateMany
   */
  export type CalendarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Calendars.
     */
    data: XOR<CalendarUpdateManyMutationInput, CalendarUncheckedUpdateManyInput>
    /**
     * Filter which Calendars to update
     */
    where?: CalendarWhereInput
  }

  /**
   * Calendar upsert
   */
  export type CalendarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * The filter to search for the Calendar to update in case it exists.
     */
    where: CalendarWhereUniqueInput
    /**
     * In case the Calendar found by the `where` argument doesn't exist, create a new Calendar with this data.
     */
    create: XOR<CalendarCreateInput, CalendarUncheckedCreateInput>
    /**
     * In case the Calendar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarUpdateInput, CalendarUncheckedUpdateInput>
  }

  /**
   * Calendar delete
   */
  export type CalendarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * Filter which Calendar to delete.
     */
    where: CalendarWhereUniqueInput
  }

  /**
   * Calendar deleteMany
   */
  export type CalendarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Calendars to delete
     */
    where?: CalendarWhereInput
  }

  /**
   * Calendar.stages
   */
  export type Calendar$stagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    where?: StageWhereInput
    orderBy?: StageOrderByWithRelationInput | StageOrderByWithRelationInput[]
    cursor?: StageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StageScalarFieldEnum | StageScalarFieldEnum[]
  }

  /**
   * Calendar.calendarZones
   */
  export type Calendar$calendarZonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarZone
     */
    select?: CalendarZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarZoneInclude<ExtArgs> | null
    where?: CalendarZoneWhereInput
    orderBy?: CalendarZoneOrderByWithRelationInput | CalendarZoneOrderByWithRelationInput[]
    cursor?: CalendarZoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarZoneScalarFieldEnum | CalendarZoneScalarFieldEnum[]
  }

  /**
   * Calendar.calendarIndicators
   */
  export type Calendar$calendarIndicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarIndicator
     */
    select?: CalendarIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarIndicatorInclude<ExtArgs> | null
    where?: CalendarIndicatorWhereInput
    orderBy?: CalendarIndicatorOrderByWithRelationInput | CalendarIndicatorOrderByWithRelationInput[]
    cursor?: CalendarIndicatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarIndicatorScalarFieldEnum | CalendarIndicatorScalarFieldEnum[]
  }

  /**
   * Calendar without action
   */
  export type CalendarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
  }


  /**
   * Model CalendarZone
   */

  export type AggregateCalendarZone = {
    _count: CalendarZoneCountAggregateOutputType | null
    _avg: CalendarZoneAvgAggregateOutputType | null
    _sum: CalendarZoneSumAggregateOutputType | null
    _min: CalendarZoneMinAggregateOutputType | null
    _max: CalendarZoneMaxAggregateOutputType | null
  }

  export type CalendarZoneAvgAggregateOutputType = {
    cityCount: number | null
    districtCount: number | null
  }

  export type CalendarZoneSumAggregateOutputType = {
    cityCount: number | null
    districtCount: number | null
  }

  export type CalendarZoneMinAggregateOutputType = {
    id: string | null
    calendarId: string | null
    zoneId: string | null
    zoneName: string | null
    cityCount: number | null
    districtCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalendarZoneMaxAggregateOutputType = {
    id: string | null
    calendarId: string | null
    zoneId: string | null
    zoneName: string | null
    cityCount: number | null
    districtCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalendarZoneCountAggregateOutputType = {
    id: number
    calendarId: number
    zoneId: number
    zoneName: number
    cityCount: number
    districtCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CalendarZoneAvgAggregateInputType = {
    cityCount?: true
    districtCount?: true
  }

  export type CalendarZoneSumAggregateInputType = {
    cityCount?: true
    districtCount?: true
  }

  export type CalendarZoneMinAggregateInputType = {
    id?: true
    calendarId?: true
    zoneId?: true
    zoneName?: true
    cityCount?: true
    districtCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalendarZoneMaxAggregateInputType = {
    id?: true
    calendarId?: true
    zoneId?: true
    zoneName?: true
    cityCount?: true
    districtCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalendarZoneCountAggregateInputType = {
    id?: true
    calendarId?: true
    zoneId?: true
    zoneName?: true
    cityCount?: true
    districtCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CalendarZoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarZone to aggregate.
     */
    where?: CalendarZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarZones to fetch.
     */
    orderBy?: CalendarZoneOrderByWithRelationInput | CalendarZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CalendarZones
    **/
    _count?: true | CalendarZoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CalendarZoneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CalendarZoneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarZoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarZoneMaxAggregateInputType
  }

  export type GetCalendarZoneAggregateType<T extends CalendarZoneAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendarZone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendarZone[P]>
      : GetScalarType<T[P], AggregateCalendarZone[P]>
  }




  export type CalendarZoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarZoneWhereInput
    orderBy?: CalendarZoneOrderByWithAggregationInput | CalendarZoneOrderByWithAggregationInput[]
    by: CalendarZoneScalarFieldEnum[] | CalendarZoneScalarFieldEnum
    having?: CalendarZoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarZoneCountAggregateInputType | true
    _avg?: CalendarZoneAvgAggregateInputType
    _sum?: CalendarZoneSumAggregateInputType
    _min?: CalendarZoneMinAggregateInputType
    _max?: CalendarZoneMaxAggregateInputType
  }

  export type CalendarZoneGroupByOutputType = {
    id: string
    calendarId: string
    zoneId: string
    zoneName: string
    cityCount: number
    districtCount: number
    createdAt: Date
    updatedAt: Date
    _count: CalendarZoneCountAggregateOutputType | null
    _avg: CalendarZoneAvgAggregateOutputType | null
    _sum: CalendarZoneSumAggregateOutputType | null
    _min: CalendarZoneMinAggregateOutputType | null
    _max: CalendarZoneMaxAggregateOutputType | null
  }

  type GetCalendarZoneGroupByPayload<T extends CalendarZoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarZoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarZoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarZoneGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarZoneGroupByOutputType[P]>
        }
      >
    >


  export type CalendarZoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    calendarId?: boolean
    zoneId?: boolean
    zoneName?: boolean
    cityCount?: boolean
    districtCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    calendar?: boolean | CalendarDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    districts?: boolean | CalendarZone$districtsArgs<ExtArgs>
    _count?: boolean | CalendarZoneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarZone"]>

  export type CalendarZoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    calendarId?: boolean
    zoneId?: boolean
    zoneName?: boolean
    cityCount?: boolean
    districtCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    calendar?: boolean | CalendarDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarZone"]>

  export type CalendarZoneSelectScalar = {
    id?: boolean
    calendarId?: boolean
    zoneId?: boolean
    zoneName?: boolean
    cityCount?: boolean
    districtCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CalendarZoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calendar?: boolean | CalendarDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    districts?: boolean | CalendarZone$districtsArgs<ExtArgs>
    _count?: boolean | CalendarZoneCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CalendarZoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calendar?: boolean | CalendarDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }

  export type $CalendarZonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CalendarZone"
    objects: {
      calendar: Prisma.$CalendarPayload<ExtArgs>
      zone: Prisma.$ZonePayload<ExtArgs>
      districts: Prisma.$CalendarZoneDistrictPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      calendarId: string
      zoneId: string
      zoneName: string
      cityCount: number
      districtCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["calendarZone"]>
    composites: {}
  }

  type CalendarZoneGetPayload<S extends boolean | null | undefined | CalendarZoneDefaultArgs> = $Result.GetResult<Prisma.$CalendarZonePayload, S>

  type CalendarZoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CalendarZoneFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CalendarZoneCountAggregateInputType | true
    }

  export interface CalendarZoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CalendarZone'], meta: { name: 'CalendarZone' } }
    /**
     * Find zero or one CalendarZone that matches the filter.
     * @param {CalendarZoneFindUniqueArgs} args - Arguments to find a CalendarZone
     * @example
     * // Get one CalendarZone
     * const calendarZone = await prisma.calendarZone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalendarZoneFindUniqueArgs>(args: SelectSubset<T, CalendarZoneFindUniqueArgs<ExtArgs>>): Prisma__CalendarZoneClient<$Result.GetResult<Prisma.$CalendarZonePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CalendarZone that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CalendarZoneFindUniqueOrThrowArgs} args - Arguments to find a CalendarZone
     * @example
     * // Get one CalendarZone
     * const calendarZone = await prisma.calendarZone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalendarZoneFindUniqueOrThrowArgs>(args: SelectSubset<T, CalendarZoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalendarZoneClient<$Result.GetResult<Prisma.$CalendarZonePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CalendarZone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarZoneFindFirstArgs} args - Arguments to find a CalendarZone
     * @example
     * // Get one CalendarZone
     * const calendarZone = await prisma.calendarZone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalendarZoneFindFirstArgs>(args?: SelectSubset<T, CalendarZoneFindFirstArgs<ExtArgs>>): Prisma__CalendarZoneClient<$Result.GetResult<Prisma.$CalendarZonePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CalendarZone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarZoneFindFirstOrThrowArgs} args - Arguments to find a CalendarZone
     * @example
     * // Get one CalendarZone
     * const calendarZone = await prisma.calendarZone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalendarZoneFindFirstOrThrowArgs>(args?: SelectSubset<T, CalendarZoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalendarZoneClient<$Result.GetResult<Prisma.$CalendarZonePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CalendarZones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarZoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalendarZones
     * const calendarZones = await prisma.calendarZone.findMany()
     * 
     * // Get first 10 CalendarZones
     * const calendarZones = await prisma.calendarZone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarZoneWithIdOnly = await prisma.calendarZone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalendarZoneFindManyArgs>(args?: SelectSubset<T, CalendarZoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarZonePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CalendarZone.
     * @param {CalendarZoneCreateArgs} args - Arguments to create a CalendarZone.
     * @example
     * // Create one CalendarZone
     * const CalendarZone = await prisma.calendarZone.create({
     *   data: {
     *     // ... data to create a CalendarZone
     *   }
     * })
     * 
     */
    create<T extends CalendarZoneCreateArgs>(args: SelectSubset<T, CalendarZoneCreateArgs<ExtArgs>>): Prisma__CalendarZoneClient<$Result.GetResult<Prisma.$CalendarZonePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CalendarZones.
     * @param {CalendarZoneCreateManyArgs} args - Arguments to create many CalendarZones.
     * @example
     * // Create many CalendarZones
     * const calendarZone = await prisma.calendarZone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalendarZoneCreateManyArgs>(args?: SelectSubset<T, CalendarZoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CalendarZones and returns the data saved in the database.
     * @param {CalendarZoneCreateManyAndReturnArgs} args - Arguments to create many CalendarZones.
     * @example
     * // Create many CalendarZones
     * const calendarZone = await prisma.calendarZone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CalendarZones and only return the `id`
     * const calendarZoneWithIdOnly = await prisma.calendarZone.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CalendarZoneCreateManyAndReturnArgs>(args?: SelectSubset<T, CalendarZoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarZonePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CalendarZone.
     * @param {CalendarZoneDeleteArgs} args - Arguments to delete one CalendarZone.
     * @example
     * // Delete one CalendarZone
     * const CalendarZone = await prisma.calendarZone.delete({
     *   where: {
     *     // ... filter to delete one CalendarZone
     *   }
     * })
     * 
     */
    delete<T extends CalendarZoneDeleteArgs>(args: SelectSubset<T, CalendarZoneDeleteArgs<ExtArgs>>): Prisma__CalendarZoneClient<$Result.GetResult<Prisma.$CalendarZonePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CalendarZone.
     * @param {CalendarZoneUpdateArgs} args - Arguments to update one CalendarZone.
     * @example
     * // Update one CalendarZone
     * const calendarZone = await prisma.calendarZone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalendarZoneUpdateArgs>(args: SelectSubset<T, CalendarZoneUpdateArgs<ExtArgs>>): Prisma__CalendarZoneClient<$Result.GetResult<Prisma.$CalendarZonePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CalendarZones.
     * @param {CalendarZoneDeleteManyArgs} args - Arguments to filter CalendarZones to delete.
     * @example
     * // Delete a few CalendarZones
     * const { count } = await prisma.calendarZone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalendarZoneDeleteManyArgs>(args?: SelectSubset<T, CalendarZoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarZoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalendarZones
     * const calendarZone = await prisma.calendarZone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalendarZoneUpdateManyArgs>(args: SelectSubset<T, CalendarZoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CalendarZone.
     * @param {CalendarZoneUpsertArgs} args - Arguments to update or create a CalendarZone.
     * @example
     * // Update or create a CalendarZone
     * const calendarZone = await prisma.calendarZone.upsert({
     *   create: {
     *     // ... data to create a CalendarZone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalendarZone we want to update
     *   }
     * })
     */
    upsert<T extends CalendarZoneUpsertArgs>(args: SelectSubset<T, CalendarZoneUpsertArgs<ExtArgs>>): Prisma__CalendarZoneClient<$Result.GetResult<Prisma.$CalendarZonePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CalendarZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarZoneCountArgs} args - Arguments to filter CalendarZones to count.
     * @example
     * // Count the number of CalendarZones
     * const count = await prisma.calendarZone.count({
     *   where: {
     *     // ... the filter for the CalendarZones we want to count
     *   }
     * })
    **/
    count<T extends CalendarZoneCountArgs>(
      args?: Subset<T, CalendarZoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarZoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CalendarZone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarZoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarZoneAggregateArgs>(args: Subset<T, CalendarZoneAggregateArgs>): Prisma.PrismaPromise<GetCalendarZoneAggregateType<T>>

    /**
     * Group by CalendarZone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarZoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarZoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarZoneGroupByArgs['orderBy'] }
        : { orderBy?: CalendarZoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarZoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarZoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CalendarZone model
   */
  readonly fields: CalendarZoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CalendarZone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalendarZoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    calendar<T extends CalendarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CalendarDefaultArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    zone<T extends ZoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ZoneDefaultArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    districts<T extends CalendarZone$districtsArgs<ExtArgs> = {}>(args?: Subset<T, CalendarZone$districtsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarZoneDistrictPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CalendarZone model
   */ 
  interface CalendarZoneFieldRefs {
    readonly id: FieldRef<"CalendarZone", 'String'>
    readonly calendarId: FieldRef<"CalendarZone", 'String'>
    readonly zoneId: FieldRef<"CalendarZone", 'String'>
    readonly zoneName: FieldRef<"CalendarZone", 'String'>
    readonly cityCount: FieldRef<"CalendarZone", 'Int'>
    readonly districtCount: FieldRef<"CalendarZone", 'Int'>
    readonly createdAt: FieldRef<"CalendarZone", 'DateTime'>
    readonly updatedAt: FieldRef<"CalendarZone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CalendarZone findUnique
   */
  export type CalendarZoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarZone
     */
    select?: CalendarZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarZoneInclude<ExtArgs> | null
    /**
     * Filter, which CalendarZone to fetch.
     */
    where: CalendarZoneWhereUniqueInput
  }

  /**
   * CalendarZone findUniqueOrThrow
   */
  export type CalendarZoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarZone
     */
    select?: CalendarZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarZoneInclude<ExtArgs> | null
    /**
     * Filter, which CalendarZone to fetch.
     */
    where: CalendarZoneWhereUniqueInput
  }

  /**
   * CalendarZone findFirst
   */
  export type CalendarZoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarZone
     */
    select?: CalendarZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarZoneInclude<ExtArgs> | null
    /**
     * Filter, which CalendarZone to fetch.
     */
    where?: CalendarZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarZones to fetch.
     */
    orderBy?: CalendarZoneOrderByWithRelationInput | CalendarZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarZones.
     */
    cursor?: CalendarZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarZones.
     */
    distinct?: CalendarZoneScalarFieldEnum | CalendarZoneScalarFieldEnum[]
  }

  /**
   * CalendarZone findFirstOrThrow
   */
  export type CalendarZoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarZone
     */
    select?: CalendarZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarZoneInclude<ExtArgs> | null
    /**
     * Filter, which CalendarZone to fetch.
     */
    where?: CalendarZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarZones to fetch.
     */
    orderBy?: CalendarZoneOrderByWithRelationInput | CalendarZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarZones.
     */
    cursor?: CalendarZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarZones.
     */
    distinct?: CalendarZoneScalarFieldEnum | CalendarZoneScalarFieldEnum[]
  }

  /**
   * CalendarZone findMany
   */
  export type CalendarZoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarZone
     */
    select?: CalendarZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarZoneInclude<ExtArgs> | null
    /**
     * Filter, which CalendarZones to fetch.
     */
    where?: CalendarZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarZones to fetch.
     */
    orderBy?: CalendarZoneOrderByWithRelationInput | CalendarZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CalendarZones.
     */
    cursor?: CalendarZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarZones.
     */
    skip?: number
    distinct?: CalendarZoneScalarFieldEnum | CalendarZoneScalarFieldEnum[]
  }

  /**
   * CalendarZone create
   */
  export type CalendarZoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarZone
     */
    select?: CalendarZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarZoneInclude<ExtArgs> | null
    /**
     * The data needed to create a CalendarZone.
     */
    data: XOR<CalendarZoneCreateInput, CalendarZoneUncheckedCreateInput>
  }

  /**
   * CalendarZone createMany
   */
  export type CalendarZoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CalendarZones.
     */
    data: CalendarZoneCreateManyInput | CalendarZoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalendarZone createManyAndReturn
   */
  export type CalendarZoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarZone
     */
    select?: CalendarZoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CalendarZones.
     */
    data: CalendarZoneCreateManyInput | CalendarZoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarZoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CalendarZone update
   */
  export type CalendarZoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarZone
     */
    select?: CalendarZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarZoneInclude<ExtArgs> | null
    /**
     * The data needed to update a CalendarZone.
     */
    data: XOR<CalendarZoneUpdateInput, CalendarZoneUncheckedUpdateInput>
    /**
     * Choose, which CalendarZone to update.
     */
    where: CalendarZoneWhereUniqueInput
  }

  /**
   * CalendarZone updateMany
   */
  export type CalendarZoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CalendarZones.
     */
    data: XOR<CalendarZoneUpdateManyMutationInput, CalendarZoneUncheckedUpdateManyInput>
    /**
     * Filter which CalendarZones to update
     */
    where?: CalendarZoneWhereInput
  }

  /**
   * CalendarZone upsert
   */
  export type CalendarZoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarZone
     */
    select?: CalendarZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarZoneInclude<ExtArgs> | null
    /**
     * The filter to search for the CalendarZone to update in case it exists.
     */
    where: CalendarZoneWhereUniqueInput
    /**
     * In case the CalendarZone found by the `where` argument doesn't exist, create a new CalendarZone with this data.
     */
    create: XOR<CalendarZoneCreateInput, CalendarZoneUncheckedCreateInput>
    /**
     * In case the CalendarZone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarZoneUpdateInput, CalendarZoneUncheckedUpdateInput>
  }

  /**
   * CalendarZone delete
   */
  export type CalendarZoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarZone
     */
    select?: CalendarZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarZoneInclude<ExtArgs> | null
    /**
     * Filter which CalendarZone to delete.
     */
    where: CalendarZoneWhereUniqueInput
  }

  /**
   * CalendarZone deleteMany
   */
  export type CalendarZoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarZones to delete
     */
    where?: CalendarZoneWhereInput
  }

  /**
   * CalendarZone.districts
   */
  export type CalendarZone$districtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarZoneDistrict
     */
    select?: CalendarZoneDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarZoneDistrictInclude<ExtArgs> | null
    where?: CalendarZoneDistrictWhereInput
    orderBy?: CalendarZoneDistrictOrderByWithRelationInput | CalendarZoneDistrictOrderByWithRelationInput[]
    cursor?: CalendarZoneDistrictWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarZoneDistrictScalarFieldEnum | CalendarZoneDistrictScalarFieldEnum[]
  }

  /**
   * CalendarZone without action
   */
  export type CalendarZoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarZone
     */
    select?: CalendarZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarZoneInclude<ExtArgs> | null
  }


  /**
   * Model CalendarZoneDistrict
   */

  export type AggregateCalendarZoneDistrict = {
    _count: CalendarZoneDistrictCountAggregateOutputType | null
    _avg: CalendarZoneDistrictAvgAggregateOutputType | null
    _sum: CalendarZoneDistrictSumAggregateOutputType | null
    _min: CalendarZoneDistrictMinAggregateOutputType | null
    _max: CalendarZoneDistrictMaxAggregateOutputType | null
  }

  export type CalendarZoneDistrictAvgAggregateOutputType = {
    districtId: number | null
  }

  export type CalendarZoneDistrictSumAggregateOutputType = {
    districtId: number | null
  }

  export type CalendarZoneDistrictMinAggregateOutputType = {
    calendarZoneId: string | null
    districtId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalendarZoneDistrictMaxAggregateOutputType = {
    calendarZoneId: string | null
    districtId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalendarZoneDistrictCountAggregateOutputType = {
    calendarZoneId: number
    districtId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CalendarZoneDistrictAvgAggregateInputType = {
    districtId?: true
  }

  export type CalendarZoneDistrictSumAggregateInputType = {
    districtId?: true
  }

  export type CalendarZoneDistrictMinAggregateInputType = {
    calendarZoneId?: true
    districtId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalendarZoneDistrictMaxAggregateInputType = {
    calendarZoneId?: true
    districtId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalendarZoneDistrictCountAggregateInputType = {
    calendarZoneId?: true
    districtId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CalendarZoneDistrictAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarZoneDistrict to aggregate.
     */
    where?: CalendarZoneDistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarZoneDistricts to fetch.
     */
    orderBy?: CalendarZoneDistrictOrderByWithRelationInput | CalendarZoneDistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarZoneDistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarZoneDistricts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarZoneDistricts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CalendarZoneDistricts
    **/
    _count?: true | CalendarZoneDistrictCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CalendarZoneDistrictAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CalendarZoneDistrictSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarZoneDistrictMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarZoneDistrictMaxAggregateInputType
  }

  export type GetCalendarZoneDistrictAggregateType<T extends CalendarZoneDistrictAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendarZoneDistrict]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendarZoneDistrict[P]>
      : GetScalarType<T[P], AggregateCalendarZoneDistrict[P]>
  }




  export type CalendarZoneDistrictGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarZoneDistrictWhereInput
    orderBy?: CalendarZoneDistrictOrderByWithAggregationInput | CalendarZoneDistrictOrderByWithAggregationInput[]
    by: CalendarZoneDistrictScalarFieldEnum[] | CalendarZoneDistrictScalarFieldEnum
    having?: CalendarZoneDistrictScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarZoneDistrictCountAggregateInputType | true
    _avg?: CalendarZoneDistrictAvgAggregateInputType
    _sum?: CalendarZoneDistrictSumAggregateInputType
    _min?: CalendarZoneDistrictMinAggregateInputType
    _max?: CalendarZoneDistrictMaxAggregateInputType
  }

  export type CalendarZoneDistrictGroupByOutputType = {
    calendarZoneId: string
    districtId: number
    createdAt: Date
    updatedAt: Date
    _count: CalendarZoneDistrictCountAggregateOutputType | null
    _avg: CalendarZoneDistrictAvgAggregateOutputType | null
    _sum: CalendarZoneDistrictSumAggregateOutputType | null
    _min: CalendarZoneDistrictMinAggregateOutputType | null
    _max: CalendarZoneDistrictMaxAggregateOutputType | null
  }

  type GetCalendarZoneDistrictGroupByPayload<T extends CalendarZoneDistrictGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarZoneDistrictGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarZoneDistrictGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarZoneDistrictGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarZoneDistrictGroupByOutputType[P]>
        }
      >
    >


  export type CalendarZoneDistrictSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    calendarZoneId?: boolean
    districtId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    calendarZone?: boolean | CalendarZoneDefaultArgs<ExtArgs>
    district?: boolean | DistrictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarZoneDistrict"]>

  export type CalendarZoneDistrictSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    calendarZoneId?: boolean
    districtId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    calendarZone?: boolean | CalendarZoneDefaultArgs<ExtArgs>
    district?: boolean | DistrictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarZoneDistrict"]>

  export type CalendarZoneDistrictSelectScalar = {
    calendarZoneId?: boolean
    districtId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CalendarZoneDistrictInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calendarZone?: boolean | CalendarZoneDefaultArgs<ExtArgs>
    district?: boolean | DistrictDefaultArgs<ExtArgs>
  }
  export type CalendarZoneDistrictIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calendarZone?: boolean | CalendarZoneDefaultArgs<ExtArgs>
    district?: boolean | DistrictDefaultArgs<ExtArgs>
  }

  export type $CalendarZoneDistrictPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CalendarZoneDistrict"
    objects: {
      calendarZone: Prisma.$CalendarZonePayload<ExtArgs>
      district: Prisma.$DistrictPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      calendarZoneId: string
      districtId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["calendarZoneDistrict"]>
    composites: {}
  }

  type CalendarZoneDistrictGetPayload<S extends boolean | null | undefined | CalendarZoneDistrictDefaultArgs> = $Result.GetResult<Prisma.$CalendarZoneDistrictPayload, S>

  type CalendarZoneDistrictCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CalendarZoneDistrictFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CalendarZoneDistrictCountAggregateInputType | true
    }

  export interface CalendarZoneDistrictDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CalendarZoneDistrict'], meta: { name: 'CalendarZoneDistrict' } }
    /**
     * Find zero or one CalendarZoneDistrict that matches the filter.
     * @param {CalendarZoneDistrictFindUniqueArgs} args - Arguments to find a CalendarZoneDistrict
     * @example
     * // Get one CalendarZoneDistrict
     * const calendarZoneDistrict = await prisma.calendarZoneDistrict.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalendarZoneDistrictFindUniqueArgs>(args: SelectSubset<T, CalendarZoneDistrictFindUniqueArgs<ExtArgs>>): Prisma__CalendarZoneDistrictClient<$Result.GetResult<Prisma.$CalendarZoneDistrictPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CalendarZoneDistrict that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CalendarZoneDistrictFindUniqueOrThrowArgs} args - Arguments to find a CalendarZoneDistrict
     * @example
     * // Get one CalendarZoneDistrict
     * const calendarZoneDistrict = await prisma.calendarZoneDistrict.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalendarZoneDistrictFindUniqueOrThrowArgs>(args: SelectSubset<T, CalendarZoneDistrictFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalendarZoneDistrictClient<$Result.GetResult<Prisma.$CalendarZoneDistrictPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CalendarZoneDistrict that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarZoneDistrictFindFirstArgs} args - Arguments to find a CalendarZoneDistrict
     * @example
     * // Get one CalendarZoneDistrict
     * const calendarZoneDistrict = await prisma.calendarZoneDistrict.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalendarZoneDistrictFindFirstArgs>(args?: SelectSubset<T, CalendarZoneDistrictFindFirstArgs<ExtArgs>>): Prisma__CalendarZoneDistrictClient<$Result.GetResult<Prisma.$CalendarZoneDistrictPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CalendarZoneDistrict that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarZoneDistrictFindFirstOrThrowArgs} args - Arguments to find a CalendarZoneDistrict
     * @example
     * // Get one CalendarZoneDistrict
     * const calendarZoneDistrict = await prisma.calendarZoneDistrict.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalendarZoneDistrictFindFirstOrThrowArgs>(args?: SelectSubset<T, CalendarZoneDistrictFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalendarZoneDistrictClient<$Result.GetResult<Prisma.$CalendarZoneDistrictPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CalendarZoneDistricts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarZoneDistrictFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalendarZoneDistricts
     * const calendarZoneDistricts = await prisma.calendarZoneDistrict.findMany()
     * 
     * // Get first 10 CalendarZoneDistricts
     * const calendarZoneDistricts = await prisma.calendarZoneDistrict.findMany({ take: 10 })
     * 
     * // Only select the `calendarZoneId`
     * const calendarZoneDistrictWithCalendarZoneIdOnly = await prisma.calendarZoneDistrict.findMany({ select: { calendarZoneId: true } })
     * 
     */
    findMany<T extends CalendarZoneDistrictFindManyArgs>(args?: SelectSubset<T, CalendarZoneDistrictFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarZoneDistrictPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CalendarZoneDistrict.
     * @param {CalendarZoneDistrictCreateArgs} args - Arguments to create a CalendarZoneDistrict.
     * @example
     * // Create one CalendarZoneDistrict
     * const CalendarZoneDistrict = await prisma.calendarZoneDistrict.create({
     *   data: {
     *     // ... data to create a CalendarZoneDistrict
     *   }
     * })
     * 
     */
    create<T extends CalendarZoneDistrictCreateArgs>(args: SelectSubset<T, CalendarZoneDistrictCreateArgs<ExtArgs>>): Prisma__CalendarZoneDistrictClient<$Result.GetResult<Prisma.$CalendarZoneDistrictPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CalendarZoneDistricts.
     * @param {CalendarZoneDistrictCreateManyArgs} args - Arguments to create many CalendarZoneDistricts.
     * @example
     * // Create many CalendarZoneDistricts
     * const calendarZoneDistrict = await prisma.calendarZoneDistrict.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalendarZoneDistrictCreateManyArgs>(args?: SelectSubset<T, CalendarZoneDistrictCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CalendarZoneDistricts and returns the data saved in the database.
     * @param {CalendarZoneDistrictCreateManyAndReturnArgs} args - Arguments to create many CalendarZoneDistricts.
     * @example
     * // Create many CalendarZoneDistricts
     * const calendarZoneDistrict = await prisma.calendarZoneDistrict.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CalendarZoneDistricts and only return the `calendarZoneId`
     * const calendarZoneDistrictWithCalendarZoneIdOnly = await prisma.calendarZoneDistrict.createManyAndReturn({ 
     *   select: { calendarZoneId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CalendarZoneDistrictCreateManyAndReturnArgs>(args?: SelectSubset<T, CalendarZoneDistrictCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarZoneDistrictPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CalendarZoneDistrict.
     * @param {CalendarZoneDistrictDeleteArgs} args - Arguments to delete one CalendarZoneDistrict.
     * @example
     * // Delete one CalendarZoneDistrict
     * const CalendarZoneDistrict = await prisma.calendarZoneDistrict.delete({
     *   where: {
     *     // ... filter to delete one CalendarZoneDistrict
     *   }
     * })
     * 
     */
    delete<T extends CalendarZoneDistrictDeleteArgs>(args: SelectSubset<T, CalendarZoneDistrictDeleteArgs<ExtArgs>>): Prisma__CalendarZoneDistrictClient<$Result.GetResult<Prisma.$CalendarZoneDistrictPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CalendarZoneDistrict.
     * @param {CalendarZoneDistrictUpdateArgs} args - Arguments to update one CalendarZoneDistrict.
     * @example
     * // Update one CalendarZoneDistrict
     * const calendarZoneDistrict = await prisma.calendarZoneDistrict.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalendarZoneDistrictUpdateArgs>(args: SelectSubset<T, CalendarZoneDistrictUpdateArgs<ExtArgs>>): Prisma__CalendarZoneDistrictClient<$Result.GetResult<Prisma.$CalendarZoneDistrictPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CalendarZoneDistricts.
     * @param {CalendarZoneDistrictDeleteManyArgs} args - Arguments to filter CalendarZoneDistricts to delete.
     * @example
     * // Delete a few CalendarZoneDistricts
     * const { count } = await prisma.calendarZoneDistrict.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalendarZoneDistrictDeleteManyArgs>(args?: SelectSubset<T, CalendarZoneDistrictDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarZoneDistricts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarZoneDistrictUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalendarZoneDistricts
     * const calendarZoneDistrict = await prisma.calendarZoneDistrict.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalendarZoneDistrictUpdateManyArgs>(args: SelectSubset<T, CalendarZoneDistrictUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CalendarZoneDistrict.
     * @param {CalendarZoneDistrictUpsertArgs} args - Arguments to update or create a CalendarZoneDistrict.
     * @example
     * // Update or create a CalendarZoneDistrict
     * const calendarZoneDistrict = await prisma.calendarZoneDistrict.upsert({
     *   create: {
     *     // ... data to create a CalendarZoneDistrict
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalendarZoneDistrict we want to update
     *   }
     * })
     */
    upsert<T extends CalendarZoneDistrictUpsertArgs>(args: SelectSubset<T, CalendarZoneDistrictUpsertArgs<ExtArgs>>): Prisma__CalendarZoneDistrictClient<$Result.GetResult<Prisma.$CalendarZoneDistrictPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CalendarZoneDistricts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarZoneDistrictCountArgs} args - Arguments to filter CalendarZoneDistricts to count.
     * @example
     * // Count the number of CalendarZoneDistricts
     * const count = await prisma.calendarZoneDistrict.count({
     *   where: {
     *     // ... the filter for the CalendarZoneDistricts we want to count
     *   }
     * })
    **/
    count<T extends CalendarZoneDistrictCountArgs>(
      args?: Subset<T, CalendarZoneDistrictCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarZoneDistrictCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CalendarZoneDistrict.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarZoneDistrictAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarZoneDistrictAggregateArgs>(args: Subset<T, CalendarZoneDistrictAggregateArgs>): Prisma.PrismaPromise<GetCalendarZoneDistrictAggregateType<T>>

    /**
     * Group by CalendarZoneDistrict.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarZoneDistrictGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarZoneDistrictGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarZoneDistrictGroupByArgs['orderBy'] }
        : { orderBy?: CalendarZoneDistrictGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarZoneDistrictGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarZoneDistrictGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CalendarZoneDistrict model
   */
  readonly fields: CalendarZoneDistrictFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CalendarZoneDistrict.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalendarZoneDistrictClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    calendarZone<T extends CalendarZoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CalendarZoneDefaultArgs<ExtArgs>>): Prisma__CalendarZoneClient<$Result.GetResult<Prisma.$CalendarZonePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    district<T extends DistrictDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DistrictDefaultArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CalendarZoneDistrict model
   */ 
  interface CalendarZoneDistrictFieldRefs {
    readonly calendarZoneId: FieldRef<"CalendarZoneDistrict", 'String'>
    readonly districtId: FieldRef<"CalendarZoneDistrict", 'Int'>
    readonly createdAt: FieldRef<"CalendarZoneDistrict", 'DateTime'>
    readonly updatedAt: FieldRef<"CalendarZoneDistrict", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CalendarZoneDistrict findUnique
   */
  export type CalendarZoneDistrictFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarZoneDistrict
     */
    select?: CalendarZoneDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarZoneDistrictInclude<ExtArgs> | null
    /**
     * Filter, which CalendarZoneDistrict to fetch.
     */
    where: CalendarZoneDistrictWhereUniqueInput
  }

  /**
   * CalendarZoneDistrict findUniqueOrThrow
   */
  export type CalendarZoneDistrictFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarZoneDistrict
     */
    select?: CalendarZoneDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarZoneDistrictInclude<ExtArgs> | null
    /**
     * Filter, which CalendarZoneDistrict to fetch.
     */
    where: CalendarZoneDistrictWhereUniqueInput
  }

  /**
   * CalendarZoneDistrict findFirst
   */
  export type CalendarZoneDistrictFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarZoneDistrict
     */
    select?: CalendarZoneDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarZoneDistrictInclude<ExtArgs> | null
    /**
     * Filter, which CalendarZoneDistrict to fetch.
     */
    where?: CalendarZoneDistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarZoneDistricts to fetch.
     */
    orderBy?: CalendarZoneDistrictOrderByWithRelationInput | CalendarZoneDistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarZoneDistricts.
     */
    cursor?: CalendarZoneDistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarZoneDistricts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarZoneDistricts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarZoneDistricts.
     */
    distinct?: CalendarZoneDistrictScalarFieldEnum | CalendarZoneDistrictScalarFieldEnum[]
  }

  /**
   * CalendarZoneDistrict findFirstOrThrow
   */
  export type CalendarZoneDistrictFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarZoneDistrict
     */
    select?: CalendarZoneDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarZoneDistrictInclude<ExtArgs> | null
    /**
     * Filter, which CalendarZoneDistrict to fetch.
     */
    where?: CalendarZoneDistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarZoneDistricts to fetch.
     */
    orderBy?: CalendarZoneDistrictOrderByWithRelationInput | CalendarZoneDistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarZoneDistricts.
     */
    cursor?: CalendarZoneDistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarZoneDistricts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarZoneDistricts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarZoneDistricts.
     */
    distinct?: CalendarZoneDistrictScalarFieldEnum | CalendarZoneDistrictScalarFieldEnum[]
  }

  /**
   * CalendarZoneDistrict findMany
   */
  export type CalendarZoneDistrictFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarZoneDistrict
     */
    select?: CalendarZoneDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarZoneDistrictInclude<ExtArgs> | null
    /**
     * Filter, which CalendarZoneDistricts to fetch.
     */
    where?: CalendarZoneDistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarZoneDistricts to fetch.
     */
    orderBy?: CalendarZoneDistrictOrderByWithRelationInput | CalendarZoneDistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CalendarZoneDistricts.
     */
    cursor?: CalendarZoneDistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarZoneDistricts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarZoneDistricts.
     */
    skip?: number
    distinct?: CalendarZoneDistrictScalarFieldEnum | CalendarZoneDistrictScalarFieldEnum[]
  }

  /**
   * CalendarZoneDistrict create
   */
  export type CalendarZoneDistrictCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarZoneDistrict
     */
    select?: CalendarZoneDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarZoneDistrictInclude<ExtArgs> | null
    /**
     * The data needed to create a CalendarZoneDistrict.
     */
    data: XOR<CalendarZoneDistrictCreateInput, CalendarZoneDistrictUncheckedCreateInput>
  }

  /**
   * CalendarZoneDistrict createMany
   */
  export type CalendarZoneDistrictCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CalendarZoneDistricts.
     */
    data: CalendarZoneDistrictCreateManyInput | CalendarZoneDistrictCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalendarZoneDistrict createManyAndReturn
   */
  export type CalendarZoneDistrictCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarZoneDistrict
     */
    select?: CalendarZoneDistrictSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CalendarZoneDistricts.
     */
    data: CalendarZoneDistrictCreateManyInput | CalendarZoneDistrictCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarZoneDistrictIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CalendarZoneDistrict update
   */
  export type CalendarZoneDistrictUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarZoneDistrict
     */
    select?: CalendarZoneDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarZoneDistrictInclude<ExtArgs> | null
    /**
     * The data needed to update a CalendarZoneDistrict.
     */
    data: XOR<CalendarZoneDistrictUpdateInput, CalendarZoneDistrictUncheckedUpdateInput>
    /**
     * Choose, which CalendarZoneDistrict to update.
     */
    where: CalendarZoneDistrictWhereUniqueInput
  }

  /**
   * CalendarZoneDistrict updateMany
   */
  export type CalendarZoneDistrictUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CalendarZoneDistricts.
     */
    data: XOR<CalendarZoneDistrictUpdateManyMutationInput, CalendarZoneDistrictUncheckedUpdateManyInput>
    /**
     * Filter which CalendarZoneDistricts to update
     */
    where?: CalendarZoneDistrictWhereInput
  }

  /**
   * CalendarZoneDistrict upsert
   */
  export type CalendarZoneDistrictUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarZoneDistrict
     */
    select?: CalendarZoneDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarZoneDistrictInclude<ExtArgs> | null
    /**
     * The filter to search for the CalendarZoneDistrict to update in case it exists.
     */
    where: CalendarZoneDistrictWhereUniqueInput
    /**
     * In case the CalendarZoneDistrict found by the `where` argument doesn't exist, create a new CalendarZoneDistrict with this data.
     */
    create: XOR<CalendarZoneDistrictCreateInput, CalendarZoneDistrictUncheckedCreateInput>
    /**
     * In case the CalendarZoneDistrict was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarZoneDistrictUpdateInput, CalendarZoneDistrictUncheckedUpdateInput>
  }

  /**
   * CalendarZoneDistrict delete
   */
  export type CalendarZoneDistrictDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarZoneDistrict
     */
    select?: CalendarZoneDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarZoneDistrictInclude<ExtArgs> | null
    /**
     * Filter which CalendarZoneDistrict to delete.
     */
    where: CalendarZoneDistrictWhereUniqueInput
  }

  /**
   * CalendarZoneDistrict deleteMany
   */
  export type CalendarZoneDistrictDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarZoneDistricts to delete
     */
    where?: CalendarZoneDistrictWhereInput
  }

  /**
   * CalendarZoneDistrict without action
   */
  export type CalendarZoneDistrictDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarZoneDistrict
     */
    select?: CalendarZoneDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarZoneDistrictInclude<ExtArgs> | null
  }


  /**
   * Model CalendarIndicator
   */

  export type AggregateCalendarIndicator = {
    _count: CalendarIndicatorCountAggregateOutputType | null
    _min: CalendarIndicatorMinAggregateOutputType | null
    _max: CalendarIndicatorMaxAggregateOutputType | null
  }

  export type CalendarIndicatorMinAggregateOutputType = {
    id: string | null
    calendarId: string | null
    indicatorId: string | null
    nameSnapshot: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalendarIndicatorMaxAggregateOutputType = {
    id: string | null
    calendarId: string | null
    indicatorId: string | null
    nameSnapshot: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalendarIndicatorCountAggregateOutputType = {
    id: number
    calendarId: number
    indicatorId: number
    nameSnapshot: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CalendarIndicatorMinAggregateInputType = {
    id?: true
    calendarId?: true
    indicatorId?: true
    nameSnapshot?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalendarIndicatorMaxAggregateInputType = {
    id?: true
    calendarId?: true
    indicatorId?: true
    nameSnapshot?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalendarIndicatorCountAggregateInputType = {
    id?: true
    calendarId?: true
    indicatorId?: true
    nameSnapshot?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CalendarIndicatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarIndicator to aggregate.
     */
    where?: CalendarIndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarIndicators to fetch.
     */
    orderBy?: CalendarIndicatorOrderByWithRelationInput | CalendarIndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarIndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarIndicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarIndicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CalendarIndicators
    **/
    _count?: true | CalendarIndicatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarIndicatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarIndicatorMaxAggregateInputType
  }

  export type GetCalendarIndicatorAggregateType<T extends CalendarIndicatorAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendarIndicator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendarIndicator[P]>
      : GetScalarType<T[P], AggregateCalendarIndicator[P]>
  }




  export type CalendarIndicatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarIndicatorWhereInput
    orderBy?: CalendarIndicatorOrderByWithAggregationInput | CalendarIndicatorOrderByWithAggregationInput[]
    by: CalendarIndicatorScalarFieldEnum[] | CalendarIndicatorScalarFieldEnum
    having?: CalendarIndicatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarIndicatorCountAggregateInputType | true
    _min?: CalendarIndicatorMinAggregateInputType
    _max?: CalendarIndicatorMaxAggregateInputType
  }

  export type CalendarIndicatorGroupByOutputType = {
    id: string
    calendarId: string
    indicatorId: string
    nameSnapshot: string
    createdAt: Date
    updatedAt: Date
    _count: CalendarIndicatorCountAggregateOutputType | null
    _min: CalendarIndicatorMinAggregateOutputType | null
    _max: CalendarIndicatorMaxAggregateOutputType | null
  }

  type GetCalendarIndicatorGroupByPayload<T extends CalendarIndicatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarIndicatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarIndicatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarIndicatorGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarIndicatorGroupByOutputType[P]>
        }
      >
    >


  export type CalendarIndicatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    calendarId?: boolean
    indicatorId?: boolean
    nameSnapshot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    calendar?: boolean | CalendarDefaultArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarIndicator"]>

  export type CalendarIndicatorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    calendarId?: boolean
    indicatorId?: boolean
    nameSnapshot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    calendar?: boolean | CalendarDefaultArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarIndicator"]>

  export type CalendarIndicatorSelectScalar = {
    id?: boolean
    calendarId?: boolean
    indicatorId?: boolean
    nameSnapshot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CalendarIndicatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calendar?: boolean | CalendarDefaultArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
  }
  export type CalendarIndicatorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calendar?: boolean | CalendarDefaultArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
  }

  export type $CalendarIndicatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CalendarIndicator"
    objects: {
      calendar: Prisma.$CalendarPayload<ExtArgs>
      indicator: Prisma.$IndicatorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      calendarId: string
      indicatorId: string
      nameSnapshot: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["calendarIndicator"]>
    composites: {}
  }

  type CalendarIndicatorGetPayload<S extends boolean | null | undefined | CalendarIndicatorDefaultArgs> = $Result.GetResult<Prisma.$CalendarIndicatorPayload, S>

  type CalendarIndicatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CalendarIndicatorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CalendarIndicatorCountAggregateInputType | true
    }

  export interface CalendarIndicatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CalendarIndicator'], meta: { name: 'CalendarIndicator' } }
    /**
     * Find zero or one CalendarIndicator that matches the filter.
     * @param {CalendarIndicatorFindUniqueArgs} args - Arguments to find a CalendarIndicator
     * @example
     * // Get one CalendarIndicator
     * const calendarIndicator = await prisma.calendarIndicator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalendarIndicatorFindUniqueArgs>(args: SelectSubset<T, CalendarIndicatorFindUniqueArgs<ExtArgs>>): Prisma__CalendarIndicatorClient<$Result.GetResult<Prisma.$CalendarIndicatorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CalendarIndicator that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CalendarIndicatorFindUniqueOrThrowArgs} args - Arguments to find a CalendarIndicator
     * @example
     * // Get one CalendarIndicator
     * const calendarIndicator = await prisma.calendarIndicator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalendarIndicatorFindUniqueOrThrowArgs>(args: SelectSubset<T, CalendarIndicatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalendarIndicatorClient<$Result.GetResult<Prisma.$CalendarIndicatorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CalendarIndicator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarIndicatorFindFirstArgs} args - Arguments to find a CalendarIndicator
     * @example
     * // Get one CalendarIndicator
     * const calendarIndicator = await prisma.calendarIndicator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalendarIndicatorFindFirstArgs>(args?: SelectSubset<T, CalendarIndicatorFindFirstArgs<ExtArgs>>): Prisma__CalendarIndicatorClient<$Result.GetResult<Prisma.$CalendarIndicatorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CalendarIndicator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarIndicatorFindFirstOrThrowArgs} args - Arguments to find a CalendarIndicator
     * @example
     * // Get one CalendarIndicator
     * const calendarIndicator = await prisma.calendarIndicator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalendarIndicatorFindFirstOrThrowArgs>(args?: SelectSubset<T, CalendarIndicatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalendarIndicatorClient<$Result.GetResult<Prisma.$CalendarIndicatorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CalendarIndicators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarIndicatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalendarIndicators
     * const calendarIndicators = await prisma.calendarIndicator.findMany()
     * 
     * // Get first 10 CalendarIndicators
     * const calendarIndicators = await prisma.calendarIndicator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarIndicatorWithIdOnly = await prisma.calendarIndicator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalendarIndicatorFindManyArgs>(args?: SelectSubset<T, CalendarIndicatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarIndicatorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CalendarIndicator.
     * @param {CalendarIndicatorCreateArgs} args - Arguments to create a CalendarIndicator.
     * @example
     * // Create one CalendarIndicator
     * const CalendarIndicator = await prisma.calendarIndicator.create({
     *   data: {
     *     // ... data to create a CalendarIndicator
     *   }
     * })
     * 
     */
    create<T extends CalendarIndicatorCreateArgs>(args: SelectSubset<T, CalendarIndicatorCreateArgs<ExtArgs>>): Prisma__CalendarIndicatorClient<$Result.GetResult<Prisma.$CalendarIndicatorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CalendarIndicators.
     * @param {CalendarIndicatorCreateManyArgs} args - Arguments to create many CalendarIndicators.
     * @example
     * // Create many CalendarIndicators
     * const calendarIndicator = await prisma.calendarIndicator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalendarIndicatorCreateManyArgs>(args?: SelectSubset<T, CalendarIndicatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CalendarIndicators and returns the data saved in the database.
     * @param {CalendarIndicatorCreateManyAndReturnArgs} args - Arguments to create many CalendarIndicators.
     * @example
     * // Create many CalendarIndicators
     * const calendarIndicator = await prisma.calendarIndicator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CalendarIndicators and only return the `id`
     * const calendarIndicatorWithIdOnly = await prisma.calendarIndicator.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CalendarIndicatorCreateManyAndReturnArgs>(args?: SelectSubset<T, CalendarIndicatorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarIndicatorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CalendarIndicator.
     * @param {CalendarIndicatorDeleteArgs} args - Arguments to delete one CalendarIndicator.
     * @example
     * // Delete one CalendarIndicator
     * const CalendarIndicator = await prisma.calendarIndicator.delete({
     *   where: {
     *     // ... filter to delete one CalendarIndicator
     *   }
     * })
     * 
     */
    delete<T extends CalendarIndicatorDeleteArgs>(args: SelectSubset<T, CalendarIndicatorDeleteArgs<ExtArgs>>): Prisma__CalendarIndicatorClient<$Result.GetResult<Prisma.$CalendarIndicatorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CalendarIndicator.
     * @param {CalendarIndicatorUpdateArgs} args - Arguments to update one CalendarIndicator.
     * @example
     * // Update one CalendarIndicator
     * const calendarIndicator = await prisma.calendarIndicator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalendarIndicatorUpdateArgs>(args: SelectSubset<T, CalendarIndicatorUpdateArgs<ExtArgs>>): Prisma__CalendarIndicatorClient<$Result.GetResult<Prisma.$CalendarIndicatorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CalendarIndicators.
     * @param {CalendarIndicatorDeleteManyArgs} args - Arguments to filter CalendarIndicators to delete.
     * @example
     * // Delete a few CalendarIndicators
     * const { count } = await prisma.calendarIndicator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalendarIndicatorDeleteManyArgs>(args?: SelectSubset<T, CalendarIndicatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarIndicators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarIndicatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalendarIndicators
     * const calendarIndicator = await prisma.calendarIndicator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalendarIndicatorUpdateManyArgs>(args: SelectSubset<T, CalendarIndicatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CalendarIndicator.
     * @param {CalendarIndicatorUpsertArgs} args - Arguments to update or create a CalendarIndicator.
     * @example
     * // Update or create a CalendarIndicator
     * const calendarIndicator = await prisma.calendarIndicator.upsert({
     *   create: {
     *     // ... data to create a CalendarIndicator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalendarIndicator we want to update
     *   }
     * })
     */
    upsert<T extends CalendarIndicatorUpsertArgs>(args: SelectSubset<T, CalendarIndicatorUpsertArgs<ExtArgs>>): Prisma__CalendarIndicatorClient<$Result.GetResult<Prisma.$CalendarIndicatorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CalendarIndicators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarIndicatorCountArgs} args - Arguments to filter CalendarIndicators to count.
     * @example
     * // Count the number of CalendarIndicators
     * const count = await prisma.calendarIndicator.count({
     *   where: {
     *     // ... the filter for the CalendarIndicators we want to count
     *   }
     * })
    **/
    count<T extends CalendarIndicatorCountArgs>(
      args?: Subset<T, CalendarIndicatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarIndicatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CalendarIndicator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarIndicatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarIndicatorAggregateArgs>(args: Subset<T, CalendarIndicatorAggregateArgs>): Prisma.PrismaPromise<GetCalendarIndicatorAggregateType<T>>

    /**
     * Group by CalendarIndicator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarIndicatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarIndicatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarIndicatorGroupByArgs['orderBy'] }
        : { orderBy?: CalendarIndicatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarIndicatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarIndicatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CalendarIndicator model
   */
  readonly fields: CalendarIndicatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CalendarIndicator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalendarIndicatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    calendar<T extends CalendarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CalendarDefaultArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    indicator<T extends IndicatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IndicatorDefaultArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CalendarIndicator model
   */ 
  interface CalendarIndicatorFieldRefs {
    readonly id: FieldRef<"CalendarIndicator", 'String'>
    readonly calendarId: FieldRef<"CalendarIndicator", 'String'>
    readonly indicatorId: FieldRef<"CalendarIndicator", 'String'>
    readonly nameSnapshot: FieldRef<"CalendarIndicator", 'String'>
    readonly createdAt: FieldRef<"CalendarIndicator", 'DateTime'>
    readonly updatedAt: FieldRef<"CalendarIndicator", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CalendarIndicator findUnique
   */
  export type CalendarIndicatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarIndicator
     */
    select?: CalendarIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which CalendarIndicator to fetch.
     */
    where: CalendarIndicatorWhereUniqueInput
  }

  /**
   * CalendarIndicator findUniqueOrThrow
   */
  export type CalendarIndicatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarIndicator
     */
    select?: CalendarIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which CalendarIndicator to fetch.
     */
    where: CalendarIndicatorWhereUniqueInput
  }

  /**
   * CalendarIndicator findFirst
   */
  export type CalendarIndicatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarIndicator
     */
    select?: CalendarIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which CalendarIndicator to fetch.
     */
    where?: CalendarIndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarIndicators to fetch.
     */
    orderBy?: CalendarIndicatorOrderByWithRelationInput | CalendarIndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarIndicators.
     */
    cursor?: CalendarIndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarIndicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarIndicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarIndicators.
     */
    distinct?: CalendarIndicatorScalarFieldEnum | CalendarIndicatorScalarFieldEnum[]
  }

  /**
   * CalendarIndicator findFirstOrThrow
   */
  export type CalendarIndicatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarIndicator
     */
    select?: CalendarIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which CalendarIndicator to fetch.
     */
    where?: CalendarIndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarIndicators to fetch.
     */
    orderBy?: CalendarIndicatorOrderByWithRelationInput | CalendarIndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarIndicators.
     */
    cursor?: CalendarIndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarIndicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarIndicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarIndicators.
     */
    distinct?: CalendarIndicatorScalarFieldEnum | CalendarIndicatorScalarFieldEnum[]
  }

  /**
   * CalendarIndicator findMany
   */
  export type CalendarIndicatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarIndicator
     */
    select?: CalendarIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which CalendarIndicators to fetch.
     */
    where?: CalendarIndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarIndicators to fetch.
     */
    orderBy?: CalendarIndicatorOrderByWithRelationInput | CalendarIndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CalendarIndicators.
     */
    cursor?: CalendarIndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarIndicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarIndicators.
     */
    skip?: number
    distinct?: CalendarIndicatorScalarFieldEnum | CalendarIndicatorScalarFieldEnum[]
  }

  /**
   * CalendarIndicator create
   */
  export type CalendarIndicatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarIndicator
     */
    select?: CalendarIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarIndicatorInclude<ExtArgs> | null
    /**
     * The data needed to create a CalendarIndicator.
     */
    data: XOR<CalendarIndicatorCreateInput, CalendarIndicatorUncheckedCreateInput>
  }

  /**
   * CalendarIndicator createMany
   */
  export type CalendarIndicatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CalendarIndicators.
     */
    data: CalendarIndicatorCreateManyInput | CalendarIndicatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalendarIndicator createManyAndReturn
   */
  export type CalendarIndicatorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarIndicator
     */
    select?: CalendarIndicatorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CalendarIndicators.
     */
    data: CalendarIndicatorCreateManyInput | CalendarIndicatorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarIndicatorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CalendarIndicator update
   */
  export type CalendarIndicatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarIndicator
     */
    select?: CalendarIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarIndicatorInclude<ExtArgs> | null
    /**
     * The data needed to update a CalendarIndicator.
     */
    data: XOR<CalendarIndicatorUpdateInput, CalendarIndicatorUncheckedUpdateInput>
    /**
     * Choose, which CalendarIndicator to update.
     */
    where: CalendarIndicatorWhereUniqueInput
  }

  /**
   * CalendarIndicator updateMany
   */
  export type CalendarIndicatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CalendarIndicators.
     */
    data: XOR<CalendarIndicatorUpdateManyMutationInput, CalendarIndicatorUncheckedUpdateManyInput>
    /**
     * Filter which CalendarIndicators to update
     */
    where?: CalendarIndicatorWhereInput
  }

  /**
   * CalendarIndicator upsert
   */
  export type CalendarIndicatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarIndicator
     */
    select?: CalendarIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarIndicatorInclude<ExtArgs> | null
    /**
     * The filter to search for the CalendarIndicator to update in case it exists.
     */
    where: CalendarIndicatorWhereUniqueInput
    /**
     * In case the CalendarIndicator found by the `where` argument doesn't exist, create a new CalendarIndicator with this data.
     */
    create: XOR<CalendarIndicatorCreateInput, CalendarIndicatorUncheckedCreateInput>
    /**
     * In case the CalendarIndicator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarIndicatorUpdateInput, CalendarIndicatorUncheckedUpdateInput>
  }

  /**
   * CalendarIndicator delete
   */
  export type CalendarIndicatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarIndicator
     */
    select?: CalendarIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarIndicatorInclude<ExtArgs> | null
    /**
     * Filter which CalendarIndicator to delete.
     */
    where: CalendarIndicatorWhereUniqueInput
  }

  /**
   * CalendarIndicator deleteMany
   */
  export type CalendarIndicatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarIndicators to delete
     */
    where?: CalendarIndicatorWhereInput
  }

  /**
   * CalendarIndicator without action
   */
  export type CalendarIndicatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarIndicator
     */
    select?: CalendarIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarIndicatorInclude<ExtArgs> | null
  }


  /**
   * Model Stage
   */

  export type AggregateStage = {
    _count: StageCountAggregateOutputType | null
    _avg: StageAvgAggregateOutputType | null
    _sum: StageSumAggregateOutputType | null
    _min: StageMinAggregateOutputType | null
    _max: StageMaxAggregateOutputType | null
  }

  export type StageAvgAggregateOutputType = {
    order: number | null
    startMonth: number | null
    endMonth: number | null
  }

  export type StageSumAggregateOutputType = {
    order: number | null
    startMonth: number | null
    endMonth: number | null
  }

  export type StageMinAggregateOutputType = {
    id: string | null
    calendarId: string | null
    order: number | null
    name: string | null
    description: string | null
    status: $Enums.StageStatus | null
    color: string | null
    startTenDay: $Enums.TenDay | null
    startMonth: number | null
    endTenDay: $Enums.TenDay | null
    endMonth: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StageMaxAggregateOutputType = {
    id: string | null
    calendarId: string | null
    order: number | null
    name: string | null
    description: string | null
    status: $Enums.StageStatus | null
    color: string | null
    startTenDay: $Enums.TenDay | null
    startMonth: number | null
    endTenDay: $Enums.TenDay | null
    endMonth: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StageCountAggregateOutputType = {
    id: number
    calendarId: number
    order: number
    name: number
    description: number
    status: number
    color: number
    startTenDay: number
    startMonth: number
    endTenDay: number
    endMonth: number
    analysis: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StageAvgAggregateInputType = {
    order?: true
    startMonth?: true
    endMonth?: true
  }

  export type StageSumAggregateInputType = {
    order?: true
    startMonth?: true
    endMonth?: true
  }

  export type StageMinAggregateInputType = {
    id?: true
    calendarId?: true
    order?: true
    name?: true
    description?: true
    status?: true
    color?: true
    startTenDay?: true
    startMonth?: true
    endTenDay?: true
    endMonth?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StageMaxAggregateInputType = {
    id?: true
    calendarId?: true
    order?: true
    name?: true
    description?: true
    status?: true
    color?: true
    startTenDay?: true
    startMonth?: true
    endTenDay?: true
    endMonth?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StageCountAggregateInputType = {
    id?: true
    calendarId?: true
    order?: true
    name?: true
    description?: true
    status?: true
    color?: true
    startTenDay?: true
    startMonth?: true
    endTenDay?: true
    endMonth?: true
    analysis?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stage to aggregate.
     */
    where?: StageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stages to fetch.
     */
    orderBy?: StageOrderByWithRelationInput | StageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stages
    **/
    _count?: true | StageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StageMaxAggregateInputType
  }

  export type GetStageAggregateType<T extends StageAggregateArgs> = {
        [P in keyof T & keyof AggregateStage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStage[P]>
      : GetScalarType<T[P], AggregateStage[P]>
  }




  export type StageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StageWhereInput
    orderBy?: StageOrderByWithAggregationInput | StageOrderByWithAggregationInput[]
    by: StageScalarFieldEnum[] | StageScalarFieldEnum
    having?: StageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StageCountAggregateInputType | true
    _avg?: StageAvgAggregateInputType
    _sum?: StageSumAggregateInputType
    _min?: StageMinAggregateInputType
    _max?: StageMaxAggregateInputType
  }

  export type StageGroupByOutputType = {
    id: string
    calendarId: string
    order: number
    name: string
    description: string | null
    status: $Enums.StageStatus
    color: string
    startTenDay: $Enums.TenDay | null
    startMonth: number | null
    endTenDay: $Enums.TenDay | null
    endMonth: number | null
    analysis: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: StageCountAggregateOutputType | null
    _avg: StageAvgAggregateOutputType | null
    _sum: StageSumAggregateOutputType | null
    _min: StageMinAggregateOutputType | null
    _max: StageMaxAggregateOutputType | null
  }

  type GetStageGroupByPayload<T extends StageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StageGroupByOutputType[P]>
            : GetScalarType<T[P], StageGroupByOutputType[P]>
        }
      >
    >


  export type StageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    calendarId?: boolean
    order?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    color?: boolean
    startTenDay?: boolean
    startMonth?: boolean
    endTenDay?: boolean
    endMonth?: boolean
    analysis?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    calendar?: boolean | CalendarDefaultArgs<ExtArgs>
    images?: boolean | Stage$imagesArgs<ExtArgs>
    thresholds?: boolean | Stage$thresholdsArgs<ExtArgs>
    _count?: boolean | StageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stage"]>

  export type StageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    calendarId?: boolean
    order?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    color?: boolean
    startTenDay?: boolean
    startMonth?: boolean
    endTenDay?: boolean
    endMonth?: boolean
    analysis?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    calendar?: boolean | CalendarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stage"]>

  export type StageSelectScalar = {
    id?: boolean
    calendarId?: boolean
    order?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    color?: boolean
    startTenDay?: boolean
    startMonth?: boolean
    endTenDay?: boolean
    endMonth?: boolean
    analysis?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calendar?: boolean | CalendarDefaultArgs<ExtArgs>
    images?: boolean | Stage$imagesArgs<ExtArgs>
    thresholds?: boolean | Stage$thresholdsArgs<ExtArgs>
    _count?: boolean | StageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calendar?: boolean | CalendarDefaultArgs<ExtArgs>
  }

  export type $StagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stage"
    objects: {
      calendar: Prisma.$CalendarPayload<ExtArgs>
      images: Prisma.$StageImagePayload<ExtArgs>[]
      thresholds: Prisma.$StageThresholdPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      calendarId: string
      order: number
      name: string
      description: string | null
      status: $Enums.StageStatus
      color: string
      startTenDay: $Enums.TenDay | null
      startMonth: number | null
      endTenDay: $Enums.TenDay | null
      endMonth: number | null
      analysis: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stage"]>
    composites: {}
  }

  type StageGetPayload<S extends boolean | null | undefined | StageDefaultArgs> = $Result.GetResult<Prisma.$StagePayload, S>

  type StageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StageCountAggregateInputType | true
    }

  export interface StageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stage'], meta: { name: 'Stage' } }
    /**
     * Find zero or one Stage that matches the filter.
     * @param {StageFindUniqueArgs} args - Arguments to find a Stage
     * @example
     * // Get one Stage
     * const stage = await prisma.stage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StageFindUniqueArgs>(args: SelectSubset<T, StageFindUniqueArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Stage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StageFindUniqueOrThrowArgs} args - Arguments to find a Stage
     * @example
     * // Get one Stage
     * const stage = await prisma.stage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StageFindUniqueOrThrowArgs>(args: SelectSubset<T, StageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Stage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageFindFirstArgs} args - Arguments to find a Stage
     * @example
     * // Get one Stage
     * const stage = await prisma.stage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StageFindFirstArgs>(args?: SelectSubset<T, StageFindFirstArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Stage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageFindFirstOrThrowArgs} args - Arguments to find a Stage
     * @example
     * // Get one Stage
     * const stage = await prisma.stage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StageFindFirstOrThrowArgs>(args?: SelectSubset<T, StageFindFirstOrThrowArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Stages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stages
     * const stages = await prisma.stage.findMany()
     * 
     * // Get first 10 Stages
     * const stages = await prisma.stage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stageWithIdOnly = await prisma.stage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StageFindManyArgs>(args?: SelectSubset<T, StageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Stage.
     * @param {StageCreateArgs} args - Arguments to create a Stage.
     * @example
     * // Create one Stage
     * const Stage = await prisma.stage.create({
     *   data: {
     *     // ... data to create a Stage
     *   }
     * })
     * 
     */
    create<T extends StageCreateArgs>(args: SelectSubset<T, StageCreateArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Stages.
     * @param {StageCreateManyArgs} args - Arguments to create many Stages.
     * @example
     * // Create many Stages
     * const stage = await prisma.stage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StageCreateManyArgs>(args?: SelectSubset<T, StageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stages and returns the data saved in the database.
     * @param {StageCreateManyAndReturnArgs} args - Arguments to create many Stages.
     * @example
     * // Create many Stages
     * const stage = await prisma.stage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stages and only return the `id`
     * const stageWithIdOnly = await prisma.stage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StageCreateManyAndReturnArgs>(args?: SelectSubset<T, StageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Stage.
     * @param {StageDeleteArgs} args - Arguments to delete one Stage.
     * @example
     * // Delete one Stage
     * const Stage = await prisma.stage.delete({
     *   where: {
     *     // ... filter to delete one Stage
     *   }
     * })
     * 
     */
    delete<T extends StageDeleteArgs>(args: SelectSubset<T, StageDeleteArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Stage.
     * @param {StageUpdateArgs} args - Arguments to update one Stage.
     * @example
     * // Update one Stage
     * const stage = await prisma.stage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StageUpdateArgs>(args: SelectSubset<T, StageUpdateArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Stages.
     * @param {StageDeleteManyArgs} args - Arguments to filter Stages to delete.
     * @example
     * // Delete a few Stages
     * const { count } = await prisma.stage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StageDeleteManyArgs>(args?: SelectSubset<T, StageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stages
     * const stage = await prisma.stage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StageUpdateManyArgs>(args: SelectSubset<T, StageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Stage.
     * @param {StageUpsertArgs} args - Arguments to update or create a Stage.
     * @example
     * // Update or create a Stage
     * const stage = await prisma.stage.upsert({
     *   create: {
     *     // ... data to create a Stage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stage we want to update
     *   }
     * })
     */
    upsert<T extends StageUpsertArgs>(args: SelectSubset<T, StageUpsertArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Stages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageCountArgs} args - Arguments to filter Stages to count.
     * @example
     * // Count the number of Stages
     * const count = await prisma.stage.count({
     *   where: {
     *     // ... the filter for the Stages we want to count
     *   }
     * })
    **/
    count<T extends StageCountArgs>(
      args?: Subset<T, StageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StageAggregateArgs>(args: Subset<T, StageAggregateArgs>): Prisma.PrismaPromise<GetStageAggregateType<T>>

    /**
     * Group by Stage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StageGroupByArgs['orderBy'] }
        : { orderBy?: StageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stage model
   */
  readonly fields: StageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    calendar<T extends CalendarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CalendarDefaultArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    images<T extends Stage$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Stage$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StageImagePayload<ExtArgs>, T, "findMany"> | Null>
    thresholds<T extends Stage$thresholdsArgs<ExtArgs> = {}>(args?: Subset<T, Stage$thresholdsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StageThresholdPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stage model
   */ 
  interface StageFieldRefs {
    readonly id: FieldRef<"Stage", 'String'>
    readonly calendarId: FieldRef<"Stage", 'String'>
    readonly order: FieldRef<"Stage", 'Int'>
    readonly name: FieldRef<"Stage", 'String'>
    readonly description: FieldRef<"Stage", 'String'>
    readonly status: FieldRef<"Stage", 'StageStatus'>
    readonly color: FieldRef<"Stage", 'String'>
    readonly startTenDay: FieldRef<"Stage", 'TenDay'>
    readonly startMonth: FieldRef<"Stage", 'Int'>
    readonly endTenDay: FieldRef<"Stage", 'TenDay'>
    readonly endMonth: FieldRef<"Stage", 'Int'>
    readonly analysis: FieldRef<"Stage", 'Json'>
    readonly createdAt: FieldRef<"Stage", 'DateTime'>
    readonly updatedAt: FieldRef<"Stage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Stage findUnique
   */
  export type StageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * Filter, which Stage to fetch.
     */
    where: StageWhereUniqueInput
  }

  /**
   * Stage findUniqueOrThrow
   */
  export type StageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * Filter, which Stage to fetch.
     */
    where: StageWhereUniqueInput
  }

  /**
   * Stage findFirst
   */
  export type StageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * Filter, which Stage to fetch.
     */
    where?: StageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stages to fetch.
     */
    orderBy?: StageOrderByWithRelationInput | StageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stages.
     */
    cursor?: StageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stages.
     */
    distinct?: StageScalarFieldEnum | StageScalarFieldEnum[]
  }

  /**
   * Stage findFirstOrThrow
   */
  export type StageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * Filter, which Stage to fetch.
     */
    where?: StageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stages to fetch.
     */
    orderBy?: StageOrderByWithRelationInput | StageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stages.
     */
    cursor?: StageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stages.
     */
    distinct?: StageScalarFieldEnum | StageScalarFieldEnum[]
  }

  /**
   * Stage findMany
   */
  export type StageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * Filter, which Stages to fetch.
     */
    where?: StageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stages to fetch.
     */
    orderBy?: StageOrderByWithRelationInput | StageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stages.
     */
    cursor?: StageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stages.
     */
    skip?: number
    distinct?: StageScalarFieldEnum | StageScalarFieldEnum[]
  }

  /**
   * Stage create
   */
  export type StageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * The data needed to create a Stage.
     */
    data: XOR<StageCreateInput, StageUncheckedCreateInput>
  }

  /**
   * Stage createMany
   */
  export type StageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stages.
     */
    data: StageCreateManyInput | StageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stage createManyAndReturn
   */
  export type StageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Stages.
     */
    data: StageCreateManyInput | StageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stage update
   */
  export type StageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * The data needed to update a Stage.
     */
    data: XOR<StageUpdateInput, StageUncheckedUpdateInput>
    /**
     * Choose, which Stage to update.
     */
    where: StageWhereUniqueInput
  }

  /**
   * Stage updateMany
   */
  export type StageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stages.
     */
    data: XOR<StageUpdateManyMutationInput, StageUncheckedUpdateManyInput>
    /**
     * Filter which Stages to update
     */
    where?: StageWhereInput
  }

  /**
   * Stage upsert
   */
  export type StageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * The filter to search for the Stage to update in case it exists.
     */
    where: StageWhereUniqueInput
    /**
     * In case the Stage found by the `where` argument doesn't exist, create a new Stage with this data.
     */
    create: XOR<StageCreateInput, StageUncheckedCreateInput>
    /**
     * In case the Stage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StageUpdateInput, StageUncheckedUpdateInput>
  }

  /**
   * Stage delete
   */
  export type StageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * Filter which Stage to delete.
     */
    where: StageWhereUniqueInput
  }

  /**
   * Stage deleteMany
   */
  export type StageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stages to delete
     */
    where?: StageWhereInput
  }

  /**
   * Stage.images
   */
  export type Stage$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageImage
     */
    select?: StageImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageImageInclude<ExtArgs> | null
    where?: StageImageWhereInput
    orderBy?: StageImageOrderByWithRelationInput | StageImageOrderByWithRelationInput[]
    cursor?: StageImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StageImageScalarFieldEnum | StageImageScalarFieldEnum[]
  }

  /**
   * Stage.thresholds
   */
  export type Stage$thresholdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageThreshold
     */
    select?: StageThresholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageThresholdInclude<ExtArgs> | null
    where?: StageThresholdWhereInput
    orderBy?: StageThresholdOrderByWithRelationInput | StageThresholdOrderByWithRelationInput[]
    cursor?: StageThresholdWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StageThresholdScalarFieldEnum | StageThresholdScalarFieldEnum[]
  }

  /**
   * Stage without action
   */
  export type StageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
  }


  /**
   * Model StageImage
   */

  export type AggregateStageImage = {
    _count: StageImageCountAggregateOutputType | null
    _avg: StageImageAvgAggregateOutputType | null
    _sum: StageImageSumAggregateOutputType | null
    _min: StageImageMinAggregateOutputType | null
    _max: StageImageMaxAggregateOutputType | null
  }

  export type StageImageAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type StageImageSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type StageImageMinAggregateOutputType = {
    id: string | null
    stageId: string | null
    type: $Enums.StageImageType | null
    url: string | null
    thumbnail: string | null
    name: string | null
    source: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StageImageMaxAggregateOutputType = {
    id: string | null
    stageId: string | null
    type: $Enums.StageImageType | null
    url: string | null
    thumbnail: string | null
    name: string | null
    source: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StageImageCountAggregateOutputType = {
    id: number
    stageId: number
    type: number
    url: number
    thumbnail: number
    name: number
    source: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StageImageAvgAggregateInputType = {
    sortOrder?: true
  }

  export type StageImageSumAggregateInputType = {
    sortOrder?: true
  }

  export type StageImageMinAggregateInputType = {
    id?: true
    stageId?: true
    type?: true
    url?: true
    thumbnail?: true
    name?: true
    source?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StageImageMaxAggregateInputType = {
    id?: true
    stageId?: true
    type?: true
    url?: true
    thumbnail?: true
    name?: true
    source?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StageImageCountAggregateInputType = {
    id?: true
    stageId?: true
    type?: true
    url?: true
    thumbnail?: true
    name?: true
    source?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StageImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StageImage to aggregate.
     */
    where?: StageImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StageImages to fetch.
     */
    orderBy?: StageImageOrderByWithRelationInput | StageImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StageImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StageImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StageImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StageImages
    **/
    _count?: true | StageImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StageImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StageImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StageImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StageImageMaxAggregateInputType
  }

  export type GetStageImageAggregateType<T extends StageImageAggregateArgs> = {
        [P in keyof T & keyof AggregateStageImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStageImage[P]>
      : GetScalarType<T[P], AggregateStageImage[P]>
  }




  export type StageImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StageImageWhereInput
    orderBy?: StageImageOrderByWithAggregationInput | StageImageOrderByWithAggregationInput[]
    by: StageImageScalarFieldEnum[] | StageImageScalarFieldEnum
    having?: StageImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StageImageCountAggregateInputType | true
    _avg?: StageImageAvgAggregateInputType
    _sum?: StageImageSumAggregateInputType
    _min?: StageImageMinAggregateInputType
    _max?: StageImageMaxAggregateInputType
  }

  export type StageImageGroupByOutputType = {
    id: string
    stageId: string
    type: $Enums.StageImageType
    url: string
    thumbnail: string | null
    name: string | null
    source: string | null
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: StageImageCountAggregateOutputType | null
    _avg: StageImageAvgAggregateOutputType | null
    _sum: StageImageSumAggregateOutputType | null
    _min: StageImageMinAggregateOutputType | null
    _max: StageImageMaxAggregateOutputType | null
  }

  type GetStageImageGroupByPayload<T extends StageImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StageImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StageImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StageImageGroupByOutputType[P]>
            : GetScalarType<T[P], StageImageGroupByOutputType[P]>
        }
      >
    >


  export type StageImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stageId?: boolean
    type?: boolean
    url?: boolean
    thumbnail?: boolean
    name?: boolean
    source?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stage?: boolean | StageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stageImage"]>

  export type StageImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stageId?: boolean
    type?: boolean
    url?: boolean
    thumbnail?: boolean
    name?: boolean
    source?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stage?: boolean | StageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stageImage"]>

  export type StageImageSelectScalar = {
    id?: boolean
    stageId?: boolean
    type?: boolean
    url?: boolean
    thumbnail?: boolean
    name?: boolean
    source?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StageImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stage?: boolean | StageDefaultArgs<ExtArgs>
  }
  export type StageImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stage?: boolean | StageDefaultArgs<ExtArgs>
  }

  export type $StageImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StageImage"
    objects: {
      stage: Prisma.$StagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stageId: string
      type: $Enums.StageImageType
      url: string
      thumbnail: string | null
      name: string | null
      source: string | null
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stageImage"]>
    composites: {}
  }

  type StageImageGetPayload<S extends boolean | null | undefined | StageImageDefaultArgs> = $Result.GetResult<Prisma.$StageImagePayload, S>

  type StageImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StageImageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StageImageCountAggregateInputType | true
    }

  export interface StageImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StageImage'], meta: { name: 'StageImage' } }
    /**
     * Find zero or one StageImage that matches the filter.
     * @param {StageImageFindUniqueArgs} args - Arguments to find a StageImage
     * @example
     * // Get one StageImage
     * const stageImage = await prisma.stageImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StageImageFindUniqueArgs>(args: SelectSubset<T, StageImageFindUniqueArgs<ExtArgs>>): Prisma__StageImageClient<$Result.GetResult<Prisma.$StageImagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StageImage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StageImageFindUniqueOrThrowArgs} args - Arguments to find a StageImage
     * @example
     * // Get one StageImage
     * const stageImage = await prisma.stageImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StageImageFindUniqueOrThrowArgs>(args: SelectSubset<T, StageImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StageImageClient<$Result.GetResult<Prisma.$StageImagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StageImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageImageFindFirstArgs} args - Arguments to find a StageImage
     * @example
     * // Get one StageImage
     * const stageImage = await prisma.stageImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StageImageFindFirstArgs>(args?: SelectSubset<T, StageImageFindFirstArgs<ExtArgs>>): Prisma__StageImageClient<$Result.GetResult<Prisma.$StageImagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StageImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageImageFindFirstOrThrowArgs} args - Arguments to find a StageImage
     * @example
     * // Get one StageImage
     * const stageImage = await prisma.stageImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StageImageFindFirstOrThrowArgs>(args?: SelectSubset<T, StageImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__StageImageClient<$Result.GetResult<Prisma.$StageImagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StageImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StageImages
     * const stageImages = await prisma.stageImage.findMany()
     * 
     * // Get first 10 StageImages
     * const stageImages = await prisma.stageImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stageImageWithIdOnly = await prisma.stageImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StageImageFindManyArgs>(args?: SelectSubset<T, StageImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StageImagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StageImage.
     * @param {StageImageCreateArgs} args - Arguments to create a StageImage.
     * @example
     * // Create one StageImage
     * const StageImage = await prisma.stageImage.create({
     *   data: {
     *     // ... data to create a StageImage
     *   }
     * })
     * 
     */
    create<T extends StageImageCreateArgs>(args: SelectSubset<T, StageImageCreateArgs<ExtArgs>>): Prisma__StageImageClient<$Result.GetResult<Prisma.$StageImagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StageImages.
     * @param {StageImageCreateManyArgs} args - Arguments to create many StageImages.
     * @example
     * // Create many StageImages
     * const stageImage = await prisma.stageImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StageImageCreateManyArgs>(args?: SelectSubset<T, StageImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StageImages and returns the data saved in the database.
     * @param {StageImageCreateManyAndReturnArgs} args - Arguments to create many StageImages.
     * @example
     * // Create many StageImages
     * const stageImage = await prisma.stageImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StageImages and only return the `id`
     * const stageImageWithIdOnly = await prisma.stageImage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StageImageCreateManyAndReturnArgs>(args?: SelectSubset<T, StageImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StageImagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StageImage.
     * @param {StageImageDeleteArgs} args - Arguments to delete one StageImage.
     * @example
     * // Delete one StageImage
     * const StageImage = await prisma.stageImage.delete({
     *   where: {
     *     // ... filter to delete one StageImage
     *   }
     * })
     * 
     */
    delete<T extends StageImageDeleteArgs>(args: SelectSubset<T, StageImageDeleteArgs<ExtArgs>>): Prisma__StageImageClient<$Result.GetResult<Prisma.$StageImagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StageImage.
     * @param {StageImageUpdateArgs} args - Arguments to update one StageImage.
     * @example
     * // Update one StageImage
     * const stageImage = await prisma.stageImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StageImageUpdateArgs>(args: SelectSubset<T, StageImageUpdateArgs<ExtArgs>>): Prisma__StageImageClient<$Result.GetResult<Prisma.$StageImagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StageImages.
     * @param {StageImageDeleteManyArgs} args - Arguments to filter StageImages to delete.
     * @example
     * // Delete a few StageImages
     * const { count } = await prisma.stageImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StageImageDeleteManyArgs>(args?: SelectSubset<T, StageImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StageImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StageImages
     * const stageImage = await prisma.stageImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StageImageUpdateManyArgs>(args: SelectSubset<T, StageImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StageImage.
     * @param {StageImageUpsertArgs} args - Arguments to update or create a StageImage.
     * @example
     * // Update or create a StageImage
     * const stageImage = await prisma.stageImage.upsert({
     *   create: {
     *     // ... data to create a StageImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StageImage we want to update
     *   }
     * })
     */
    upsert<T extends StageImageUpsertArgs>(args: SelectSubset<T, StageImageUpsertArgs<ExtArgs>>): Prisma__StageImageClient<$Result.GetResult<Prisma.$StageImagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StageImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageImageCountArgs} args - Arguments to filter StageImages to count.
     * @example
     * // Count the number of StageImages
     * const count = await prisma.stageImage.count({
     *   where: {
     *     // ... the filter for the StageImages we want to count
     *   }
     * })
    **/
    count<T extends StageImageCountArgs>(
      args?: Subset<T, StageImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StageImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StageImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StageImageAggregateArgs>(args: Subset<T, StageImageAggregateArgs>): Prisma.PrismaPromise<GetStageImageAggregateType<T>>

    /**
     * Group by StageImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StageImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StageImageGroupByArgs['orderBy'] }
        : { orderBy?: StageImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StageImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStageImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StageImage model
   */
  readonly fields: StageImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StageImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StageImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stage<T extends StageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StageDefaultArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StageImage model
   */ 
  interface StageImageFieldRefs {
    readonly id: FieldRef<"StageImage", 'String'>
    readonly stageId: FieldRef<"StageImage", 'String'>
    readonly type: FieldRef<"StageImage", 'StageImageType'>
    readonly url: FieldRef<"StageImage", 'String'>
    readonly thumbnail: FieldRef<"StageImage", 'String'>
    readonly name: FieldRef<"StageImage", 'String'>
    readonly source: FieldRef<"StageImage", 'String'>
    readonly sortOrder: FieldRef<"StageImage", 'Int'>
    readonly createdAt: FieldRef<"StageImage", 'DateTime'>
    readonly updatedAt: FieldRef<"StageImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StageImage findUnique
   */
  export type StageImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageImage
     */
    select?: StageImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageImageInclude<ExtArgs> | null
    /**
     * Filter, which StageImage to fetch.
     */
    where: StageImageWhereUniqueInput
  }

  /**
   * StageImage findUniqueOrThrow
   */
  export type StageImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageImage
     */
    select?: StageImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageImageInclude<ExtArgs> | null
    /**
     * Filter, which StageImage to fetch.
     */
    where: StageImageWhereUniqueInput
  }

  /**
   * StageImage findFirst
   */
  export type StageImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageImage
     */
    select?: StageImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageImageInclude<ExtArgs> | null
    /**
     * Filter, which StageImage to fetch.
     */
    where?: StageImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StageImages to fetch.
     */
    orderBy?: StageImageOrderByWithRelationInput | StageImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StageImages.
     */
    cursor?: StageImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StageImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StageImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StageImages.
     */
    distinct?: StageImageScalarFieldEnum | StageImageScalarFieldEnum[]
  }

  /**
   * StageImage findFirstOrThrow
   */
  export type StageImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageImage
     */
    select?: StageImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageImageInclude<ExtArgs> | null
    /**
     * Filter, which StageImage to fetch.
     */
    where?: StageImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StageImages to fetch.
     */
    orderBy?: StageImageOrderByWithRelationInput | StageImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StageImages.
     */
    cursor?: StageImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StageImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StageImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StageImages.
     */
    distinct?: StageImageScalarFieldEnum | StageImageScalarFieldEnum[]
  }

  /**
   * StageImage findMany
   */
  export type StageImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageImage
     */
    select?: StageImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageImageInclude<ExtArgs> | null
    /**
     * Filter, which StageImages to fetch.
     */
    where?: StageImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StageImages to fetch.
     */
    orderBy?: StageImageOrderByWithRelationInput | StageImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StageImages.
     */
    cursor?: StageImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StageImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StageImages.
     */
    skip?: number
    distinct?: StageImageScalarFieldEnum | StageImageScalarFieldEnum[]
  }

  /**
   * StageImage create
   */
  export type StageImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageImage
     */
    select?: StageImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageImageInclude<ExtArgs> | null
    /**
     * The data needed to create a StageImage.
     */
    data: XOR<StageImageCreateInput, StageImageUncheckedCreateInput>
  }

  /**
   * StageImage createMany
   */
  export type StageImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StageImages.
     */
    data: StageImageCreateManyInput | StageImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StageImage createManyAndReturn
   */
  export type StageImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageImage
     */
    select?: StageImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StageImages.
     */
    data: StageImageCreateManyInput | StageImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StageImage update
   */
  export type StageImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageImage
     */
    select?: StageImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageImageInclude<ExtArgs> | null
    /**
     * The data needed to update a StageImage.
     */
    data: XOR<StageImageUpdateInput, StageImageUncheckedUpdateInput>
    /**
     * Choose, which StageImage to update.
     */
    where: StageImageWhereUniqueInput
  }

  /**
   * StageImage updateMany
   */
  export type StageImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StageImages.
     */
    data: XOR<StageImageUpdateManyMutationInput, StageImageUncheckedUpdateManyInput>
    /**
     * Filter which StageImages to update
     */
    where?: StageImageWhereInput
  }

  /**
   * StageImage upsert
   */
  export type StageImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageImage
     */
    select?: StageImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageImageInclude<ExtArgs> | null
    /**
     * The filter to search for the StageImage to update in case it exists.
     */
    where: StageImageWhereUniqueInput
    /**
     * In case the StageImage found by the `where` argument doesn't exist, create a new StageImage with this data.
     */
    create: XOR<StageImageCreateInput, StageImageUncheckedCreateInput>
    /**
     * In case the StageImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StageImageUpdateInput, StageImageUncheckedUpdateInput>
  }

  /**
   * StageImage delete
   */
  export type StageImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageImage
     */
    select?: StageImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageImageInclude<ExtArgs> | null
    /**
     * Filter which StageImage to delete.
     */
    where: StageImageWhereUniqueInput
  }

  /**
   * StageImage deleteMany
   */
  export type StageImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StageImages to delete
     */
    where?: StageImageWhereInput
  }

  /**
   * StageImage without action
   */
  export type StageImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageImage
     */
    select?: StageImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageImageInclude<ExtArgs> | null
  }


  /**
   * Model StageThreshold
   */

  export type AggregateStageThreshold = {
    _count: StageThresholdCountAggregateOutputType | null
    _avg: StageThresholdAvgAggregateOutputType | null
    _sum: StageThresholdSumAggregateOutputType | null
    _min: StageThresholdMinAggregateOutputType | null
    _max: StageThresholdMaxAggregateOutputType | null
  }

  export type StageThresholdAvgAggregateOutputType = {
    value: number | null
    durationDays: number | null
  }

  export type StageThresholdSumAggregateOutputType = {
    value: number | null
    durationDays: number | null
  }

  export type StageThresholdMinAggregateOutputType = {
    id: string | null
    stageId: string | null
    indicatorId: string | null
    operator: $Enums.ThresholdOperator | null
    value: number | null
    unit: string | null
    durationDays: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StageThresholdMaxAggregateOutputType = {
    id: string | null
    stageId: string | null
    indicatorId: string | null
    operator: $Enums.ThresholdOperator | null
    value: number | null
    unit: string | null
    durationDays: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StageThresholdCountAggregateOutputType = {
    id: number
    stageId: number
    indicatorId: number
    operator: number
    value: number
    unit: number
    durationDays: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StageThresholdAvgAggregateInputType = {
    value?: true
    durationDays?: true
  }

  export type StageThresholdSumAggregateInputType = {
    value?: true
    durationDays?: true
  }

  export type StageThresholdMinAggregateInputType = {
    id?: true
    stageId?: true
    indicatorId?: true
    operator?: true
    value?: true
    unit?: true
    durationDays?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StageThresholdMaxAggregateInputType = {
    id?: true
    stageId?: true
    indicatorId?: true
    operator?: true
    value?: true
    unit?: true
    durationDays?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StageThresholdCountAggregateInputType = {
    id?: true
    stageId?: true
    indicatorId?: true
    operator?: true
    value?: true
    unit?: true
    durationDays?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StageThresholdAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StageThreshold to aggregate.
     */
    where?: StageThresholdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StageThresholds to fetch.
     */
    orderBy?: StageThresholdOrderByWithRelationInput | StageThresholdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StageThresholdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StageThresholds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StageThresholds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StageThresholds
    **/
    _count?: true | StageThresholdCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StageThresholdAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StageThresholdSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StageThresholdMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StageThresholdMaxAggregateInputType
  }

  export type GetStageThresholdAggregateType<T extends StageThresholdAggregateArgs> = {
        [P in keyof T & keyof AggregateStageThreshold]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStageThreshold[P]>
      : GetScalarType<T[P], AggregateStageThreshold[P]>
  }




  export type StageThresholdGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StageThresholdWhereInput
    orderBy?: StageThresholdOrderByWithAggregationInput | StageThresholdOrderByWithAggregationInput[]
    by: StageThresholdScalarFieldEnum[] | StageThresholdScalarFieldEnum
    having?: StageThresholdScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StageThresholdCountAggregateInputType | true
    _avg?: StageThresholdAvgAggregateInputType
    _sum?: StageThresholdSumAggregateInputType
    _min?: StageThresholdMinAggregateInputType
    _max?: StageThresholdMaxAggregateInputType
  }

  export type StageThresholdGroupByOutputType = {
    id: string
    stageId: string
    indicatorId: string
    operator: $Enums.ThresholdOperator
    value: number
    unit: string | null
    durationDays: number
    createdAt: Date
    updatedAt: Date
    _count: StageThresholdCountAggregateOutputType | null
    _avg: StageThresholdAvgAggregateOutputType | null
    _sum: StageThresholdSumAggregateOutputType | null
    _min: StageThresholdMinAggregateOutputType | null
    _max: StageThresholdMaxAggregateOutputType | null
  }

  type GetStageThresholdGroupByPayload<T extends StageThresholdGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StageThresholdGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StageThresholdGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StageThresholdGroupByOutputType[P]>
            : GetScalarType<T[P], StageThresholdGroupByOutputType[P]>
        }
      >
    >


  export type StageThresholdSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stageId?: boolean
    indicatorId?: boolean
    operator?: boolean
    value?: boolean
    unit?: boolean
    durationDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stage?: boolean | StageDefaultArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stageThreshold"]>

  export type StageThresholdSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stageId?: boolean
    indicatorId?: boolean
    operator?: boolean
    value?: boolean
    unit?: boolean
    durationDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stage?: boolean | StageDefaultArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stageThreshold"]>

  export type StageThresholdSelectScalar = {
    id?: boolean
    stageId?: boolean
    indicatorId?: boolean
    operator?: boolean
    value?: boolean
    unit?: boolean
    durationDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StageThresholdInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stage?: boolean | StageDefaultArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
  }
  export type StageThresholdIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stage?: boolean | StageDefaultArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
  }

  export type $StageThresholdPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StageThreshold"
    objects: {
      stage: Prisma.$StagePayload<ExtArgs>
      indicator: Prisma.$IndicatorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stageId: string
      indicatorId: string
      operator: $Enums.ThresholdOperator
      value: number
      unit: string | null
      durationDays: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stageThreshold"]>
    composites: {}
  }

  type StageThresholdGetPayload<S extends boolean | null | undefined | StageThresholdDefaultArgs> = $Result.GetResult<Prisma.$StageThresholdPayload, S>

  type StageThresholdCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StageThresholdFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StageThresholdCountAggregateInputType | true
    }

  export interface StageThresholdDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StageThreshold'], meta: { name: 'StageThreshold' } }
    /**
     * Find zero or one StageThreshold that matches the filter.
     * @param {StageThresholdFindUniqueArgs} args - Arguments to find a StageThreshold
     * @example
     * // Get one StageThreshold
     * const stageThreshold = await prisma.stageThreshold.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StageThresholdFindUniqueArgs>(args: SelectSubset<T, StageThresholdFindUniqueArgs<ExtArgs>>): Prisma__StageThresholdClient<$Result.GetResult<Prisma.$StageThresholdPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StageThreshold that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StageThresholdFindUniqueOrThrowArgs} args - Arguments to find a StageThreshold
     * @example
     * // Get one StageThreshold
     * const stageThreshold = await prisma.stageThreshold.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StageThresholdFindUniqueOrThrowArgs>(args: SelectSubset<T, StageThresholdFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StageThresholdClient<$Result.GetResult<Prisma.$StageThresholdPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StageThreshold that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageThresholdFindFirstArgs} args - Arguments to find a StageThreshold
     * @example
     * // Get one StageThreshold
     * const stageThreshold = await prisma.stageThreshold.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StageThresholdFindFirstArgs>(args?: SelectSubset<T, StageThresholdFindFirstArgs<ExtArgs>>): Prisma__StageThresholdClient<$Result.GetResult<Prisma.$StageThresholdPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StageThreshold that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageThresholdFindFirstOrThrowArgs} args - Arguments to find a StageThreshold
     * @example
     * // Get one StageThreshold
     * const stageThreshold = await prisma.stageThreshold.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StageThresholdFindFirstOrThrowArgs>(args?: SelectSubset<T, StageThresholdFindFirstOrThrowArgs<ExtArgs>>): Prisma__StageThresholdClient<$Result.GetResult<Prisma.$StageThresholdPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StageThresholds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageThresholdFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StageThresholds
     * const stageThresholds = await prisma.stageThreshold.findMany()
     * 
     * // Get first 10 StageThresholds
     * const stageThresholds = await prisma.stageThreshold.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stageThresholdWithIdOnly = await prisma.stageThreshold.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StageThresholdFindManyArgs>(args?: SelectSubset<T, StageThresholdFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StageThresholdPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StageThreshold.
     * @param {StageThresholdCreateArgs} args - Arguments to create a StageThreshold.
     * @example
     * // Create one StageThreshold
     * const StageThreshold = await prisma.stageThreshold.create({
     *   data: {
     *     // ... data to create a StageThreshold
     *   }
     * })
     * 
     */
    create<T extends StageThresholdCreateArgs>(args: SelectSubset<T, StageThresholdCreateArgs<ExtArgs>>): Prisma__StageThresholdClient<$Result.GetResult<Prisma.$StageThresholdPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StageThresholds.
     * @param {StageThresholdCreateManyArgs} args - Arguments to create many StageThresholds.
     * @example
     * // Create many StageThresholds
     * const stageThreshold = await prisma.stageThreshold.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StageThresholdCreateManyArgs>(args?: SelectSubset<T, StageThresholdCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StageThresholds and returns the data saved in the database.
     * @param {StageThresholdCreateManyAndReturnArgs} args - Arguments to create many StageThresholds.
     * @example
     * // Create many StageThresholds
     * const stageThreshold = await prisma.stageThreshold.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StageThresholds and only return the `id`
     * const stageThresholdWithIdOnly = await prisma.stageThreshold.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StageThresholdCreateManyAndReturnArgs>(args?: SelectSubset<T, StageThresholdCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StageThresholdPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StageThreshold.
     * @param {StageThresholdDeleteArgs} args - Arguments to delete one StageThreshold.
     * @example
     * // Delete one StageThreshold
     * const StageThreshold = await prisma.stageThreshold.delete({
     *   where: {
     *     // ... filter to delete one StageThreshold
     *   }
     * })
     * 
     */
    delete<T extends StageThresholdDeleteArgs>(args: SelectSubset<T, StageThresholdDeleteArgs<ExtArgs>>): Prisma__StageThresholdClient<$Result.GetResult<Prisma.$StageThresholdPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StageThreshold.
     * @param {StageThresholdUpdateArgs} args - Arguments to update one StageThreshold.
     * @example
     * // Update one StageThreshold
     * const stageThreshold = await prisma.stageThreshold.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StageThresholdUpdateArgs>(args: SelectSubset<T, StageThresholdUpdateArgs<ExtArgs>>): Prisma__StageThresholdClient<$Result.GetResult<Prisma.$StageThresholdPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StageThresholds.
     * @param {StageThresholdDeleteManyArgs} args - Arguments to filter StageThresholds to delete.
     * @example
     * // Delete a few StageThresholds
     * const { count } = await prisma.stageThreshold.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StageThresholdDeleteManyArgs>(args?: SelectSubset<T, StageThresholdDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StageThresholds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageThresholdUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StageThresholds
     * const stageThreshold = await prisma.stageThreshold.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StageThresholdUpdateManyArgs>(args: SelectSubset<T, StageThresholdUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StageThreshold.
     * @param {StageThresholdUpsertArgs} args - Arguments to update or create a StageThreshold.
     * @example
     * // Update or create a StageThreshold
     * const stageThreshold = await prisma.stageThreshold.upsert({
     *   create: {
     *     // ... data to create a StageThreshold
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StageThreshold we want to update
     *   }
     * })
     */
    upsert<T extends StageThresholdUpsertArgs>(args: SelectSubset<T, StageThresholdUpsertArgs<ExtArgs>>): Prisma__StageThresholdClient<$Result.GetResult<Prisma.$StageThresholdPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StageThresholds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageThresholdCountArgs} args - Arguments to filter StageThresholds to count.
     * @example
     * // Count the number of StageThresholds
     * const count = await prisma.stageThreshold.count({
     *   where: {
     *     // ... the filter for the StageThresholds we want to count
     *   }
     * })
    **/
    count<T extends StageThresholdCountArgs>(
      args?: Subset<T, StageThresholdCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StageThresholdCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StageThreshold.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageThresholdAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StageThresholdAggregateArgs>(args: Subset<T, StageThresholdAggregateArgs>): Prisma.PrismaPromise<GetStageThresholdAggregateType<T>>

    /**
     * Group by StageThreshold.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageThresholdGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StageThresholdGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StageThresholdGroupByArgs['orderBy'] }
        : { orderBy?: StageThresholdGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StageThresholdGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStageThresholdGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StageThreshold model
   */
  readonly fields: StageThresholdFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StageThreshold.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StageThresholdClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stage<T extends StageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StageDefaultArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    indicator<T extends IndicatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IndicatorDefaultArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StageThreshold model
   */ 
  interface StageThresholdFieldRefs {
    readonly id: FieldRef<"StageThreshold", 'String'>
    readonly stageId: FieldRef<"StageThreshold", 'String'>
    readonly indicatorId: FieldRef<"StageThreshold", 'String'>
    readonly operator: FieldRef<"StageThreshold", 'ThresholdOperator'>
    readonly value: FieldRef<"StageThreshold", 'Float'>
    readonly unit: FieldRef<"StageThreshold", 'String'>
    readonly durationDays: FieldRef<"StageThreshold", 'Int'>
    readonly createdAt: FieldRef<"StageThreshold", 'DateTime'>
    readonly updatedAt: FieldRef<"StageThreshold", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StageThreshold findUnique
   */
  export type StageThresholdFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageThreshold
     */
    select?: StageThresholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageThresholdInclude<ExtArgs> | null
    /**
     * Filter, which StageThreshold to fetch.
     */
    where: StageThresholdWhereUniqueInput
  }

  /**
   * StageThreshold findUniqueOrThrow
   */
  export type StageThresholdFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageThreshold
     */
    select?: StageThresholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageThresholdInclude<ExtArgs> | null
    /**
     * Filter, which StageThreshold to fetch.
     */
    where: StageThresholdWhereUniqueInput
  }

  /**
   * StageThreshold findFirst
   */
  export type StageThresholdFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageThreshold
     */
    select?: StageThresholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageThresholdInclude<ExtArgs> | null
    /**
     * Filter, which StageThreshold to fetch.
     */
    where?: StageThresholdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StageThresholds to fetch.
     */
    orderBy?: StageThresholdOrderByWithRelationInput | StageThresholdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StageThresholds.
     */
    cursor?: StageThresholdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StageThresholds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StageThresholds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StageThresholds.
     */
    distinct?: StageThresholdScalarFieldEnum | StageThresholdScalarFieldEnum[]
  }

  /**
   * StageThreshold findFirstOrThrow
   */
  export type StageThresholdFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageThreshold
     */
    select?: StageThresholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageThresholdInclude<ExtArgs> | null
    /**
     * Filter, which StageThreshold to fetch.
     */
    where?: StageThresholdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StageThresholds to fetch.
     */
    orderBy?: StageThresholdOrderByWithRelationInput | StageThresholdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StageThresholds.
     */
    cursor?: StageThresholdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StageThresholds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StageThresholds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StageThresholds.
     */
    distinct?: StageThresholdScalarFieldEnum | StageThresholdScalarFieldEnum[]
  }

  /**
   * StageThreshold findMany
   */
  export type StageThresholdFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageThreshold
     */
    select?: StageThresholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageThresholdInclude<ExtArgs> | null
    /**
     * Filter, which StageThresholds to fetch.
     */
    where?: StageThresholdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StageThresholds to fetch.
     */
    orderBy?: StageThresholdOrderByWithRelationInput | StageThresholdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StageThresholds.
     */
    cursor?: StageThresholdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StageThresholds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StageThresholds.
     */
    skip?: number
    distinct?: StageThresholdScalarFieldEnum | StageThresholdScalarFieldEnum[]
  }

  /**
   * StageThreshold create
   */
  export type StageThresholdCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageThreshold
     */
    select?: StageThresholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageThresholdInclude<ExtArgs> | null
    /**
     * The data needed to create a StageThreshold.
     */
    data: XOR<StageThresholdCreateInput, StageThresholdUncheckedCreateInput>
  }

  /**
   * StageThreshold createMany
   */
  export type StageThresholdCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StageThresholds.
     */
    data: StageThresholdCreateManyInput | StageThresholdCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StageThreshold createManyAndReturn
   */
  export type StageThresholdCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageThreshold
     */
    select?: StageThresholdSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StageThresholds.
     */
    data: StageThresholdCreateManyInput | StageThresholdCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageThresholdIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StageThreshold update
   */
  export type StageThresholdUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageThreshold
     */
    select?: StageThresholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageThresholdInclude<ExtArgs> | null
    /**
     * The data needed to update a StageThreshold.
     */
    data: XOR<StageThresholdUpdateInput, StageThresholdUncheckedUpdateInput>
    /**
     * Choose, which StageThreshold to update.
     */
    where: StageThresholdWhereUniqueInput
  }

  /**
   * StageThreshold updateMany
   */
  export type StageThresholdUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StageThresholds.
     */
    data: XOR<StageThresholdUpdateManyMutationInput, StageThresholdUncheckedUpdateManyInput>
    /**
     * Filter which StageThresholds to update
     */
    where?: StageThresholdWhereInput
  }

  /**
   * StageThreshold upsert
   */
  export type StageThresholdUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageThreshold
     */
    select?: StageThresholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageThresholdInclude<ExtArgs> | null
    /**
     * The filter to search for the StageThreshold to update in case it exists.
     */
    where: StageThresholdWhereUniqueInput
    /**
     * In case the StageThreshold found by the `where` argument doesn't exist, create a new StageThreshold with this data.
     */
    create: XOR<StageThresholdCreateInput, StageThresholdUncheckedCreateInput>
    /**
     * In case the StageThreshold was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StageThresholdUpdateInput, StageThresholdUncheckedUpdateInput>
  }

  /**
   * StageThreshold delete
   */
  export type StageThresholdDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageThreshold
     */
    select?: StageThresholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageThresholdInclude<ExtArgs> | null
    /**
     * Filter which StageThreshold to delete.
     */
    where: StageThresholdWhereUniqueInput
  }

  /**
   * StageThreshold deleteMany
   */
  export type StageThresholdDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StageThresholds to delete
     */
    where?: StageThresholdWhereInput
  }

  /**
   * StageThreshold without action
   */
  export type StageThresholdDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageThreshold
     */
    select?: StageThresholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageThresholdInclude<ExtArgs> | null
  }


  /**
   * Model Gwl
   */

  export type AggregateGwl = {
    _count: GwlCountAggregateOutputType | null
    _avg: GwlAvgAggregateOutputType | null
    _sum: GwlSumAggregateOutputType | null
    _min: GwlMinAggregateOutputType | null
    _max: GwlMaxAggregateOutputType | null
  }

  export type GwlAvgAggregateOutputType = {
    id: number | null
  }

  export type GwlSumAggregateOutputType = {
    id: number | null
  }

  export type GwlMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GwlMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GwlCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GwlAvgAggregateInputType = {
    id?: true
  }

  export type GwlSumAggregateInputType = {
    id?: true
  }

  export type GwlMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GwlMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GwlCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GwlAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gwl to aggregate.
     */
    where?: GwlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gwls to fetch.
     */
    orderBy?: GwlOrderByWithRelationInput | GwlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GwlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gwls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gwls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gwls
    **/
    _count?: true | GwlCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GwlAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GwlSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GwlMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GwlMaxAggregateInputType
  }

  export type GetGwlAggregateType<T extends GwlAggregateArgs> = {
        [P in keyof T & keyof AggregateGwl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGwl[P]>
      : GetScalarType<T[P], AggregateGwl[P]>
  }




  export type GwlGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GwlWhereInput
    orderBy?: GwlOrderByWithAggregationInput | GwlOrderByWithAggregationInput[]
    by: GwlScalarFieldEnum[] | GwlScalarFieldEnum
    having?: GwlScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GwlCountAggregateInputType | true
    _avg?: GwlAvgAggregateInputType
    _sum?: GwlSumAggregateInputType
    _min?: GwlMinAggregateInputType
    _max?: GwlMaxAggregateInputType
  }

  export type GwlGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: GwlCountAggregateOutputType | null
    _avg: GwlAvgAggregateOutputType | null
    _sum: GwlSumAggregateOutputType | null
    _min: GwlMinAggregateOutputType | null
    _max: GwlMaxAggregateOutputType | null
  }

  type GetGwlGroupByPayload<T extends GwlGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GwlGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GwlGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GwlGroupByOutputType[P]>
            : GetScalarType<T[P], GwlGroupByOutputType[P]>
        }
      >
    >


  export type GwlSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["gwl"]>

  export type GwlSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["gwl"]>

  export type GwlSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $GwlPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Gwl"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gwl"]>
    composites: {}
  }

  type GwlGetPayload<S extends boolean | null | undefined | GwlDefaultArgs> = $Result.GetResult<Prisma.$GwlPayload, S>

  type GwlCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GwlFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GwlCountAggregateInputType | true
    }

  export interface GwlDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Gwl'], meta: { name: 'Gwl' } }
    /**
     * Find zero or one Gwl that matches the filter.
     * @param {GwlFindUniqueArgs} args - Arguments to find a Gwl
     * @example
     * // Get one Gwl
     * const gwl = await prisma.gwl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GwlFindUniqueArgs>(args: SelectSubset<T, GwlFindUniqueArgs<ExtArgs>>): Prisma__GwlClient<$Result.GetResult<Prisma.$GwlPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Gwl that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GwlFindUniqueOrThrowArgs} args - Arguments to find a Gwl
     * @example
     * // Get one Gwl
     * const gwl = await prisma.gwl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GwlFindUniqueOrThrowArgs>(args: SelectSubset<T, GwlFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GwlClient<$Result.GetResult<Prisma.$GwlPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Gwl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GwlFindFirstArgs} args - Arguments to find a Gwl
     * @example
     * // Get one Gwl
     * const gwl = await prisma.gwl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GwlFindFirstArgs>(args?: SelectSubset<T, GwlFindFirstArgs<ExtArgs>>): Prisma__GwlClient<$Result.GetResult<Prisma.$GwlPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Gwl that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GwlFindFirstOrThrowArgs} args - Arguments to find a Gwl
     * @example
     * // Get one Gwl
     * const gwl = await prisma.gwl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GwlFindFirstOrThrowArgs>(args?: SelectSubset<T, GwlFindFirstOrThrowArgs<ExtArgs>>): Prisma__GwlClient<$Result.GetResult<Prisma.$GwlPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Gwls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GwlFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gwls
     * const gwls = await prisma.gwl.findMany()
     * 
     * // Get first 10 Gwls
     * const gwls = await prisma.gwl.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gwlWithIdOnly = await prisma.gwl.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GwlFindManyArgs>(args?: SelectSubset<T, GwlFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GwlPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Gwl.
     * @param {GwlCreateArgs} args - Arguments to create a Gwl.
     * @example
     * // Create one Gwl
     * const Gwl = await prisma.gwl.create({
     *   data: {
     *     // ... data to create a Gwl
     *   }
     * })
     * 
     */
    create<T extends GwlCreateArgs>(args: SelectSubset<T, GwlCreateArgs<ExtArgs>>): Prisma__GwlClient<$Result.GetResult<Prisma.$GwlPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Gwls.
     * @param {GwlCreateManyArgs} args - Arguments to create many Gwls.
     * @example
     * // Create many Gwls
     * const gwl = await prisma.gwl.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GwlCreateManyArgs>(args?: SelectSubset<T, GwlCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Gwls and returns the data saved in the database.
     * @param {GwlCreateManyAndReturnArgs} args - Arguments to create many Gwls.
     * @example
     * // Create many Gwls
     * const gwl = await prisma.gwl.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Gwls and only return the `id`
     * const gwlWithIdOnly = await prisma.gwl.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GwlCreateManyAndReturnArgs>(args?: SelectSubset<T, GwlCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GwlPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Gwl.
     * @param {GwlDeleteArgs} args - Arguments to delete one Gwl.
     * @example
     * // Delete one Gwl
     * const Gwl = await prisma.gwl.delete({
     *   where: {
     *     // ... filter to delete one Gwl
     *   }
     * })
     * 
     */
    delete<T extends GwlDeleteArgs>(args: SelectSubset<T, GwlDeleteArgs<ExtArgs>>): Prisma__GwlClient<$Result.GetResult<Prisma.$GwlPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Gwl.
     * @param {GwlUpdateArgs} args - Arguments to update one Gwl.
     * @example
     * // Update one Gwl
     * const gwl = await prisma.gwl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GwlUpdateArgs>(args: SelectSubset<T, GwlUpdateArgs<ExtArgs>>): Prisma__GwlClient<$Result.GetResult<Prisma.$GwlPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Gwls.
     * @param {GwlDeleteManyArgs} args - Arguments to filter Gwls to delete.
     * @example
     * // Delete a few Gwls
     * const { count } = await prisma.gwl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GwlDeleteManyArgs>(args?: SelectSubset<T, GwlDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gwls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GwlUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gwls
     * const gwl = await prisma.gwl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GwlUpdateManyArgs>(args: SelectSubset<T, GwlUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gwl.
     * @param {GwlUpsertArgs} args - Arguments to update or create a Gwl.
     * @example
     * // Update or create a Gwl
     * const gwl = await prisma.gwl.upsert({
     *   create: {
     *     // ... data to create a Gwl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gwl we want to update
     *   }
     * })
     */
    upsert<T extends GwlUpsertArgs>(args: SelectSubset<T, GwlUpsertArgs<ExtArgs>>): Prisma__GwlClient<$Result.GetResult<Prisma.$GwlPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Gwls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GwlCountArgs} args - Arguments to filter Gwls to count.
     * @example
     * // Count the number of Gwls
     * const count = await prisma.gwl.count({
     *   where: {
     *     // ... the filter for the Gwls we want to count
     *   }
     * })
    **/
    count<T extends GwlCountArgs>(
      args?: Subset<T, GwlCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GwlCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gwl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GwlAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GwlAggregateArgs>(args: Subset<T, GwlAggregateArgs>): Prisma.PrismaPromise<GetGwlAggregateType<T>>

    /**
     * Group by Gwl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GwlGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GwlGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GwlGroupByArgs['orderBy'] }
        : { orderBy?: GwlGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GwlGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGwlGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Gwl model
   */
  readonly fields: GwlFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Gwl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GwlClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Gwl model
   */ 
  interface GwlFieldRefs {
    readonly id: FieldRef<"Gwl", 'Int'>
    readonly name: FieldRef<"Gwl", 'String'>
    readonly createdAt: FieldRef<"Gwl", 'DateTime'>
    readonly updatedAt: FieldRef<"Gwl", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Gwl findUnique
   */
  export type GwlFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gwl
     */
    select?: GwlSelect<ExtArgs> | null
    /**
     * Filter, which Gwl to fetch.
     */
    where: GwlWhereUniqueInput
  }

  /**
   * Gwl findUniqueOrThrow
   */
  export type GwlFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gwl
     */
    select?: GwlSelect<ExtArgs> | null
    /**
     * Filter, which Gwl to fetch.
     */
    where: GwlWhereUniqueInput
  }

  /**
   * Gwl findFirst
   */
  export type GwlFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gwl
     */
    select?: GwlSelect<ExtArgs> | null
    /**
     * Filter, which Gwl to fetch.
     */
    where?: GwlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gwls to fetch.
     */
    orderBy?: GwlOrderByWithRelationInput | GwlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gwls.
     */
    cursor?: GwlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gwls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gwls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gwls.
     */
    distinct?: GwlScalarFieldEnum | GwlScalarFieldEnum[]
  }

  /**
   * Gwl findFirstOrThrow
   */
  export type GwlFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gwl
     */
    select?: GwlSelect<ExtArgs> | null
    /**
     * Filter, which Gwl to fetch.
     */
    where?: GwlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gwls to fetch.
     */
    orderBy?: GwlOrderByWithRelationInput | GwlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gwls.
     */
    cursor?: GwlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gwls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gwls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gwls.
     */
    distinct?: GwlScalarFieldEnum | GwlScalarFieldEnum[]
  }

  /**
   * Gwl findMany
   */
  export type GwlFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gwl
     */
    select?: GwlSelect<ExtArgs> | null
    /**
     * Filter, which Gwls to fetch.
     */
    where?: GwlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gwls to fetch.
     */
    orderBy?: GwlOrderByWithRelationInput | GwlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gwls.
     */
    cursor?: GwlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gwls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gwls.
     */
    skip?: number
    distinct?: GwlScalarFieldEnum | GwlScalarFieldEnum[]
  }

  /**
   * Gwl create
   */
  export type GwlCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gwl
     */
    select?: GwlSelect<ExtArgs> | null
    /**
     * The data needed to create a Gwl.
     */
    data: XOR<GwlCreateInput, GwlUncheckedCreateInput>
  }

  /**
   * Gwl createMany
   */
  export type GwlCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Gwls.
     */
    data: GwlCreateManyInput | GwlCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gwl createManyAndReturn
   */
  export type GwlCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gwl
     */
    select?: GwlSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Gwls.
     */
    data: GwlCreateManyInput | GwlCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gwl update
   */
  export type GwlUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gwl
     */
    select?: GwlSelect<ExtArgs> | null
    /**
     * The data needed to update a Gwl.
     */
    data: XOR<GwlUpdateInput, GwlUncheckedUpdateInput>
    /**
     * Choose, which Gwl to update.
     */
    where: GwlWhereUniqueInput
  }

  /**
   * Gwl updateMany
   */
  export type GwlUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Gwls.
     */
    data: XOR<GwlUpdateManyMutationInput, GwlUncheckedUpdateManyInput>
    /**
     * Filter which Gwls to update
     */
    where?: GwlWhereInput
  }

  /**
   * Gwl upsert
   */
  export type GwlUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gwl
     */
    select?: GwlSelect<ExtArgs> | null
    /**
     * The filter to search for the Gwl to update in case it exists.
     */
    where: GwlWhereUniqueInput
    /**
     * In case the Gwl found by the `where` argument doesn't exist, create a new Gwl with this data.
     */
    create: XOR<GwlCreateInput, GwlUncheckedCreateInput>
    /**
     * In case the Gwl was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GwlUpdateInput, GwlUncheckedUpdateInput>
  }

  /**
   * Gwl delete
   */
  export type GwlDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gwl
     */
    select?: GwlSelect<ExtArgs> | null
    /**
     * Filter which Gwl to delete.
     */
    where: GwlWhereUniqueInput
  }

  /**
   * Gwl deleteMany
   */
  export type GwlDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gwls to delete
     */
    where?: GwlWhereInput
  }

  /**
   * Gwl without action
   */
  export type GwlDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gwl
     */
    select?: GwlSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CropScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CropScalarFieldEnum = (typeof CropScalarFieldEnum)[keyof typeof CropScalarFieldEnum]


  export const IndicatorCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IndicatorCategoryScalarFieldEnum = (typeof IndicatorCategoryScalarFieldEnum)[keyof typeof IndicatorCategoryScalarFieldEnum]


  export const IndicatorScalarFieldEnum: {
    id: 'id',
    categoryId: 'categoryId',
    name: 'name',
    unit: 'unit',
    description: 'description',
    source: 'source',
    defaultMin: 'defaultMin',
    defaultMax: 'defaultMax',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IndicatorScalarFieldEnum = (typeof IndicatorScalarFieldEnum)[keyof typeof IndicatorScalarFieldEnum]


  export const ZoneScalarFieldEnum: {
    id: 'id',
    zoneName: 'zoneName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ZoneScalarFieldEnum = (typeof ZoneScalarFieldEnum)[keyof typeof ZoneScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const DistrictScalarFieldEnum: {
    id: 'id',
    name: 'name',
    cityId: 'cityId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DistrictScalarFieldEnum = (typeof DistrictScalarFieldEnum)[keyof typeof DistrictScalarFieldEnum]


  export const ZoneDistrictScalarFieldEnum: {
    zoneId: 'zoneId',
    districtId: 'districtId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ZoneDistrictScalarFieldEnum = (typeof ZoneDistrictScalarFieldEnum)[keyof typeof ZoneDistrictScalarFieldEnum]


  export const CalendarScalarFieldEnum: {
    id: 'id',
    cropId: 'cropId',
    title: 'title',
    creatorId: 'creatorId',
    creatorName: 'creatorName',
    isShared: 'isShared',
    isPublished: 'isPublished',
    fileType: 'fileType',
    allowCenterUse: 'allowCenterUse',
    publishedAt: 'publishedAt',
    lastEditedAt: 'lastEditedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CalendarScalarFieldEnum = (typeof CalendarScalarFieldEnum)[keyof typeof CalendarScalarFieldEnum]


  export const CalendarZoneScalarFieldEnum: {
    id: 'id',
    calendarId: 'calendarId',
    zoneId: 'zoneId',
    zoneName: 'zoneName',
    cityCount: 'cityCount',
    districtCount: 'districtCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CalendarZoneScalarFieldEnum = (typeof CalendarZoneScalarFieldEnum)[keyof typeof CalendarZoneScalarFieldEnum]


  export const CalendarZoneDistrictScalarFieldEnum: {
    calendarZoneId: 'calendarZoneId',
    districtId: 'districtId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CalendarZoneDistrictScalarFieldEnum = (typeof CalendarZoneDistrictScalarFieldEnum)[keyof typeof CalendarZoneDistrictScalarFieldEnum]


  export const CalendarIndicatorScalarFieldEnum: {
    id: 'id',
    calendarId: 'calendarId',
    indicatorId: 'indicatorId',
    nameSnapshot: 'nameSnapshot',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CalendarIndicatorScalarFieldEnum = (typeof CalendarIndicatorScalarFieldEnum)[keyof typeof CalendarIndicatorScalarFieldEnum]


  export const StageScalarFieldEnum: {
    id: 'id',
    calendarId: 'calendarId',
    order: 'order',
    name: 'name',
    description: 'description',
    status: 'status',
    color: 'color',
    startTenDay: 'startTenDay',
    startMonth: 'startMonth',
    endTenDay: 'endTenDay',
    endMonth: 'endMonth',
    analysis: 'analysis',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StageScalarFieldEnum = (typeof StageScalarFieldEnum)[keyof typeof StageScalarFieldEnum]


  export const StageImageScalarFieldEnum: {
    id: 'id',
    stageId: 'stageId',
    type: 'type',
    url: 'url',
    thumbnail: 'thumbnail',
    name: 'name',
    source: 'source',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StageImageScalarFieldEnum = (typeof StageImageScalarFieldEnum)[keyof typeof StageImageScalarFieldEnum]


  export const StageThresholdScalarFieldEnum: {
    id: 'id',
    stageId: 'stageId',
    indicatorId: 'indicatorId',
    operator: 'operator',
    value: 'value',
    unit: 'unit',
    durationDays: 'durationDays',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StageThresholdScalarFieldEnum = (typeof StageThresholdScalarFieldEnum)[keyof typeof StageThresholdScalarFieldEnum]


  export const GwlScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GwlScalarFieldEnum = (typeof GwlScalarFieldEnum)[keyof typeof GwlScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'CalendarFileType'
   */
  export type EnumCalendarFileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CalendarFileType'>
    


  /**
   * Reference to a field of type 'CalendarFileType[]'
   */
  export type ListEnumCalendarFileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CalendarFileType[]'>
    


  /**
   * Reference to a field of type 'StageStatus'
   */
  export type EnumStageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StageStatus'>
    


  /**
   * Reference to a field of type 'StageStatus[]'
   */
  export type ListEnumStageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StageStatus[]'>
    


  /**
   * Reference to a field of type 'TenDay'
   */
  export type EnumTenDayFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenDay'>
    


  /**
   * Reference to a field of type 'TenDay[]'
   */
  export type ListEnumTenDayFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenDay[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'StageImageType'
   */
  export type EnumStageImageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StageImageType'>
    


  /**
   * Reference to a field of type 'StageImageType[]'
   */
  export type ListEnumStageImageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StageImageType[]'>
    


  /**
   * Reference to a field of type 'ThresholdOperator'
   */
  export type EnumThresholdOperatorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ThresholdOperator'>
    


  /**
   * Reference to a field of type 'ThresholdOperator[]'
   */
  export type ListEnumThresholdOperatorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ThresholdOperator[]'>
    
  /**
   * Deep Input Types
   */


  export type CropWhereInput = {
    AND?: CropWhereInput | CropWhereInput[]
    OR?: CropWhereInput[]
    NOT?: CropWhereInput | CropWhereInput[]
    id?: StringFilter<"Crop"> | string
    name?: StringFilter<"Crop"> | string
    description?: StringNullableFilter<"Crop"> | string | null
    createdAt?: DateTimeFilter<"Crop"> | Date | string
    updatedAt?: DateTimeFilter<"Crop"> | Date | string
    calendars?: CalendarListRelationFilter
  }

  export type CropOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    calendars?: CalendarOrderByRelationAggregateInput
  }

  export type CropWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CropWhereInput | CropWhereInput[]
    OR?: CropWhereInput[]
    NOT?: CropWhereInput | CropWhereInput[]
    name?: StringFilter<"Crop"> | string
    description?: StringNullableFilter<"Crop"> | string | null
    createdAt?: DateTimeFilter<"Crop"> | Date | string
    updatedAt?: DateTimeFilter<"Crop"> | Date | string
    calendars?: CalendarListRelationFilter
  }, "id">

  export type CropOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CropCountOrderByAggregateInput
    _max?: CropMaxOrderByAggregateInput
    _min?: CropMinOrderByAggregateInput
  }

  export type CropScalarWhereWithAggregatesInput = {
    AND?: CropScalarWhereWithAggregatesInput | CropScalarWhereWithAggregatesInput[]
    OR?: CropScalarWhereWithAggregatesInput[]
    NOT?: CropScalarWhereWithAggregatesInput | CropScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Crop"> | string
    name?: StringWithAggregatesFilter<"Crop"> | string
    description?: StringNullableWithAggregatesFilter<"Crop"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Crop"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Crop"> | Date | string
  }

  export type IndicatorCategoryWhereInput = {
    AND?: IndicatorCategoryWhereInput | IndicatorCategoryWhereInput[]
    OR?: IndicatorCategoryWhereInput[]
    NOT?: IndicatorCategoryWhereInput | IndicatorCategoryWhereInput[]
    id?: StringFilter<"IndicatorCategory"> | string
    name?: StringFilter<"IndicatorCategory"> | string
    description?: StringNullableFilter<"IndicatorCategory"> | string | null
    order?: IntFilter<"IndicatorCategory"> | number
    createdAt?: DateTimeFilter<"IndicatorCategory"> | Date | string
    updatedAt?: DateTimeFilter<"IndicatorCategory"> | Date | string
    indicators?: IndicatorListRelationFilter
  }

  export type IndicatorCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    indicators?: IndicatorOrderByRelationAggregateInput
  }

  export type IndicatorCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: IndicatorCategoryWhereInput | IndicatorCategoryWhereInput[]
    OR?: IndicatorCategoryWhereInput[]
    NOT?: IndicatorCategoryWhereInput | IndicatorCategoryWhereInput[]
    description?: StringNullableFilter<"IndicatorCategory"> | string | null
    order?: IntFilter<"IndicatorCategory"> | number
    createdAt?: DateTimeFilter<"IndicatorCategory"> | Date | string
    updatedAt?: DateTimeFilter<"IndicatorCategory"> | Date | string
    indicators?: IndicatorListRelationFilter
  }, "id" | "name">

  export type IndicatorCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IndicatorCategoryCountOrderByAggregateInput
    _avg?: IndicatorCategoryAvgOrderByAggregateInput
    _max?: IndicatorCategoryMaxOrderByAggregateInput
    _min?: IndicatorCategoryMinOrderByAggregateInput
    _sum?: IndicatorCategorySumOrderByAggregateInput
  }

  export type IndicatorCategoryScalarWhereWithAggregatesInput = {
    AND?: IndicatorCategoryScalarWhereWithAggregatesInput | IndicatorCategoryScalarWhereWithAggregatesInput[]
    OR?: IndicatorCategoryScalarWhereWithAggregatesInput[]
    NOT?: IndicatorCategoryScalarWhereWithAggregatesInput | IndicatorCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IndicatorCategory"> | string
    name?: StringWithAggregatesFilter<"IndicatorCategory"> | string
    description?: StringNullableWithAggregatesFilter<"IndicatorCategory"> | string | null
    order?: IntWithAggregatesFilter<"IndicatorCategory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"IndicatorCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IndicatorCategory"> | Date | string
  }

  export type IndicatorWhereInput = {
    AND?: IndicatorWhereInput | IndicatorWhereInput[]
    OR?: IndicatorWhereInput[]
    NOT?: IndicatorWhereInput | IndicatorWhereInput[]
    id?: StringFilter<"Indicator"> | string
    categoryId?: StringFilter<"Indicator"> | string
    name?: StringFilter<"Indicator"> | string
    unit?: StringFilter<"Indicator"> | string
    description?: StringNullableFilter<"Indicator"> | string | null
    source?: StringFilter<"Indicator"> | string
    defaultMin?: FloatNullableFilter<"Indicator"> | number | null
    defaultMax?: FloatNullableFilter<"Indicator"> | number | null
    createdAt?: DateTimeFilter<"Indicator"> | Date | string
    updatedAt?: DateTimeFilter<"Indicator"> | Date | string
    category?: XOR<IndicatorCategoryRelationFilter, IndicatorCategoryWhereInput>
    thresholds?: StageThresholdListRelationFilter
    calendarIndicators?: CalendarIndicatorListRelationFilter
  }

  export type IndicatorOrderByWithRelationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    description?: SortOrderInput | SortOrder
    source?: SortOrder
    defaultMin?: SortOrderInput | SortOrder
    defaultMax?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: IndicatorCategoryOrderByWithRelationInput
    thresholds?: StageThresholdOrderByRelationAggregateInput
    calendarIndicators?: CalendarIndicatorOrderByRelationAggregateInput
  }

  export type IndicatorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IndicatorWhereInput | IndicatorWhereInput[]
    OR?: IndicatorWhereInput[]
    NOT?: IndicatorWhereInput | IndicatorWhereInput[]
    categoryId?: StringFilter<"Indicator"> | string
    name?: StringFilter<"Indicator"> | string
    unit?: StringFilter<"Indicator"> | string
    description?: StringNullableFilter<"Indicator"> | string | null
    source?: StringFilter<"Indicator"> | string
    defaultMin?: FloatNullableFilter<"Indicator"> | number | null
    defaultMax?: FloatNullableFilter<"Indicator"> | number | null
    createdAt?: DateTimeFilter<"Indicator"> | Date | string
    updatedAt?: DateTimeFilter<"Indicator"> | Date | string
    category?: XOR<IndicatorCategoryRelationFilter, IndicatorCategoryWhereInput>
    thresholds?: StageThresholdListRelationFilter
    calendarIndicators?: CalendarIndicatorListRelationFilter
  }, "id">

  export type IndicatorOrderByWithAggregationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    description?: SortOrderInput | SortOrder
    source?: SortOrder
    defaultMin?: SortOrderInput | SortOrder
    defaultMax?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IndicatorCountOrderByAggregateInput
    _avg?: IndicatorAvgOrderByAggregateInput
    _max?: IndicatorMaxOrderByAggregateInput
    _min?: IndicatorMinOrderByAggregateInput
    _sum?: IndicatorSumOrderByAggregateInput
  }

  export type IndicatorScalarWhereWithAggregatesInput = {
    AND?: IndicatorScalarWhereWithAggregatesInput | IndicatorScalarWhereWithAggregatesInput[]
    OR?: IndicatorScalarWhereWithAggregatesInput[]
    NOT?: IndicatorScalarWhereWithAggregatesInput | IndicatorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Indicator"> | string
    categoryId?: StringWithAggregatesFilter<"Indicator"> | string
    name?: StringWithAggregatesFilter<"Indicator"> | string
    unit?: StringWithAggregatesFilter<"Indicator"> | string
    description?: StringNullableWithAggregatesFilter<"Indicator"> | string | null
    source?: StringWithAggregatesFilter<"Indicator"> | string
    defaultMin?: FloatNullableWithAggregatesFilter<"Indicator"> | number | null
    defaultMax?: FloatNullableWithAggregatesFilter<"Indicator"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Indicator"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Indicator"> | Date | string
  }

  export type ZoneWhereInput = {
    AND?: ZoneWhereInput | ZoneWhereInput[]
    OR?: ZoneWhereInput[]
    NOT?: ZoneWhereInput | ZoneWhereInput[]
    id?: StringFilter<"Zone"> | string
    zoneName?: StringFilter<"Zone"> | string
    createdAt?: DateTimeFilter<"Zone"> | Date | string
    updatedAt?: DateTimeFilter<"Zone"> | Date | string
    zoneDistricts?: ZoneDistrictListRelationFilter
    calendarZones?: CalendarZoneListRelationFilter
  }

  export type ZoneOrderByWithRelationInput = {
    id?: SortOrder
    zoneName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    zoneDistricts?: ZoneDistrictOrderByRelationAggregateInput
    calendarZones?: CalendarZoneOrderByRelationAggregateInput
  }

  export type ZoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ZoneWhereInput | ZoneWhereInput[]
    OR?: ZoneWhereInput[]
    NOT?: ZoneWhereInput | ZoneWhereInput[]
    zoneName?: StringFilter<"Zone"> | string
    createdAt?: DateTimeFilter<"Zone"> | Date | string
    updatedAt?: DateTimeFilter<"Zone"> | Date | string
    zoneDistricts?: ZoneDistrictListRelationFilter
    calendarZones?: CalendarZoneListRelationFilter
  }, "id">

  export type ZoneOrderByWithAggregationInput = {
    id?: SortOrder
    zoneName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ZoneCountOrderByAggregateInput
    _max?: ZoneMaxOrderByAggregateInput
    _min?: ZoneMinOrderByAggregateInput
  }

  export type ZoneScalarWhereWithAggregatesInput = {
    AND?: ZoneScalarWhereWithAggregatesInput | ZoneScalarWhereWithAggregatesInput[]
    OR?: ZoneScalarWhereWithAggregatesInput[]
    NOT?: ZoneScalarWhereWithAggregatesInput | ZoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Zone"> | string
    zoneName?: StringWithAggregatesFilter<"Zone"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Zone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Zone"> | Date | string
  }

  export type CityWhereInput = {
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    id?: IntFilter<"City"> | number
    name?: StringFilter<"City"> | string
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
    districts?: DistrictListRelationFilter
  }

  export type CityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    districts?: DistrictOrderByRelationAggregateInput
  }

  export type CityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    name?: StringFilter<"City"> | string
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
    districts?: DistrictListRelationFilter
  }, "id">

  export type CityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CityCountOrderByAggregateInput
    _avg?: CityAvgOrderByAggregateInput
    _max?: CityMaxOrderByAggregateInput
    _min?: CityMinOrderByAggregateInput
    _sum?: CitySumOrderByAggregateInput
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    OR?: CityScalarWhereWithAggregatesInput[]
    NOT?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"City"> | number
    name?: StringWithAggregatesFilter<"City"> | string
    createdAt?: DateTimeWithAggregatesFilter<"City"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"City"> | Date | string
  }

  export type DistrictWhereInput = {
    AND?: DistrictWhereInput | DistrictWhereInput[]
    OR?: DistrictWhereInput[]
    NOT?: DistrictWhereInput | DistrictWhereInput[]
    id?: IntFilter<"District"> | number
    name?: StringFilter<"District"> | string
    cityId?: IntFilter<"District"> | number
    createdAt?: DateTimeFilter<"District"> | Date | string
    updatedAt?: DateTimeFilter<"District"> | Date | string
    city?: XOR<CityRelationFilter, CityWhereInput>
    zoneDistricts?: ZoneDistrictListRelationFilter
    calendarZoneDistricts?: CalendarZoneDistrictListRelationFilter
  }

  export type DistrictOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    city?: CityOrderByWithRelationInput
    zoneDistricts?: ZoneDistrictOrderByRelationAggregateInput
    calendarZoneDistricts?: CalendarZoneDistrictOrderByRelationAggregateInput
  }

  export type DistrictWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DistrictWhereInput | DistrictWhereInput[]
    OR?: DistrictWhereInput[]
    NOT?: DistrictWhereInput | DistrictWhereInput[]
    name?: StringFilter<"District"> | string
    cityId?: IntFilter<"District"> | number
    createdAt?: DateTimeFilter<"District"> | Date | string
    updatedAt?: DateTimeFilter<"District"> | Date | string
    city?: XOR<CityRelationFilter, CityWhereInput>
    zoneDistricts?: ZoneDistrictListRelationFilter
    calendarZoneDistricts?: CalendarZoneDistrictListRelationFilter
  }, "id">

  export type DistrictOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DistrictCountOrderByAggregateInput
    _avg?: DistrictAvgOrderByAggregateInput
    _max?: DistrictMaxOrderByAggregateInput
    _min?: DistrictMinOrderByAggregateInput
    _sum?: DistrictSumOrderByAggregateInput
  }

  export type DistrictScalarWhereWithAggregatesInput = {
    AND?: DistrictScalarWhereWithAggregatesInput | DistrictScalarWhereWithAggregatesInput[]
    OR?: DistrictScalarWhereWithAggregatesInput[]
    NOT?: DistrictScalarWhereWithAggregatesInput | DistrictScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"District"> | number
    name?: StringWithAggregatesFilter<"District"> | string
    cityId?: IntWithAggregatesFilter<"District"> | number
    createdAt?: DateTimeWithAggregatesFilter<"District"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"District"> | Date | string
  }

  export type ZoneDistrictWhereInput = {
    AND?: ZoneDistrictWhereInput | ZoneDistrictWhereInput[]
    OR?: ZoneDistrictWhereInput[]
    NOT?: ZoneDistrictWhereInput | ZoneDistrictWhereInput[]
    zoneId?: StringFilter<"ZoneDistrict"> | string
    districtId?: IntFilter<"ZoneDistrict"> | number
    createdAt?: DateTimeFilter<"ZoneDistrict"> | Date | string
    updatedAt?: DateTimeFilter<"ZoneDistrict"> | Date | string
    zone?: XOR<ZoneRelationFilter, ZoneWhereInput>
    district?: XOR<DistrictRelationFilter, DistrictWhereInput>
  }

  export type ZoneDistrictOrderByWithRelationInput = {
    zoneId?: SortOrder
    districtId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    zone?: ZoneOrderByWithRelationInput
    district?: DistrictOrderByWithRelationInput
  }

  export type ZoneDistrictWhereUniqueInput = Prisma.AtLeast<{
    zoneId_districtId?: ZoneDistrictZoneIdDistrictIdCompoundUniqueInput
    AND?: ZoneDistrictWhereInput | ZoneDistrictWhereInput[]
    OR?: ZoneDistrictWhereInput[]
    NOT?: ZoneDistrictWhereInput | ZoneDistrictWhereInput[]
    zoneId?: StringFilter<"ZoneDistrict"> | string
    districtId?: IntFilter<"ZoneDistrict"> | number
    createdAt?: DateTimeFilter<"ZoneDistrict"> | Date | string
    updatedAt?: DateTimeFilter<"ZoneDistrict"> | Date | string
    zone?: XOR<ZoneRelationFilter, ZoneWhereInput>
    district?: XOR<DistrictRelationFilter, DistrictWhereInput>
  }, "zoneId_districtId">

  export type ZoneDistrictOrderByWithAggregationInput = {
    zoneId?: SortOrder
    districtId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ZoneDistrictCountOrderByAggregateInput
    _avg?: ZoneDistrictAvgOrderByAggregateInput
    _max?: ZoneDistrictMaxOrderByAggregateInput
    _min?: ZoneDistrictMinOrderByAggregateInput
    _sum?: ZoneDistrictSumOrderByAggregateInput
  }

  export type ZoneDistrictScalarWhereWithAggregatesInput = {
    AND?: ZoneDistrictScalarWhereWithAggregatesInput | ZoneDistrictScalarWhereWithAggregatesInput[]
    OR?: ZoneDistrictScalarWhereWithAggregatesInput[]
    NOT?: ZoneDistrictScalarWhereWithAggregatesInput | ZoneDistrictScalarWhereWithAggregatesInput[]
    zoneId?: StringWithAggregatesFilter<"ZoneDistrict"> | string
    districtId?: IntWithAggregatesFilter<"ZoneDistrict"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ZoneDistrict"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ZoneDistrict"> | Date | string
  }

  export type CalendarWhereInput = {
    AND?: CalendarWhereInput | CalendarWhereInput[]
    OR?: CalendarWhereInput[]
    NOT?: CalendarWhereInput | CalendarWhereInput[]
    id?: StringFilter<"Calendar"> | string
    cropId?: StringFilter<"Calendar"> | string
    title?: StringFilter<"Calendar"> | string
    creatorId?: StringFilter<"Calendar"> | string
    creatorName?: StringFilter<"Calendar"> | string
    isShared?: BoolFilter<"Calendar"> | boolean
    isPublished?: BoolFilter<"Calendar"> | boolean
    fileType?: EnumCalendarFileTypeFilter<"Calendar"> | $Enums.CalendarFileType
    allowCenterUse?: BoolFilter<"Calendar"> | boolean
    publishedAt?: DateTimeNullableFilter<"Calendar"> | Date | string | null
    lastEditedAt?: DateTimeFilter<"Calendar"> | Date | string
    createdAt?: DateTimeFilter<"Calendar"> | Date | string
    updatedAt?: DateTimeFilter<"Calendar"> | Date | string
    crop?: XOR<CropRelationFilter, CropWhereInput>
    stages?: StageListRelationFilter
    calendarZones?: CalendarZoneListRelationFilter
    calendarIndicators?: CalendarIndicatorListRelationFilter
  }

  export type CalendarOrderByWithRelationInput = {
    id?: SortOrder
    cropId?: SortOrder
    title?: SortOrder
    creatorId?: SortOrder
    creatorName?: SortOrder
    isShared?: SortOrder
    isPublished?: SortOrder
    fileType?: SortOrder
    allowCenterUse?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    lastEditedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    crop?: CropOrderByWithRelationInput
    stages?: StageOrderByRelationAggregateInput
    calendarZones?: CalendarZoneOrderByRelationAggregateInput
    calendarIndicators?: CalendarIndicatorOrderByRelationAggregateInput
  }

  export type CalendarWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CalendarWhereInput | CalendarWhereInput[]
    OR?: CalendarWhereInput[]
    NOT?: CalendarWhereInput | CalendarWhereInput[]
    cropId?: StringFilter<"Calendar"> | string
    title?: StringFilter<"Calendar"> | string
    creatorId?: StringFilter<"Calendar"> | string
    creatorName?: StringFilter<"Calendar"> | string
    isShared?: BoolFilter<"Calendar"> | boolean
    isPublished?: BoolFilter<"Calendar"> | boolean
    fileType?: EnumCalendarFileTypeFilter<"Calendar"> | $Enums.CalendarFileType
    allowCenterUse?: BoolFilter<"Calendar"> | boolean
    publishedAt?: DateTimeNullableFilter<"Calendar"> | Date | string | null
    lastEditedAt?: DateTimeFilter<"Calendar"> | Date | string
    createdAt?: DateTimeFilter<"Calendar"> | Date | string
    updatedAt?: DateTimeFilter<"Calendar"> | Date | string
    crop?: XOR<CropRelationFilter, CropWhereInput>
    stages?: StageListRelationFilter
    calendarZones?: CalendarZoneListRelationFilter
    calendarIndicators?: CalendarIndicatorListRelationFilter
  }, "id">

  export type CalendarOrderByWithAggregationInput = {
    id?: SortOrder
    cropId?: SortOrder
    title?: SortOrder
    creatorId?: SortOrder
    creatorName?: SortOrder
    isShared?: SortOrder
    isPublished?: SortOrder
    fileType?: SortOrder
    allowCenterUse?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    lastEditedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CalendarCountOrderByAggregateInput
    _max?: CalendarMaxOrderByAggregateInput
    _min?: CalendarMinOrderByAggregateInput
  }

  export type CalendarScalarWhereWithAggregatesInput = {
    AND?: CalendarScalarWhereWithAggregatesInput | CalendarScalarWhereWithAggregatesInput[]
    OR?: CalendarScalarWhereWithAggregatesInput[]
    NOT?: CalendarScalarWhereWithAggregatesInput | CalendarScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Calendar"> | string
    cropId?: StringWithAggregatesFilter<"Calendar"> | string
    title?: StringWithAggregatesFilter<"Calendar"> | string
    creatorId?: StringWithAggregatesFilter<"Calendar"> | string
    creatorName?: StringWithAggregatesFilter<"Calendar"> | string
    isShared?: BoolWithAggregatesFilter<"Calendar"> | boolean
    isPublished?: BoolWithAggregatesFilter<"Calendar"> | boolean
    fileType?: EnumCalendarFileTypeWithAggregatesFilter<"Calendar"> | $Enums.CalendarFileType
    allowCenterUse?: BoolWithAggregatesFilter<"Calendar"> | boolean
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Calendar"> | Date | string | null
    lastEditedAt?: DateTimeWithAggregatesFilter<"Calendar"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Calendar"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Calendar"> | Date | string
  }

  export type CalendarZoneWhereInput = {
    AND?: CalendarZoneWhereInput | CalendarZoneWhereInput[]
    OR?: CalendarZoneWhereInput[]
    NOT?: CalendarZoneWhereInput | CalendarZoneWhereInput[]
    id?: StringFilter<"CalendarZone"> | string
    calendarId?: StringFilter<"CalendarZone"> | string
    zoneId?: StringFilter<"CalendarZone"> | string
    zoneName?: StringFilter<"CalendarZone"> | string
    cityCount?: IntFilter<"CalendarZone"> | number
    districtCount?: IntFilter<"CalendarZone"> | number
    createdAt?: DateTimeFilter<"CalendarZone"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarZone"> | Date | string
    calendar?: XOR<CalendarRelationFilter, CalendarWhereInput>
    zone?: XOR<ZoneRelationFilter, ZoneWhereInput>
    districts?: CalendarZoneDistrictListRelationFilter
  }

  export type CalendarZoneOrderByWithRelationInput = {
    id?: SortOrder
    calendarId?: SortOrder
    zoneId?: SortOrder
    zoneName?: SortOrder
    cityCount?: SortOrder
    districtCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    calendar?: CalendarOrderByWithRelationInput
    zone?: ZoneOrderByWithRelationInput
    districts?: CalendarZoneDistrictOrderByRelationAggregateInput
  }

  export type CalendarZoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CalendarZoneWhereInput | CalendarZoneWhereInput[]
    OR?: CalendarZoneWhereInput[]
    NOT?: CalendarZoneWhereInput | CalendarZoneWhereInput[]
    calendarId?: StringFilter<"CalendarZone"> | string
    zoneId?: StringFilter<"CalendarZone"> | string
    zoneName?: StringFilter<"CalendarZone"> | string
    cityCount?: IntFilter<"CalendarZone"> | number
    districtCount?: IntFilter<"CalendarZone"> | number
    createdAt?: DateTimeFilter<"CalendarZone"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarZone"> | Date | string
    calendar?: XOR<CalendarRelationFilter, CalendarWhereInput>
    zone?: XOR<ZoneRelationFilter, ZoneWhereInput>
    districts?: CalendarZoneDistrictListRelationFilter
  }, "id">

  export type CalendarZoneOrderByWithAggregationInput = {
    id?: SortOrder
    calendarId?: SortOrder
    zoneId?: SortOrder
    zoneName?: SortOrder
    cityCount?: SortOrder
    districtCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CalendarZoneCountOrderByAggregateInput
    _avg?: CalendarZoneAvgOrderByAggregateInput
    _max?: CalendarZoneMaxOrderByAggregateInput
    _min?: CalendarZoneMinOrderByAggregateInput
    _sum?: CalendarZoneSumOrderByAggregateInput
  }

  export type CalendarZoneScalarWhereWithAggregatesInput = {
    AND?: CalendarZoneScalarWhereWithAggregatesInput | CalendarZoneScalarWhereWithAggregatesInput[]
    OR?: CalendarZoneScalarWhereWithAggregatesInput[]
    NOT?: CalendarZoneScalarWhereWithAggregatesInput | CalendarZoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CalendarZone"> | string
    calendarId?: StringWithAggregatesFilter<"CalendarZone"> | string
    zoneId?: StringWithAggregatesFilter<"CalendarZone"> | string
    zoneName?: StringWithAggregatesFilter<"CalendarZone"> | string
    cityCount?: IntWithAggregatesFilter<"CalendarZone"> | number
    districtCount?: IntWithAggregatesFilter<"CalendarZone"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CalendarZone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CalendarZone"> | Date | string
  }

  export type CalendarZoneDistrictWhereInput = {
    AND?: CalendarZoneDistrictWhereInput | CalendarZoneDistrictWhereInput[]
    OR?: CalendarZoneDistrictWhereInput[]
    NOT?: CalendarZoneDistrictWhereInput | CalendarZoneDistrictWhereInput[]
    calendarZoneId?: StringFilter<"CalendarZoneDistrict"> | string
    districtId?: IntFilter<"CalendarZoneDistrict"> | number
    createdAt?: DateTimeFilter<"CalendarZoneDistrict"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarZoneDistrict"> | Date | string
    calendarZone?: XOR<CalendarZoneRelationFilter, CalendarZoneWhereInput>
    district?: XOR<DistrictRelationFilter, DistrictWhereInput>
  }

  export type CalendarZoneDistrictOrderByWithRelationInput = {
    calendarZoneId?: SortOrder
    districtId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    calendarZone?: CalendarZoneOrderByWithRelationInput
    district?: DistrictOrderByWithRelationInput
  }

  export type CalendarZoneDistrictWhereUniqueInput = Prisma.AtLeast<{
    calendarZoneId_districtId?: CalendarZoneDistrictCalendarZoneIdDistrictIdCompoundUniqueInput
    AND?: CalendarZoneDistrictWhereInput | CalendarZoneDistrictWhereInput[]
    OR?: CalendarZoneDistrictWhereInput[]
    NOT?: CalendarZoneDistrictWhereInput | CalendarZoneDistrictWhereInput[]
    calendarZoneId?: StringFilter<"CalendarZoneDistrict"> | string
    districtId?: IntFilter<"CalendarZoneDistrict"> | number
    createdAt?: DateTimeFilter<"CalendarZoneDistrict"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarZoneDistrict"> | Date | string
    calendarZone?: XOR<CalendarZoneRelationFilter, CalendarZoneWhereInput>
    district?: XOR<DistrictRelationFilter, DistrictWhereInput>
  }, "calendarZoneId_districtId">

  export type CalendarZoneDistrictOrderByWithAggregationInput = {
    calendarZoneId?: SortOrder
    districtId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CalendarZoneDistrictCountOrderByAggregateInput
    _avg?: CalendarZoneDistrictAvgOrderByAggregateInput
    _max?: CalendarZoneDistrictMaxOrderByAggregateInput
    _min?: CalendarZoneDistrictMinOrderByAggregateInput
    _sum?: CalendarZoneDistrictSumOrderByAggregateInput
  }

  export type CalendarZoneDistrictScalarWhereWithAggregatesInput = {
    AND?: CalendarZoneDistrictScalarWhereWithAggregatesInput | CalendarZoneDistrictScalarWhereWithAggregatesInput[]
    OR?: CalendarZoneDistrictScalarWhereWithAggregatesInput[]
    NOT?: CalendarZoneDistrictScalarWhereWithAggregatesInput | CalendarZoneDistrictScalarWhereWithAggregatesInput[]
    calendarZoneId?: StringWithAggregatesFilter<"CalendarZoneDistrict"> | string
    districtId?: IntWithAggregatesFilter<"CalendarZoneDistrict"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CalendarZoneDistrict"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CalendarZoneDistrict"> | Date | string
  }

  export type CalendarIndicatorWhereInput = {
    AND?: CalendarIndicatorWhereInput | CalendarIndicatorWhereInput[]
    OR?: CalendarIndicatorWhereInput[]
    NOT?: CalendarIndicatorWhereInput | CalendarIndicatorWhereInput[]
    id?: StringFilter<"CalendarIndicator"> | string
    calendarId?: StringFilter<"CalendarIndicator"> | string
    indicatorId?: StringFilter<"CalendarIndicator"> | string
    nameSnapshot?: StringFilter<"CalendarIndicator"> | string
    createdAt?: DateTimeFilter<"CalendarIndicator"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarIndicator"> | Date | string
    calendar?: XOR<CalendarRelationFilter, CalendarWhereInput>
    indicator?: XOR<IndicatorRelationFilter, IndicatorWhereInput>
  }

  export type CalendarIndicatorOrderByWithRelationInput = {
    id?: SortOrder
    calendarId?: SortOrder
    indicatorId?: SortOrder
    nameSnapshot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    calendar?: CalendarOrderByWithRelationInput
    indicator?: IndicatorOrderByWithRelationInput
  }

  export type CalendarIndicatorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CalendarIndicatorWhereInput | CalendarIndicatorWhereInput[]
    OR?: CalendarIndicatorWhereInput[]
    NOT?: CalendarIndicatorWhereInput | CalendarIndicatorWhereInput[]
    calendarId?: StringFilter<"CalendarIndicator"> | string
    indicatorId?: StringFilter<"CalendarIndicator"> | string
    nameSnapshot?: StringFilter<"CalendarIndicator"> | string
    createdAt?: DateTimeFilter<"CalendarIndicator"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarIndicator"> | Date | string
    calendar?: XOR<CalendarRelationFilter, CalendarWhereInput>
    indicator?: XOR<IndicatorRelationFilter, IndicatorWhereInput>
  }, "id">

  export type CalendarIndicatorOrderByWithAggregationInput = {
    id?: SortOrder
    calendarId?: SortOrder
    indicatorId?: SortOrder
    nameSnapshot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CalendarIndicatorCountOrderByAggregateInput
    _max?: CalendarIndicatorMaxOrderByAggregateInput
    _min?: CalendarIndicatorMinOrderByAggregateInput
  }

  export type CalendarIndicatorScalarWhereWithAggregatesInput = {
    AND?: CalendarIndicatorScalarWhereWithAggregatesInput | CalendarIndicatorScalarWhereWithAggregatesInput[]
    OR?: CalendarIndicatorScalarWhereWithAggregatesInput[]
    NOT?: CalendarIndicatorScalarWhereWithAggregatesInput | CalendarIndicatorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CalendarIndicator"> | string
    calendarId?: StringWithAggregatesFilter<"CalendarIndicator"> | string
    indicatorId?: StringWithAggregatesFilter<"CalendarIndicator"> | string
    nameSnapshot?: StringWithAggregatesFilter<"CalendarIndicator"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CalendarIndicator"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CalendarIndicator"> | Date | string
  }

  export type StageWhereInput = {
    AND?: StageWhereInput | StageWhereInput[]
    OR?: StageWhereInput[]
    NOT?: StageWhereInput | StageWhereInput[]
    id?: StringFilter<"Stage"> | string
    calendarId?: StringFilter<"Stage"> | string
    order?: IntFilter<"Stage"> | number
    name?: StringFilter<"Stage"> | string
    description?: StringNullableFilter<"Stage"> | string | null
    status?: EnumStageStatusFilter<"Stage"> | $Enums.StageStatus
    color?: StringFilter<"Stage"> | string
    startTenDay?: EnumTenDayNullableFilter<"Stage"> | $Enums.TenDay | null
    startMonth?: IntNullableFilter<"Stage"> | number | null
    endTenDay?: EnumTenDayNullableFilter<"Stage"> | $Enums.TenDay | null
    endMonth?: IntNullableFilter<"Stage"> | number | null
    analysis?: JsonNullableFilter<"Stage">
    createdAt?: DateTimeFilter<"Stage"> | Date | string
    updatedAt?: DateTimeFilter<"Stage"> | Date | string
    calendar?: XOR<CalendarRelationFilter, CalendarWhereInput>
    images?: StageImageListRelationFilter
    thresholds?: StageThresholdListRelationFilter
  }

  export type StageOrderByWithRelationInput = {
    id?: SortOrder
    calendarId?: SortOrder
    order?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    color?: SortOrder
    startTenDay?: SortOrderInput | SortOrder
    startMonth?: SortOrderInput | SortOrder
    endTenDay?: SortOrderInput | SortOrder
    endMonth?: SortOrderInput | SortOrder
    analysis?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    calendar?: CalendarOrderByWithRelationInput
    images?: StageImageOrderByRelationAggregateInput
    thresholds?: StageThresholdOrderByRelationAggregateInput
  }

  export type StageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StageWhereInput | StageWhereInput[]
    OR?: StageWhereInput[]
    NOT?: StageWhereInput | StageWhereInput[]
    calendarId?: StringFilter<"Stage"> | string
    order?: IntFilter<"Stage"> | number
    name?: StringFilter<"Stage"> | string
    description?: StringNullableFilter<"Stage"> | string | null
    status?: EnumStageStatusFilter<"Stage"> | $Enums.StageStatus
    color?: StringFilter<"Stage"> | string
    startTenDay?: EnumTenDayNullableFilter<"Stage"> | $Enums.TenDay | null
    startMonth?: IntNullableFilter<"Stage"> | number | null
    endTenDay?: EnumTenDayNullableFilter<"Stage"> | $Enums.TenDay | null
    endMonth?: IntNullableFilter<"Stage"> | number | null
    analysis?: JsonNullableFilter<"Stage">
    createdAt?: DateTimeFilter<"Stage"> | Date | string
    updatedAt?: DateTimeFilter<"Stage"> | Date | string
    calendar?: XOR<CalendarRelationFilter, CalendarWhereInput>
    images?: StageImageListRelationFilter
    thresholds?: StageThresholdListRelationFilter
  }, "id">

  export type StageOrderByWithAggregationInput = {
    id?: SortOrder
    calendarId?: SortOrder
    order?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    color?: SortOrder
    startTenDay?: SortOrderInput | SortOrder
    startMonth?: SortOrderInput | SortOrder
    endTenDay?: SortOrderInput | SortOrder
    endMonth?: SortOrderInput | SortOrder
    analysis?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StageCountOrderByAggregateInput
    _avg?: StageAvgOrderByAggregateInput
    _max?: StageMaxOrderByAggregateInput
    _min?: StageMinOrderByAggregateInput
    _sum?: StageSumOrderByAggregateInput
  }

  export type StageScalarWhereWithAggregatesInput = {
    AND?: StageScalarWhereWithAggregatesInput | StageScalarWhereWithAggregatesInput[]
    OR?: StageScalarWhereWithAggregatesInput[]
    NOT?: StageScalarWhereWithAggregatesInput | StageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Stage"> | string
    calendarId?: StringWithAggregatesFilter<"Stage"> | string
    order?: IntWithAggregatesFilter<"Stage"> | number
    name?: StringWithAggregatesFilter<"Stage"> | string
    description?: StringNullableWithAggregatesFilter<"Stage"> | string | null
    status?: EnumStageStatusWithAggregatesFilter<"Stage"> | $Enums.StageStatus
    color?: StringWithAggregatesFilter<"Stage"> | string
    startTenDay?: EnumTenDayNullableWithAggregatesFilter<"Stage"> | $Enums.TenDay | null
    startMonth?: IntNullableWithAggregatesFilter<"Stage"> | number | null
    endTenDay?: EnumTenDayNullableWithAggregatesFilter<"Stage"> | $Enums.TenDay | null
    endMonth?: IntNullableWithAggregatesFilter<"Stage"> | number | null
    analysis?: JsonNullableWithAggregatesFilter<"Stage">
    createdAt?: DateTimeWithAggregatesFilter<"Stage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Stage"> | Date | string
  }

  export type StageImageWhereInput = {
    AND?: StageImageWhereInput | StageImageWhereInput[]
    OR?: StageImageWhereInput[]
    NOT?: StageImageWhereInput | StageImageWhereInput[]
    id?: StringFilter<"StageImage"> | string
    stageId?: StringFilter<"StageImage"> | string
    type?: EnumStageImageTypeFilter<"StageImage"> | $Enums.StageImageType
    url?: StringFilter<"StageImage"> | string
    thumbnail?: StringNullableFilter<"StageImage"> | string | null
    name?: StringNullableFilter<"StageImage"> | string | null
    source?: StringNullableFilter<"StageImage"> | string | null
    sortOrder?: IntFilter<"StageImage"> | number
    createdAt?: DateTimeFilter<"StageImage"> | Date | string
    updatedAt?: DateTimeFilter<"StageImage"> | Date | string
    stage?: XOR<StageRelationFilter, StageWhereInput>
  }

  export type StageImageOrderByWithRelationInput = {
    id?: SortOrder
    stageId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stage?: StageOrderByWithRelationInput
  }

  export type StageImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StageImageWhereInput | StageImageWhereInput[]
    OR?: StageImageWhereInput[]
    NOT?: StageImageWhereInput | StageImageWhereInput[]
    stageId?: StringFilter<"StageImage"> | string
    type?: EnumStageImageTypeFilter<"StageImage"> | $Enums.StageImageType
    url?: StringFilter<"StageImage"> | string
    thumbnail?: StringNullableFilter<"StageImage"> | string | null
    name?: StringNullableFilter<"StageImage"> | string | null
    source?: StringNullableFilter<"StageImage"> | string | null
    sortOrder?: IntFilter<"StageImage"> | number
    createdAt?: DateTimeFilter<"StageImage"> | Date | string
    updatedAt?: DateTimeFilter<"StageImage"> | Date | string
    stage?: XOR<StageRelationFilter, StageWhereInput>
  }, "id">

  export type StageImageOrderByWithAggregationInput = {
    id?: SortOrder
    stageId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StageImageCountOrderByAggregateInput
    _avg?: StageImageAvgOrderByAggregateInput
    _max?: StageImageMaxOrderByAggregateInput
    _min?: StageImageMinOrderByAggregateInput
    _sum?: StageImageSumOrderByAggregateInput
  }

  export type StageImageScalarWhereWithAggregatesInput = {
    AND?: StageImageScalarWhereWithAggregatesInput | StageImageScalarWhereWithAggregatesInput[]
    OR?: StageImageScalarWhereWithAggregatesInput[]
    NOT?: StageImageScalarWhereWithAggregatesInput | StageImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StageImage"> | string
    stageId?: StringWithAggregatesFilter<"StageImage"> | string
    type?: EnumStageImageTypeWithAggregatesFilter<"StageImage"> | $Enums.StageImageType
    url?: StringWithAggregatesFilter<"StageImage"> | string
    thumbnail?: StringNullableWithAggregatesFilter<"StageImage"> | string | null
    name?: StringNullableWithAggregatesFilter<"StageImage"> | string | null
    source?: StringNullableWithAggregatesFilter<"StageImage"> | string | null
    sortOrder?: IntWithAggregatesFilter<"StageImage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"StageImage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StageImage"> | Date | string
  }

  export type StageThresholdWhereInput = {
    AND?: StageThresholdWhereInput | StageThresholdWhereInput[]
    OR?: StageThresholdWhereInput[]
    NOT?: StageThresholdWhereInput | StageThresholdWhereInput[]
    id?: StringFilter<"StageThreshold"> | string
    stageId?: StringFilter<"StageThreshold"> | string
    indicatorId?: StringFilter<"StageThreshold"> | string
    operator?: EnumThresholdOperatorFilter<"StageThreshold"> | $Enums.ThresholdOperator
    value?: FloatFilter<"StageThreshold"> | number
    unit?: StringNullableFilter<"StageThreshold"> | string | null
    durationDays?: IntFilter<"StageThreshold"> | number
    createdAt?: DateTimeFilter<"StageThreshold"> | Date | string
    updatedAt?: DateTimeFilter<"StageThreshold"> | Date | string
    stage?: XOR<StageRelationFilter, StageWhereInput>
    indicator?: XOR<IndicatorRelationFilter, IndicatorWhereInput>
  }

  export type StageThresholdOrderByWithRelationInput = {
    id?: SortOrder
    stageId?: SortOrder
    indicatorId?: SortOrder
    operator?: SortOrder
    value?: SortOrder
    unit?: SortOrderInput | SortOrder
    durationDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stage?: StageOrderByWithRelationInput
    indicator?: IndicatorOrderByWithRelationInput
  }

  export type StageThresholdWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StageThresholdWhereInput | StageThresholdWhereInput[]
    OR?: StageThresholdWhereInput[]
    NOT?: StageThresholdWhereInput | StageThresholdWhereInput[]
    stageId?: StringFilter<"StageThreshold"> | string
    indicatorId?: StringFilter<"StageThreshold"> | string
    operator?: EnumThresholdOperatorFilter<"StageThreshold"> | $Enums.ThresholdOperator
    value?: FloatFilter<"StageThreshold"> | number
    unit?: StringNullableFilter<"StageThreshold"> | string | null
    durationDays?: IntFilter<"StageThreshold"> | number
    createdAt?: DateTimeFilter<"StageThreshold"> | Date | string
    updatedAt?: DateTimeFilter<"StageThreshold"> | Date | string
    stage?: XOR<StageRelationFilter, StageWhereInput>
    indicator?: XOR<IndicatorRelationFilter, IndicatorWhereInput>
  }, "id">

  export type StageThresholdOrderByWithAggregationInput = {
    id?: SortOrder
    stageId?: SortOrder
    indicatorId?: SortOrder
    operator?: SortOrder
    value?: SortOrder
    unit?: SortOrderInput | SortOrder
    durationDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StageThresholdCountOrderByAggregateInput
    _avg?: StageThresholdAvgOrderByAggregateInput
    _max?: StageThresholdMaxOrderByAggregateInput
    _min?: StageThresholdMinOrderByAggregateInput
    _sum?: StageThresholdSumOrderByAggregateInput
  }

  export type StageThresholdScalarWhereWithAggregatesInput = {
    AND?: StageThresholdScalarWhereWithAggregatesInput | StageThresholdScalarWhereWithAggregatesInput[]
    OR?: StageThresholdScalarWhereWithAggregatesInput[]
    NOT?: StageThresholdScalarWhereWithAggregatesInput | StageThresholdScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StageThreshold"> | string
    stageId?: StringWithAggregatesFilter<"StageThreshold"> | string
    indicatorId?: StringWithAggregatesFilter<"StageThreshold"> | string
    operator?: EnumThresholdOperatorWithAggregatesFilter<"StageThreshold"> | $Enums.ThresholdOperator
    value?: FloatWithAggregatesFilter<"StageThreshold"> | number
    unit?: StringNullableWithAggregatesFilter<"StageThreshold"> | string | null
    durationDays?: IntWithAggregatesFilter<"StageThreshold"> | number
    createdAt?: DateTimeWithAggregatesFilter<"StageThreshold"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StageThreshold"> | Date | string
  }

  export type GwlWhereInput = {
    AND?: GwlWhereInput | GwlWhereInput[]
    OR?: GwlWhereInput[]
    NOT?: GwlWhereInput | GwlWhereInput[]
    id?: IntFilter<"Gwl"> | number
    name?: StringFilter<"Gwl"> | string
    createdAt?: DateTimeFilter<"Gwl"> | Date | string
    updatedAt?: DateTimeFilter<"Gwl"> | Date | string
  }

  export type GwlOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GwlWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GwlWhereInput | GwlWhereInput[]
    OR?: GwlWhereInput[]
    NOT?: GwlWhereInput | GwlWhereInput[]
    name?: StringFilter<"Gwl"> | string
    createdAt?: DateTimeFilter<"Gwl"> | Date | string
    updatedAt?: DateTimeFilter<"Gwl"> | Date | string
  }, "id">

  export type GwlOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GwlCountOrderByAggregateInput
    _avg?: GwlAvgOrderByAggregateInput
    _max?: GwlMaxOrderByAggregateInput
    _min?: GwlMinOrderByAggregateInput
    _sum?: GwlSumOrderByAggregateInput
  }

  export type GwlScalarWhereWithAggregatesInput = {
    AND?: GwlScalarWhereWithAggregatesInput | GwlScalarWhereWithAggregatesInput[]
    OR?: GwlScalarWhereWithAggregatesInput[]
    NOT?: GwlScalarWhereWithAggregatesInput | GwlScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Gwl"> | number
    name?: StringWithAggregatesFilter<"Gwl"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Gwl"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Gwl"> | Date | string
  }

  export type CropCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    calendars?: CalendarCreateNestedManyWithoutCropInput
  }

  export type CropUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    calendars?: CalendarUncheckedCreateNestedManyWithoutCropInput
  }

  export type CropUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendars?: CalendarUpdateManyWithoutCropNestedInput
  }

  export type CropUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendars?: CalendarUncheckedUpdateManyWithoutCropNestedInput
  }

  export type CropCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CropUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicatorCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    indicators?: IndicatorCreateNestedManyWithoutCategoryInput
  }

  export type IndicatorCategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    indicators?: IndicatorUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type IndicatorCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicators?: IndicatorUpdateManyWithoutCategoryNestedInput
  }

  export type IndicatorCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicators?: IndicatorUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type IndicatorCategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndicatorCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicatorCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicatorCreateInput = {
    id?: string
    name: string
    unit: string
    description?: string | null
    source?: string
    defaultMin?: number | null
    defaultMax?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category: IndicatorCategoryCreateNestedOneWithoutIndicatorsInput
    thresholds?: StageThresholdCreateNestedManyWithoutIndicatorInput
    calendarIndicators?: CalendarIndicatorCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorUncheckedCreateInput = {
    id?: string
    categoryId: string
    name: string
    unit: string
    description?: string | null
    source?: string
    defaultMin?: number | null
    defaultMax?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    thresholds?: StageThresholdUncheckedCreateNestedManyWithoutIndicatorInput
    calendarIndicators?: CalendarIndicatorUncheckedCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    defaultMin?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultMax?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: IndicatorCategoryUpdateOneRequiredWithoutIndicatorsNestedInput
    thresholds?: StageThresholdUpdateManyWithoutIndicatorNestedInput
    calendarIndicators?: CalendarIndicatorUpdateManyWithoutIndicatorNestedInput
  }

  export type IndicatorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    defaultMin?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultMax?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thresholds?: StageThresholdUncheckedUpdateManyWithoutIndicatorNestedInput
    calendarIndicators?: CalendarIndicatorUncheckedUpdateManyWithoutIndicatorNestedInput
  }

  export type IndicatorCreateManyInput = {
    id?: string
    categoryId: string
    name: string
    unit: string
    description?: string | null
    source?: string
    defaultMin?: number | null
    defaultMax?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndicatorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    defaultMin?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultMax?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicatorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    defaultMin?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultMax?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneCreateInput = {
    id?: string
    zoneName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    zoneDistricts?: ZoneDistrictCreateNestedManyWithoutZoneInput
    calendarZones?: CalendarZoneCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateInput = {
    id?: string
    zoneName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    zoneDistricts?: ZoneDistrictUncheckedCreateNestedManyWithoutZoneInput
    calendarZones?: CalendarZoneUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zoneDistricts?: ZoneDistrictUpdateManyWithoutZoneNestedInput
    calendarZones?: CalendarZoneUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zoneDistricts?: ZoneDistrictUncheckedUpdateManyWithoutZoneNestedInput
    calendarZones?: CalendarZoneUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type ZoneCreateManyInput = {
    id?: string
    zoneName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityCreateInput = {
    id: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    districts?: DistrictCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateInput = {
    id: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    districts?: DistrictUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    districts?: DistrictUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    districts?: DistrictUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityCreateManyInput = {
    id: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CityUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DistrictCreateInput = {
    id: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutDistrictsInput
    zoneDistricts?: ZoneDistrictCreateNestedManyWithoutDistrictInput
    calendarZoneDistricts?: CalendarZoneDistrictCreateNestedManyWithoutDistrictInput
  }

  export type DistrictUncheckedCreateInput = {
    id: number
    name: string
    cityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    zoneDistricts?: ZoneDistrictUncheckedCreateNestedManyWithoutDistrictInput
    calendarZoneDistricts?: CalendarZoneDistrictUncheckedCreateNestedManyWithoutDistrictInput
  }

  export type DistrictUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutDistrictsNestedInput
    zoneDistricts?: ZoneDistrictUpdateManyWithoutDistrictNestedInput
    calendarZoneDistricts?: CalendarZoneDistrictUpdateManyWithoutDistrictNestedInput
  }

  export type DistrictUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zoneDistricts?: ZoneDistrictUncheckedUpdateManyWithoutDistrictNestedInput
    calendarZoneDistricts?: CalendarZoneDistrictUncheckedUpdateManyWithoutDistrictNestedInput
  }

  export type DistrictCreateManyInput = {
    id: number
    name: string
    cityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DistrictUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DistrictUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneDistrictCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    zone: ZoneCreateNestedOneWithoutZoneDistrictsInput
    district: DistrictCreateNestedOneWithoutZoneDistrictsInput
  }

  export type ZoneDistrictUncheckedCreateInput = {
    zoneId: string
    districtId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZoneDistrictUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: ZoneUpdateOneRequiredWithoutZoneDistrictsNestedInput
    district?: DistrictUpdateOneRequiredWithoutZoneDistrictsNestedInput
  }

  export type ZoneDistrictUncheckedUpdateInput = {
    zoneId?: StringFieldUpdateOperationsInput | string
    districtId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneDistrictCreateManyInput = {
    zoneId: string
    districtId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZoneDistrictUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneDistrictUncheckedUpdateManyInput = {
    zoneId?: StringFieldUpdateOperationsInput | string
    districtId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarCreateInput = {
    id?: string
    title: string
    creatorId: string
    creatorName: string
    isShared?: boolean
    isPublished?: boolean
    fileType?: $Enums.CalendarFileType
    allowCenterUse?: boolean
    publishedAt?: Date | string | null
    lastEditedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    crop: CropCreateNestedOneWithoutCalendarsInput
    stages?: StageCreateNestedManyWithoutCalendarInput
    calendarZones?: CalendarZoneCreateNestedManyWithoutCalendarInput
    calendarIndicators?: CalendarIndicatorCreateNestedManyWithoutCalendarInput
  }

  export type CalendarUncheckedCreateInput = {
    id?: string
    cropId: string
    title: string
    creatorId: string
    creatorName: string
    isShared?: boolean
    isPublished?: boolean
    fileType?: $Enums.CalendarFileType
    allowCenterUse?: boolean
    publishedAt?: Date | string | null
    lastEditedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    stages?: StageUncheckedCreateNestedManyWithoutCalendarInput
    calendarZones?: CalendarZoneUncheckedCreateNestedManyWithoutCalendarInput
    calendarIndicators?: CalendarIndicatorUncheckedCreateNestedManyWithoutCalendarInput
  }

  export type CalendarUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    creatorName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crop?: CropUpdateOneRequiredWithoutCalendarsNestedInput
    stages?: StageUpdateManyWithoutCalendarNestedInput
    calendarZones?: CalendarZoneUpdateManyWithoutCalendarNestedInput
    calendarIndicators?: CalendarIndicatorUpdateManyWithoutCalendarNestedInput
  }

  export type CalendarUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    creatorName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stages?: StageUncheckedUpdateManyWithoutCalendarNestedInput
    calendarZones?: CalendarZoneUncheckedUpdateManyWithoutCalendarNestedInput
    calendarIndicators?: CalendarIndicatorUncheckedUpdateManyWithoutCalendarNestedInput
  }

  export type CalendarCreateManyInput = {
    id?: string
    cropId: string
    title: string
    creatorId: string
    creatorName: string
    isShared?: boolean
    isPublished?: boolean
    fileType?: $Enums.CalendarFileType
    allowCenterUse?: boolean
    publishedAt?: Date | string | null
    lastEditedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    creatorName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    creatorName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarZoneCreateInput = {
    id?: string
    zoneName: string
    cityCount?: number
    districtCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    calendar: CalendarCreateNestedOneWithoutCalendarZonesInput
    zone: ZoneCreateNestedOneWithoutCalendarZonesInput
    districts?: CalendarZoneDistrictCreateNestedManyWithoutCalendarZoneInput
  }

  export type CalendarZoneUncheckedCreateInput = {
    id?: string
    calendarId: string
    zoneId: string
    zoneName: string
    cityCount?: number
    districtCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    districts?: CalendarZoneDistrictUncheckedCreateNestedManyWithoutCalendarZoneInput
  }

  export type CalendarZoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    cityCount?: IntFieldUpdateOperationsInput | number
    districtCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendar?: CalendarUpdateOneRequiredWithoutCalendarZonesNestedInput
    zone?: ZoneUpdateOneRequiredWithoutCalendarZonesNestedInput
    districts?: CalendarZoneDistrictUpdateManyWithoutCalendarZoneNestedInput
  }

  export type CalendarZoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    cityCount?: IntFieldUpdateOperationsInput | number
    districtCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    districts?: CalendarZoneDistrictUncheckedUpdateManyWithoutCalendarZoneNestedInput
  }

  export type CalendarZoneCreateManyInput = {
    id?: string
    calendarId: string
    zoneId: string
    zoneName: string
    cityCount?: number
    districtCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarZoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    cityCount?: IntFieldUpdateOperationsInput | number
    districtCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarZoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    cityCount?: IntFieldUpdateOperationsInput | number
    districtCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarZoneDistrictCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    calendarZone: CalendarZoneCreateNestedOneWithoutDistrictsInput
    district: DistrictCreateNestedOneWithoutCalendarZoneDistrictsInput
  }

  export type CalendarZoneDistrictUncheckedCreateInput = {
    calendarZoneId: string
    districtId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarZoneDistrictUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendarZone?: CalendarZoneUpdateOneRequiredWithoutDistrictsNestedInput
    district?: DistrictUpdateOneRequiredWithoutCalendarZoneDistrictsNestedInput
  }

  export type CalendarZoneDistrictUncheckedUpdateInput = {
    calendarZoneId?: StringFieldUpdateOperationsInput | string
    districtId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarZoneDistrictCreateManyInput = {
    calendarZoneId: string
    districtId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarZoneDistrictUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarZoneDistrictUncheckedUpdateManyInput = {
    calendarZoneId?: StringFieldUpdateOperationsInput | string
    districtId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarIndicatorCreateInput = {
    id?: string
    nameSnapshot: string
    createdAt?: Date | string
    updatedAt?: Date | string
    calendar: CalendarCreateNestedOneWithoutCalendarIndicatorsInput
    indicator: IndicatorCreateNestedOneWithoutCalendarIndicatorsInput
  }

  export type CalendarIndicatorUncheckedCreateInput = {
    id?: string
    calendarId: string
    indicatorId: string
    nameSnapshot: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarIndicatorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendar?: CalendarUpdateOneRequiredWithoutCalendarIndicatorsNestedInput
    indicator?: IndicatorUpdateOneRequiredWithoutCalendarIndicatorsNestedInput
  }

  export type CalendarIndicatorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    indicatorId?: StringFieldUpdateOperationsInput | string
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarIndicatorCreateManyInput = {
    id?: string
    calendarId: string
    indicatorId: string
    nameSnapshot: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarIndicatorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarIndicatorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    indicatorId?: StringFieldUpdateOperationsInput | string
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageCreateInput = {
    id?: string
    order?: number
    name: string
    description?: string | null
    status?: $Enums.StageStatus
    color?: string
    startTenDay?: $Enums.TenDay | null
    startMonth?: number | null
    endTenDay?: $Enums.TenDay | null
    endMonth?: number | null
    analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    calendar: CalendarCreateNestedOneWithoutStagesInput
    images?: StageImageCreateNestedManyWithoutStageInput
    thresholds?: StageThresholdCreateNestedManyWithoutStageInput
  }

  export type StageUncheckedCreateInput = {
    id?: string
    calendarId: string
    order?: number
    name: string
    description?: string | null
    status?: $Enums.StageStatus
    color?: string
    startTenDay?: $Enums.TenDay | null
    startMonth?: number | null
    endTenDay?: $Enums.TenDay | null
    endMonth?: number | null
    analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: StageImageUncheckedCreateNestedManyWithoutStageInput
    thresholds?: StageThresholdUncheckedCreateNestedManyWithoutStageInput
  }

  export type StageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStageStatusFieldUpdateOperationsInput | $Enums.StageStatus
    color?: StringFieldUpdateOperationsInput | string
    startTenDay?: NullableEnumTenDayFieldUpdateOperationsInput | $Enums.TenDay | null
    startMonth?: NullableIntFieldUpdateOperationsInput | number | null
    endTenDay?: NullableEnumTenDayFieldUpdateOperationsInput | $Enums.TenDay | null
    endMonth?: NullableIntFieldUpdateOperationsInput | number | null
    analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendar?: CalendarUpdateOneRequiredWithoutStagesNestedInput
    images?: StageImageUpdateManyWithoutStageNestedInput
    thresholds?: StageThresholdUpdateManyWithoutStageNestedInput
  }

  export type StageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStageStatusFieldUpdateOperationsInput | $Enums.StageStatus
    color?: StringFieldUpdateOperationsInput | string
    startTenDay?: NullableEnumTenDayFieldUpdateOperationsInput | $Enums.TenDay | null
    startMonth?: NullableIntFieldUpdateOperationsInput | number | null
    endTenDay?: NullableEnumTenDayFieldUpdateOperationsInput | $Enums.TenDay | null
    endMonth?: NullableIntFieldUpdateOperationsInput | number | null
    analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: StageImageUncheckedUpdateManyWithoutStageNestedInput
    thresholds?: StageThresholdUncheckedUpdateManyWithoutStageNestedInput
  }

  export type StageCreateManyInput = {
    id?: string
    calendarId: string
    order?: number
    name: string
    description?: string | null
    status?: $Enums.StageStatus
    color?: string
    startTenDay?: $Enums.TenDay | null
    startMonth?: number | null
    endTenDay?: $Enums.TenDay | null
    endMonth?: number | null
    analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStageStatusFieldUpdateOperationsInput | $Enums.StageStatus
    color?: StringFieldUpdateOperationsInput | string
    startTenDay?: NullableEnumTenDayFieldUpdateOperationsInput | $Enums.TenDay | null
    startMonth?: NullableIntFieldUpdateOperationsInput | number | null
    endTenDay?: NullableEnumTenDayFieldUpdateOperationsInput | $Enums.TenDay | null
    endMonth?: NullableIntFieldUpdateOperationsInput | number | null
    analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStageStatusFieldUpdateOperationsInput | $Enums.StageStatus
    color?: StringFieldUpdateOperationsInput | string
    startTenDay?: NullableEnumTenDayFieldUpdateOperationsInput | $Enums.TenDay | null
    startMonth?: NullableIntFieldUpdateOperationsInput | number | null
    endTenDay?: NullableEnumTenDayFieldUpdateOperationsInput | $Enums.TenDay | null
    endMonth?: NullableIntFieldUpdateOperationsInput | number | null
    analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageImageCreateInput = {
    id?: string
    type: $Enums.StageImageType
    url: string
    thumbnail?: string | null
    name?: string | null
    source?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    stage: StageCreateNestedOneWithoutImagesInput
  }

  export type StageImageUncheckedCreateInput = {
    id?: string
    stageId: string
    type: $Enums.StageImageType
    url: string
    thumbnail?: string | null
    name?: string | null
    source?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStageImageTypeFieldUpdateOperationsInput | $Enums.StageImageType
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stage?: StageUpdateOneRequiredWithoutImagesNestedInput
  }

  export type StageImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    type?: EnumStageImageTypeFieldUpdateOperationsInput | $Enums.StageImageType
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageImageCreateManyInput = {
    id?: string
    stageId: string
    type: $Enums.StageImageType
    url: string
    thumbnail?: string | null
    name?: string | null
    source?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStageImageTypeFieldUpdateOperationsInput | $Enums.StageImageType
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    type?: EnumStageImageTypeFieldUpdateOperationsInput | $Enums.StageImageType
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageThresholdCreateInput = {
    id?: string
    operator: $Enums.ThresholdOperator
    value: number
    unit?: string | null
    durationDays?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    stage: StageCreateNestedOneWithoutThresholdsInput
    indicator: IndicatorCreateNestedOneWithoutThresholdsInput
  }

  export type StageThresholdUncheckedCreateInput = {
    id?: string
    stageId: string
    indicatorId: string
    operator: $Enums.ThresholdOperator
    value: number
    unit?: string | null
    durationDays?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageThresholdUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    operator?: EnumThresholdOperatorFieldUpdateOperationsInput | $Enums.ThresholdOperator
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    durationDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stage?: StageUpdateOneRequiredWithoutThresholdsNestedInput
    indicator?: IndicatorUpdateOneRequiredWithoutThresholdsNestedInput
  }

  export type StageThresholdUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    indicatorId?: StringFieldUpdateOperationsInput | string
    operator?: EnumThresholdOperatorFieldUpdateOperationsInput | $Enums.ThresholdOperator
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    durationDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageThresholdCreateManyInput = {
    id?: string
    stageId: string
    indicatorId: string
    operator: $Enums.ThresholdOperator
    value: number
    unit?: string | null
    durationDays?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageThresholdUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    operator?: EnumThresholdOperatorFieldUpdateOperationsInput | $Enums.ThresholdOperator
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    durationDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageThresholdUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    indicatorId?: StringFieldUpdateOperationsInput | string
    operator?: EnumThresholdOperatorFieldUpdateOperationsInput | $Enums.ThresholdOperator
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    durationDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GwlCreateInput = {
    id: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GwlUncheckedCreateInput = {
    id: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GwlUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GwlUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GwlCreateManyInput = {
    id: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GwlUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GwlUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CalendarListRelationFilter = {
    every?: CalendarWhereInput
    some?: CalendarWhereInput
    none?: CalendarWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CalendarOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CropCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CropMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CropMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IndicatorListRelationFilter = {
    every?: IndicatorWhereInput
    some?: IndicatorWhereInput
    none?: IndicatorWhereInput
  }

  export type IndicatorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IndicatorCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndicatorCategoryAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type IndicatorCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndicatorCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndicatorCategorySumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IndicatorCategoryRelationFilter = {
    is?: IndicatorCategoryWhereInput
    isNot?: IndicatorCategoryWhereInput
  }

  export type StageThresholdListRelationFilter = {
    every?: StageThresholdWhereInput
    some?: StageThresholdWhereInput
    none?: StageThresholdWhereInput
  }

  export type CalendarIndicatorListRelationFilter = {
    every?: CalendarIndicatorWhereInput
    some?: CalendarIndicatorWhereInput
    none?: CalendarIndicatorWhereInput
  }

  export type StageThresholdOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CalendarIndicatorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IndicatorCountOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    description?: SortOrder
    source?: SortOrder
    defaultMin?: SortOrder
    defaultMax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndicatorAvgOrderByAggregateInput = {
    defaultMin?: SortOrder
    defaultMax?: SortOrder
  }

  export type IndicatorMaxOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    description?: SortOrder
    source?: SortOrder
    defaultMin?: SortOrder
    defaultMax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndicatorMinOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    description?: SortOrder
    source?: SortOrder
    defaultMin?: SortOrder
    defaultMax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndicatorSumOrderByAggregateInput = {
    defaultMin?: SortOrder
    defaultMax?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ZoneDistrictListRelationFilter = {
    every?: ZoneDistrictWhereInput
    some?: ZoneDistrictWhereInput
    none?: ZoneDistrictWhereInput
  }

  export type CalendarZoneListRelationFilter = {
    every?: CalendarZoneWhereInput
    some?: CalendarZoneWhereInput
    none?: CalendarZoneWhereInput
  }

  export type ZoneDistrictOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CalendarZoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ZoneCountOrderByAggregateInput = {
    id?: SortOrder
    zoneName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ZoneMaxOrderByAggregateInput = {
    id?: SortOrder
    zoneName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ZoneMinOrderByAggregateInput = {
    id?: SortOrder
    zoneName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DistrictListRelationFilter = {
    every?: DistrictWhereInput
    some?: DistrictWhereInput
    none?: DistrictWhereInput
  }

  export type DistrictOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CityAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CitySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CityRelationFilter = {
    is?: CityWhereInput
    isNot?: CityWhereInput
  }

  export type CalendarZoneDistrictListRelationFilter = {
    every?: CalendarZoneDistrictWhereInput
    some?: CalendarZoneDistrictWhereInput
    none?: CalendarZoneDistrictWhereInput
  }

  export type CalendarZoneDistrictOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DistrictCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DistrictAvgOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
  }

  export type DistrictMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DistrictMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DistrictSumOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
  }

  export type ZoneRelationFilter = {
    is?: ZoneWhereInput
    isNot?: ZoneWhereInput
  }

  export type DistrictRelationFilter = {
    is?: DistrictWhereInput
    isNot?: DistrictWhereInput
  }

  export type ZoneDistrictZoneIdDistrictIdCompoundUniqueInput = {
    zoneId: string
    districtId: number
  }

  export type ZoneDistrictCountOrderByAggregateInput = {
    zoneId?: SortOrder
    districtId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ZoneDistrictAvgOrderByAggregateInput = {
    districtId?: SortOrder
  }

  export type ZoneDistrictMaxOrderByAggregateInput = {
    zoneId?: SortOrder
    districtId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ZoneDistrictMinOrderByAggregateInput = {
    zoneId?: SortOrder
    districtId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ZoneDistrictSumOrderByAggregateInput = {
    districtId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumCalendarFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CalendarFileType | EnumCalendarFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CalendarFileType[] | ListEnumCalendarFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalendarFileType[] | ListEnumCalendarFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCalendarFileTypeFilter<$PrismaModel> | $Enums.CalendarFileType
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CropRelationFilter = {
    is?: CropWhereInput
    isNot?: CropWhereInput
  }

  export type StageListRelationFilter = {
    every?: StageWhereInput
    some?: StageWhereInput
    none?: StageWhereInput
  }

  export type StageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CalendarCountOrderByAggregateInput = {
    id?: SortOrder
    cropId?: SortOrder
    title?: SortOrder
    creatorId?: SortOrder
    creatorName?: SortOrder
    isShared?: SortOrder
    isPublished?: SortOrder
    fileType?: SortOrder
    allowCenterUse?: SortOrder
    publishedAt?: SortOrder
    lastEditedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarMaxOrderByAggregateInput = {
    id?: SortOrder
    cropId?: SortOrder
    title?: SortOrder
    creatorId?: SortOrder
    creatorName?: SortOrder
    isShared?: SortOrder
    isPublished?: SortOrder
    fileType?: SortOrder
    allowCenterUse?: SortOrder
    publishedAt?: SortOrder
    lastEditedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarMinOrderByAggregateInput = {
    id?: SortOrder
    cropId?: SortOrder
    title?: SortOrder
    creatorId?: SortOrder
    creatorName?: SortOrder
    isShared?: SortOrder
    isPublished?: SortOrder
    fileType?: SortOrder
    allowCenterUse?: SortOrder
    publishedAt?: SortOrder
    lastEditedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumCalendarFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CalendarFileType | EnumCalendarFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CalendarFileType[] | ListEnumCalendarFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalendarFileType[] | ListEnumCalendarFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCalendarFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.CalendarFileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCalendarFileTypeFilter<$PrismaModel>
    _max?: NestedEnumCalendarFileTypeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type CalendarRelationFilter = {
    is?: CalendarWhereInput
    isNot?: CalendarWhereInput
  }

  export type CalendarZoneCountOrderByAggregateInput = {
    id?: SortOrder
    calendarId?: SortOrder
    zoneId?: SortOrder
    zoneName?: SortOrder
    cityCount?: SortOrder
    districtCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarZoneAvgOrderByAggregateInput = {
    cityCount?: SortOrder
    districtCount?: SortOrder
  }

  export type CalendarZoneMaxOrderByAggregateInput = {
    id?: SortOrder
    calendarId?: SortOrder
    zoneId?: SortOrder
    zoneName?: SortOrder
    cityCount?: SortOrder
    districtCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarZoneMinOrderByAggregateInput = {
    id?: SortOrder
    calendarId?: SortOrder
    zoneId?: SortOrder
    zoneName?: SortOrder
    cityCount?: SortOrder
    districtCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarZoneSumOrderByAggregateInput = {
    cityCount?: SortOrder
    districtCount?: SortOrder
  }

  export type CalendarZoneRelationFilter = {
    is?: CalendarZoneWhereInput
    isNot?: CalendarZoneWhereInput
  }

  export type CalendarZoneDistrictCalendarZoneIdDistrictIdCompoundUniqueInput = {
    calendarZoneId: string
    districtId: number
  }

  export type CalendarZoneDistrictCountOrderByAggregateInput = {
    calendarZoneId?: SortOrder
    districtId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarZoneDistrictAvgOrderByAggregateInput = {
    districtId?: SortOrder
  }

  export type CalendarZoneDistrictMaxOrderByAggregateInput = {
    calendarZoneId?: SortOrder
    districtId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarZoneDistrictMinOrderByAggregateInput = {
    calendarZoneId?: SortOrder
    districtId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarZoneDistrictSumOrderByAggregateInput = {
    districtId?: SortOrder
  }

  export type IndicatorRelationFilter = {
    is?: IndicatorWhereInput
    isNot?: IndicatorWhereInput
  }

  export type CalendarIndicatorCountOrderByAggregateInput = {
    id?: SortOrder
    calendarId?: SortOrder
    indicatorId?: SortOrder
    nameSnapshot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarIndicatorMaxOrderByAggregateInput = {
    id?: SortOrder
    calendarId?: SortOrder
    indicatorId?: SortOrder
    nameSnapshot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarIndicatorMinOrderByAggregateInput = {
    id?: SortOrder
    calendarId?: SortOrder
    indicatorId?: SortOrder
    nameSnapshot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StageStatus | EnumStageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StageStatus[] | ListEnumStageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StageStatus[] | ListEnumStageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStageStatusFilter<$PrismaModel> | $Enums.StageStatus
  }

  export type EnumTenDayNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TenDay | EnumTenDayFieldRefInput<$PrismaModel> | null
    in?: $Enums.TenDay[] | ListEnumTenDayFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TenDay[] | ListEnumTenDayFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTenDayNullableFilter<$PrismaModel> | $Enums.TenDay | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StageImageListRelationFilter = {
    every?: StageImageWhereInput
    some?: StageImageWhereInput
    none?: StageImageWhereInput
  }

  export type StageImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StageCountOrderByAggregateInput = {
    id?: SortOrder
    calendarId?: SortOrder
    order?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    color?: SortOrder
    startTenDay?: SortOrder
    startMonth?: SortOrder
    endTenDay?: SortOrder
    endMonth?: SortOrder
    analysis?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StageAvgOrderByAggregateInput = {
    order?: SortOrder
    startMonth?: SortOrder
    endMonth?: SortOrder
  }

  export type StageMaxOrderByAggregateInput = {
    id?: SortOrder
    calendarId?: SortOrder
    order?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    color?: SortOrder
    startTenDay?: SortOrder
    startMonth?: SortOrder
    endTenDay?: SortOrder
    endMonth?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StageMinOrderByAggregateInput = {
    id?: SortOrder
    calendarId?: SortOrder
    order?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    color?: SortOrder
    startTenDay?: SortOrder
    startMonth?: SortOrder
    endTenDay?: SortOrder
    endMonth?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StageSumOrderByAggregateInput = {
    order?: SortOrder
    startMonth?: SortOrder
    endMonth?: SortOrder
  }

  export type EnumStageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StageStatus | EnumStageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StageStatus[] | ListEnumStageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StageStatus[] | ListEnumStageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStageStatusWithAggregatesFilter<$PrismaModel> | $Enums.StageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStageStatusFilter<$PrismaModel>
    _max?: NestedEnumStageStatusFilter<$PrismaModel>
  }

  export type EnumTenDayNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenDay | EnumTenDayFieldRefInput<$PrismaModel> | null
    in?: $Enums.TenDay[] | ListEnumTenDayFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TenDay[] | ListEnumTenDayFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTenDayNullableWithAggregatesFilter<$PrismaModel> | $Enums.TenDay | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTenDayNullableFilter<$PrismaModel>
    _max?: NestedEnumTenDayNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumStageImageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StageImageType | EnumStageImageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StageImageType[] | ListEnumStageImageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StageImageType[] | ListEnumStageImageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStageImageTypeFilter<$PrismaModel> | $Enums.StageImageType
  }

  export type StageRelationFilter = {
    is?: StageWhereInput
    isNot?: StageWhereInput
  }

  export type StageImageCountOrderByAggregateInput = {
    id?: SortOrder
    stageId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrder
    name?: SortOrder
    source?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StageImageAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type StageImageMaxOrderByAggregateInput = {
    id?: SortOrder
    stageId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrder
    name?: SortOrder
    source?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StageImageMinOrderByAggregateInput = {
    id?: SortOrder
    stageId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrder
    name?: SortOrder
    source?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StageImageSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type EnumStageImageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StageImageType | EnumStageImageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StageImageType[] | ListEnumStageImageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StageImageType[] | ListEnumStageImageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStageImageTypeWithAggregatesFilter<$PrismaModel> | $Enums.StageImageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStageImageTypeFilter<$PrismaModel>
    _max?: NestedEnumStageImageTypeFilter<$PrismaModel>
  }

  export type EnumThresholdOperatorFilter<$PrismaModel = never> = {
    equals?: $Enums.ThresholdOperator | EnumThresholdOperatorFieldRefInput<$PrismaModel>
    in?: $Enums.ThresholdOperator[] | ListEnumThresholdOperatorFieldRefInput<$PrismaModel>
    notIn?: $Enums.ThresholdOperator[] | ListEnumThresholdOperatorFieldRefInput<$PrismaModel>
    not?: NestedEnumThresholdOperatorFilter<$PrismaModel> | $Enums.ThresholdOperator
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type StageThresholdCountOrderByAggregateInput = {
    id?: SortOrder
    stageId?: SortOrder
    indicatorId?: SortOrder
    operator?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    durationDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StageThresholdAvgOrderByAggregateInput = {
    value?: SortOrder
    durationDays?: SortOrder
  }

  export type StageThresholdMaxOrderByAggregateInput = {
    id?: SortOrder
    stageId?: SortOrder
    indicatorId?: SortOrder
    operator?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    durationDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StageThresholdMinOrderByAggregateInput = {
    id?: SortOrder
    stageId?: SortOrder
    indicatorId?: SortOrder
    operator?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    durationDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StageThresholdSumOrderByAggregateInput = {
    value?: SortOrder
    durationDays?: SortOrder
  }

  export type EnumThresholdOperatorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ThresholdOperator | EnumThresholdOperatorFieldRefInput<$PrismaModel>
    in?: $Enums.ThresholdOperator[] | ListEnumThresholdOperatorFieldRefInput<$PrismaModel>
    notIn?: $Enums.ThresholdOperator[] | ListEnumThresholdOperatorFieldRefInput<$PrismaModel>
    not?: NestedEnumThresholdOperatorWithAggregatesFilter<$PrismaModel> | $Enums.ThresholdOperator
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumThresholdOperatorFilter<$PrismaModel>
    _max?: NestedEnumThresholdOperatorFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type GwlCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GwlAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GwlMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GwlMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GwlSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CalendarCreateNestedManyWithoutCropInput = {
    create?: XOR<CalendarCreateWithoutCropInput, CalendarUncheckedCreateWithoutCropInput> | CalendarCreateWithoutCropInput[] | CalendarUncheckedCreateWithoutCropInput[]
    connectOrCreate?: CalendarCreateOrConnectWithoutCropInput | CalendarCreateOrConnectWithoutCropInput[]
    createMany?: CalendarCreateManyCropInputEnvelope
    connect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
  }

  export type CalendarUncheckedCreateNestedManyWithoutCropInput = {
    create?: XOR<CalendarCreateWithoutCropInput, CalendarUncheckedCreateWithoutCropInput> | CalendarCreateWithoutCropInput[] | CalendarUncheckedCreateWithoutCropInput[]
    connectOrCreate?: CalendarCreateOrConnectWithoutCropInput | CalendarCreateOrConnectWithoutCropInput[]
    createMany?: CalendarCreateManyCropInputEnvelope
    connect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CalendarUpdateManyWithoutCropNestedInput = {
    create?: XOR<CalendarCreateWithoutCropInput, CalendarUncheckedCreateWithoutCropInput> | CalendarCreateWithoutCropInput[] | CalendarUncheckedCreateWithoutCropInput[]
    connectOrCreate?: CalendarCreateOrConnectWithoutCropInput | CalendarCreateOrConnectWithoutCropInput[]
    upsert?: CalendarUpsertWithWhereUniqueWithoutCropInput | CalendarUpsertWithWhereUniqueWithoutCropInput[]
    createMany?: CalendarCreateManyCropInputEnvelope
    set?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    disconnect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    delete?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    connect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    update?: CalendarUpdateWithWhereUniqueWithoutCropInput | CalendarUpdateWithWhereUniqueWithoutCropInput[]
    updateMany?: CalendarUpdateManyWithWhereWithoutCropInput | CalendarUpdateManyWithWhereWithoutCropInput[]
    deleteMany?: CalendarScalarWhereInput | CalendarScalarWhereInput[]
  }

  export type CalendarUncheckedUpdateManyWithoutCropNestedInput = {
    create?: XOR<CalendarCreateWithoutCropInput, CalendarUncheckedCreateWithoutCropInput> | CalendarCreateWithoutCropInput[] | CalendarUncheckedCreateWithoutCropInput[]
    connectOrCreate?: CalendarCreateOrConnectWithoutCropInput | CalendarCreateOrConnectWithoutCropInput[]
    upsert?: CalendarUpsertWithWhereUniqueWithoutCropInput | CalendarUpsertWithWhereUniqueWithoutCropInput[]
    createMany?: CalendarCreateManyCropInputEnvelope
    set?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    disconnect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    delete?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    connect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    update?: CalendarUpdateWithWhereUniqueWithoutCropInput | CalendarUpdateWithWhereUniqueWithoutCropInput[]
    updateMany?: CalendarUpdateManyWithWhereWithoutCropInput | CalendarUpdateManyWithWhereWithoutCropInput[]
    deleteMany?: CalendarScalarWhereInput | CalendarScalarWhereInput[]
  }

  export type IndicatorCreateNestedManyWithoutCategoryInput = {
    create?: XOR<IndicatorCreateWithoutCategoryInput, IndicatorUncheckedCreateWithoutCategoryInput> | IndicatorCreateWithoutCategoryInput[] | IndicatorUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: IndicatorCreateOrConnectWithoutCategoryInput | IndicatorCreateOrConnectWithoutCategoryInput[]
    createMany?: IndicatorCreateManyCategoryInputEnvelope
    connect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
  }

  export type IndicatorUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<IndicatorCreateWithoutCategoryInput, IndicatorUncheckedCreateWithoutCategoryInput> | IndicatorCreateWithoutCategoryInput[] | IndicatorUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: IndicatorCreateOrConnectWithoutCategoryInput | IndicatorCreateOrConnectWithoutCategoryInput[]
    createMany?: IndicatorCreateManyCategoryInputEnvelope
    connect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IndicatorUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<IndicatorCreateWithoutCategoryInput, IndicatorUncheckedCreateWithoutCategoryInput> | IndicatorCreateWithoutCategoryInput[] | IndicatorUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: IndicatorCreateOrConnectWithoutCategoryInput | IndicatorCreateOrConnectWithoutCategoryInput[]
    upsert?: IndicatorUpsertWithWhereUniqueWithoutCategoryInput | IndicatorUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: IndicatorCreateManyCategoryInputEnvelope
    set?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    disconnect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    delete?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    connect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    update?: IndicatorUpdateWithWhereUniqueWithoutCategoryInput | IndicatorUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: IndicatorUpdateManyWithWhereWithoutCategoryInput | IndicatorUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: IndicatorScalarWhereInput | IndicatorScalarWhereInput[]
  }

  export type IndicatorUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<IndicatorCreateWithoutCategoryInput, IndicatorUncheckedCreateWithoutCategoryInput> | IndicatorCreateWithoutCategoryInput[] | IndicatorUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: IndicatorCreateOrConnectWithoutCategoryInput | IndicatorCreateOrConnectWithoutCategoryInput[]
    upsert?: IndicatorUpsertWithWhereUniqueWithoutCategoryInput | IndicatorUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: IndicatorCreateManyCategoryInputEnvelope
    set?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    disconnect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    delete?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    connect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    update?: IndicatorUpdateWithWhereUniqueWithoutCategoryInput | IndicatorUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: IndicatorUpdateManyWithWhereWithoutCategoryInput | IndicatorUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: IndicatorScalarWhereInput | IndicatorScalarWhereInput[]
  }

  export type IndicatorCategoryCreateNestedOneWithoutIndicatorsInput = {
    create?: XOR<IndicatorCategoryCreateWithoutIndicatorsInput, IndicatorCategoryUncheckedCreateWithoutIndicatorsInput>
    connectOrCreate?: IndicatorCategoryCreateOrConnectWithoutIndicatorsInput
    connect?: IndicatorCategoryWhereUniqueInput
  }

  export type StageThresholdCreateNestedManyWithoutIndicatorInput = {
    create?: XOR<StageThresholdCreateWithoutIndicatorInput, StageThresholdUncheckedCreateWithoutIndicatorInput> | StageThresholdCreateWithoutIndicatorInput[] | StageThresholdUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: StageThresholdCreateOrConnectWithoutIndicatorInput | StageThresholdCreateOrConnectWithoutIndicatorInput[]
    createMany?: StageThresholdCreateManyIndicatorInputEnvelope
    connect?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
  }

  export type CalendarIndicatorCreateNestedManyWithoutIndicatorInput = {
    create?: XOR<CalendarIndicatorCreateWithoutIndicatorInput, CalendarIndicatorUncheckedCreateWithoutIndicatorInput> | CalendarIndicatorCreateWithoutIndicatorInput[] | CalendarIndicatorUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: CalendarIndicatorCreateOrConnectWithoutIndicatorInput | CalendarIndicatorCreateOrConnectWithoutIndicatorInput[]
    createMany?: CalendarIndicatorCreateManyIndicatorInputEnvelope
    connect?: CalendarIndicatorWhereUniqueInput | CalendarIndicatorWhereUniqueInput[]
  }

  export type StageThresholdUncheckedCreateNestedManyWithoutIndicatorInput = {
    create?: XOR<StageThresholdCreateWithoutIndicatorInput, StageThresholdUncheckedCreateWithoutIndicatorInput> | StageThresholdCreateWithoutIndicatorInput[] | StageThresholdUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: StageThresholdCreateOrConnectWithoutIndicatorInput | StageThresholdCreateOrConnectWithoutIndicatorInput[]
    createMany?: StageThresholdCreateManyIndicatorInputEnvelope
    connect?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
  }

  export type CalendarIndicatorUncheckedCreateNestedManyWithoutIndicatorInput = {
    create?: XOR<CalendarIndicatorCreateWithoutIndicatorInput, CalendarIndicatorUncheckedCreateWithoutIndicatorInput> | CalendarIndicatorCreateWithoutIndicatorInput[] | CalendarIndicatorUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: CalendarIndicatorCreateOrConnectWithoutIndicatorInput | CalendarIndicatorCreateOrConnectWithoutIndicatorInput[]
    createMany?: CalendarIndicatorCreateManyIndicatorInputEnvelope
    connect?: CalendarIndicatorWhereUniqueInput | CalendarIndicatorWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IndicatorCategoryUpdateOneRequiredWithoutIndicatorsNestedInput = {
    create?: XOR<IndicatorCategoryCreateWithoutIndicatorsInput, IndicatorCategoryUncheckedCreateWithoutIndicatorsInput>
    connectOrCreate?: IndicatorCategoryCreateOrConnectWithoutIndicatorsInput
    upsert?: IndicatorCategoryUpsertWithoutIndicatorsInput
    connect?: IndicatorCategoryWhereUniqueInput
    update?: XOR<XOR<IndicatorCategoryUpdateToOneWithWhereWithoutIndicatorsInput, IndicatorCategoryUpdateWithoutIndicatorsInput>, IndicatorCategoryUncheckedUpdateWithoutIndicatorsInput>
  }

  export type StageThresholdUpdateManyWithoutIndicatorNestedInput = {
    create?: XOR<StageThresholdCreateWithoutIndicatorInput, StageThresholdUncheckedCreateWithoutIndicatorInput> | StageThresholdCreateWithoutIndicatorInput[] | StageThresholdUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: StageThresholdCreateOrConnectWithoutIndicatorInput | StageThresholdCreateOrConnectWithoutIndicatorInput[]
    upsert?: StageThresholdUpsertWithWhereUniqueWithoutIndicatorInput | StageThresholdUpsertWithWhereUniqueWithoutIndicatorInput[]
    createMany?: StageThresholdCreateManyIndicatorInputEnvelope
    set?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    disconnect?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    delete?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    connect?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    update?: StageThresholdUpdateWithWhereUniqueWithoutIndicatorInput | StageThresholdUpdateWithWhereUniqueWithoutIndicatorInput[]
    updateMany?: StageThresholdUpdateManyWithWhereWithoutIndicatorInput | StageThresholdUpdateManyWithWhereWithoutIndicatorInput[]
    deleteMany?: StageThresholdScalarWhereInput | StageThresholdScalarWhereInput[]
  }

  export type CalendarIndicatorUpdateManyWithoutIndicatorNestedInput = {
    create?: XOR<CalendarIndicatorCreateWithoutIndicatorInput, CalendarIndicatorUncheckedCreateWithoutIndicatorInput> | CalendarIndicatorCreateWithoutIndicatorInput[] | CalendarIndicatorUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: CalendarIndicatorCreateOrConnectWithoutIndicatorInput | CalendarIndicatorCreateOrConnectWithoutIndicatorInput[]
    upsert?: CalendarIndicatorUpsertWithWhereUniqueWithoutIndicatorInput | CalendarIndicatorUpsertWithWhereUniqueWithoutIndicatorInput[]
    createMany?: CalendarIndicatorCreateManyIndicatorInputEnvelope
    set?: CalendarIndicatorWhereUniqueInput | CalendarIndicatorWhereUniqueInput[]
    disconnect?: CalendarIndicatorWhereUniqueInput | CalendarIndicatorWhereUniqueInput[]
    delete?: CalendarIndicatorWhereUniqueInput | CalendarIndicatorWhereUniqueInput[]
    connect?: CalendarIndicatorWhereUniqueInput | CalendarIndicatorWhereUniqueInput[]
    update?: CalendarIndicatorUpdateWithWhereUniqueWithoutIndicatorInput | CalendarIndicatorUpdateWithWhereUniqueWithoutIndicatorInput[]
    updateMany?: CalendarIndicatorUpdateManyWithWhereWithoutIndicatorInput | CalendarIndicatorUpdateManyWithWhereWithoutIndicatorInput[]
    deleteMany?: CalendarIndicatorScalarWhereInput | CalendarIndicatorScalarWhereInput[]
  }

  export type StageThresholdUncheckedUpdateManyWithoutIndicatorNestedInput = {
    create?: XOR<StageThresholdCreateWithoutIndicatorInput, StageThresholdUncheckedCreateWithoutIndicatorInput> | StageThresholdCreateWithoutIndicatorInput[] | StageThresholdUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: StageThresholdCreateOrConnectWithoutIndicatorInput | StageThresholdCreateOrConnectWithoutIndicatorInput[]
    upsert?: StageThresholdUpsertWithWhereUniqueWithoutIndicatorInput | StageThresholdUpsertWithWhereUniqueWithoutIndicatorInput[]
    createMany?: StageThresholdCreateManyIndicatorInputEnvelope
    set?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    disconnect?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    delete?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    connect?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    update?: StageThresholdUpdateWithWhereUniqueWithoutIndicatorInput | StageThresholdUpdateWithWhereUniqueWithoutIndicatorInput[]
    updateMany?: StageThresholdUpdateManyWithWhereWithoutIndicatorInput | StageThresholdUpdateManyWithWhereWithoutIndicatorInput[]
    deleteMany?: StageThresholdScalarWhereInput | StageThresholdScalarWhereInput[]
  }

  export type CalendarIndicatorUncheckedUpdateManyWithoutIndicatorNestedInput = {
    create?: XOR<CalendarIndicatorCreateWithoutIndicatorInput, CalendarIndicatorUncheckedCreateWithoutIndicatorInput> | CalendarIndicatorCreateWithoutIndicatorInput[] | CalendarIndicatorUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: CalendarIndicatorCreateOrConnectWithoutIndicatorInput | CalendarIndicatorCreateOrConnectWithoutIndicatorInput[]
    upsert?: CalendarIndicatorUpsertWithWhereUniqueWithoutIndicatorInput | CalendarIndicatorUpsertWithWhereUniqueWithoutIndicatorInput[]
    createMany?: CalendarIndicatorCreateManyIndicatorInputEnvelope
    set?: CalendarIndicatorWhereUniqueInput | CalendarIndicatorWhereUniqueInput[]
    disconnect?: CalendarIndicatorWhereUniqueInput | CalendarIndicatorWhereUniqueInput[]
    delete?: CalendarIndicatorWhereUniqueInput | CalendarIndicatorWhereUniqueInput[]
    connect?: CalendarIndicatorWhereUniqueInput | CalendarIndicatorWhereUniqueInput[]
    update?: CalendarIndicatorUpdateWithWhereUniqueWithoutIndicatorInput | CalendarIndicatorUpdateWithWhereUniqueWithoutIndicatorInput[]
    updateMany?: CalendarIndicatorUpdateManyWithWhereWithoutIndicatorInput | CalendarIndicatorUpdateManyWithWhereWithoutIndicatorInput[]
    deleteMany?: CalendarIndicatorScalarWhereInput | CalendarIndicatorScalarWhereInput[]
  }

  export type ZoneDistrictCreateNestedManyWithoutZoneInput = {
    create?: XOR<ZoneDistrictCreateWithoutZoneInput, ZoneDistrictUncheckedCreateWithoutZoneInput> | ZoneDistrictCreateWithoutZoneInput[] | ZoneDistrictUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: ZoneDistrictCreateOrConnectWithoutZoneInput | ZoneDistrictCreateOrConnectWithoutZoneInput[]
    createMany?: ZoneDistrictCreateManyZoneInputEnvelope
    connect?: ZoneDistrictWhereUniqueInput | ZoneDistrictWhereUniqueInput[]
  }

  export type CalendarZoneCreateNestedManyWithoutZoneInput = {
    create?: XOR<CalendarZoneCreateWithoutZoneInput, CalendarZoneUncheckedCreateWithoutZoneInput> | CalendarZoneCreateWithoutZoneInput[] | CalendarZoneUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: CalendarZoneCreateOrConnectWithoutZoneInput | CalendarZoneCreateOrConnectWithoutZoneInput[]
    createMany?: CalendarZoneCreateManyZoneInputEnvelope
    connect?: CalendarZoneWhereUniqueInput | CalendarZoneWhereUniqueInput[]
  }

  export type ZoneDistrictUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<ZoneDistrictCreateWithoutZoneInput, ZoneDistrictUncheckedCreateWithoutZoneInput> | ZoneDistrictCreateWithoutZoneInput[] | ZoneDistrictUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: ZoneDistrictCreateOrConnectWithoutZoneInput | ZoneDistrictCreateOrConnectWithoutZoneInput[]
    createMany?: ZoneDistrictCreateManyZoneInputEnvelope
    connect?: ZoneDistrictWhereUniqueInput | ZoneDistrictWhereUniqueInput[]
  }

  export type CalendarZoneUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<CalendarZoneCreateWithoutZoneInput, CalendarZoneUncheckedCreateWithoutZoneInput> | CalendarZoneCreateWithoutZoneInput[] | CalendarZoneUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: CalendarZoneCreateOrConnectWithoutZoneInput | CalendarZoneCreateOrConnectWithoutZoneInput[]
    createMany?: CalendarZoneCreateManyZoneInputEnvelope
    connect?: CalendarZoneWhereUniqueInput | CalendarZoneWhereUniqueInput[]
  }

  export type ZoneDistrictUpdateManyWithoutZoneNestedInput = {
    create?: XOR<ZoneDistrictCreateWithoutZoneInput, ZoneDistrictUncheckedCreateWithoutZoneInput> | ZoneDistrictCreateWithoutZoneInput[] | ZoneDistrictUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: ZoneDistrictCreateOrConnectWithoutZoneInput | ZoneDistrictCreateOrConnectWithoutZoneInput[]
    upsert?: ZoneDistrictUpsertWithWhereUniqueWithoutZoneInput | ZoneDistrictUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: ZoneDistrictCreateManyZoneInputEnvelope
    set?: ZoneDistrictWhereUniqueInput | ZoneDistrictWhereUniqueInput[]
    disconnect?: ZoneDistrictWhereUniqueInput | ZoneDistrictWhereUniqueInput[]
    delete?: ZoneDistrictWhereUniqueInput | ZoneDistrictWhereUniqueInput[]
    connect?: ZoneDistrictWhereUniqueInput | ZoneDistrictWhereUniqueInput[]
    update?: ZoneDistrictUpdateWithWhereUniqueWithoutZoneInput | ZoneDistrictUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: ZoneDistrictUpdateManyWithWhereWithoutZoneInput | ZoneDistrictUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: ZoneDistrictScalarWhereInput | ZoneDistrictScalarWhereInput[]
  }

  export type CalendarZoneUpdateManyWithoutZoneNestedInput = {
    create?: XOR<CalendarZoneCreateWithoutZoneInput, CalendarZoneUncheckedCreateWithoutZoneInput> | CalendarZoneCreateWithoutZoneInput[] | CalendarZoneUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: CalendarZoneCreateOrConnectWithoutZoneInput | CalendarZoneCreateOrConnectWithoutZoneInput[]
    upsert?: CalendarZoneUpsertWithWhereUniqueWithoutZoneInput | CalendarZoneUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: CalendarZoneCreateManyZoneInputEnvelope
    set?: CalendarZoneWhereUniqueInput | CalendarZoneWhereUniqueInput[]
    disconnect?: CalendarZoneWhereUniqueInput | CalendarZoneWhereUniqueInput[]
    delete?: CalendarZoneWhereUniqueInput | CalendarZoneWhereUniqueInput[]
    connect?: CalendarZoneWhereUniqueInput | CalendarZoneWhereUniqueInput[]
    update?: CalendarZoneUpdateWithWhereUniqueWithoutZoneInput | CalendarZoneUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: CalendarZoneUpdateManyWithWhereWithoutZoneInput | CalendarZoneUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: CalendarZoneScalarWhereInput | CalendarZoneScalarWhereInput[]
  }

  export type ZoneDistrictUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<ZoneDistrictCreateWithoutZoneInput, ZoneDistrictUncheckedCreateWithoutZoneInput> | ZoneDistrictCreateWithoutZoneInput[] | ZoneDistrictUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: ZoneDistrictCreateOrConnectWithoutZoneInput | ZoneDistrictCreateOrConnectWithoutZoneInput[]
    upsert?: ZoneDistrictUpsertWithWhereUniqueWithoutZoneInput | ZoneDistrictUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: ZoneDistrictCreateManyZoneInputEnvelope
    set?: ZoneDistrictWhereUniqueInput | ZoneDistrictWhereUniqueInput[]
    disconnect?: ZoneDistrictWhereUniqueInput | ZoneDistrictWhereUniqueInput[]
    delete?: ZoneDistrictWhereUniqueInput | ZoneDistrictWhereUniqueInput[]
    connect?: ZoneDistrictWhereUniqueInput | ZoneDistrictWhereUniqueInput[]
    update?: ZoneDistrictUpdateWithWhereUniqueWithoutZoneInput | ZoneDistrictUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: ZoneDistrictUpdateManyWithWhereWithoutZoneInput | ZoneDistrictUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: ZoneDistrictScalarWhereInput | ZoneDistrictScalarWhereInput[]
  }

  export type CalendarZoneUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<CalendarZoneCreateWithoutZoneInput, CalendarZoneUncheckedCreateWithoutZoneInput> | CalendarZoneCreateWithoutZoneInput[] | CalendarZoneUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: CalendarZoneCreateOrConnectWithoutZoneInput | CalendarZoneCreateOrConnectWithoutZoneInput[]
    upsert?: CalendarZoneUpsertWithWhereUniqueWithoutZoneInput | CalendarZoneUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: CalendarZoneCreateManyZoneInputEnvelope
    set?: CalendarZoneWhereUniqueInput | CalendarZoneWhereUniqueInput[]
    disconnect?: CalendarZoneWhereUniqueInput | CalendarZoneWhereUniqueInput[]
    delete?: CalendarZoneWhereUniqueInput | CalendarZoneWhereUniqueInput[]
    connect?: CalendarZoneWhereUniqueInput | CalendarZoneWhereUniqueInput[]
    update?: CalendarZoneUpdateWithWhereUniqueWithoutZoneInput | CalendarZoneUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: CalendarZoneUpdateManyWithWhereWithoutZoneInput | CalendarZoneUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: CalendarZoneScalarWhereInput | CalendarZoneScalarWhereInput[]
  }

  export type DistrictCreateNestedManyWithoutCityInput = {
    create?: XOR<DistrictCreateWithoutCityInput, DistrictUncheckedCreateWithoutCityInput> | DistrictCreateWithoutCityInput[] | DistrictUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DistrictCreateOrConnectWithoutCityInput | DistrictCreateOrConnectWithoutCityInput[]
    createMany?: DistrictCreateManyCityInputEnvelope
    connect?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
  }

  export type DistrictUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<DistrictCreateWithoutCityInput, DistrictUncheckedCreateWithoutCityInput> | DistrictCreateWithoutCityInput[] | DistrictUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DistrictCreateOrConnectWithoutCityInput | DistrictCreateOrConnectWithoutCityInput[]
    createMany?: DistrictCreateManyCityInputEnvelope
    connect?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
  }

  export type DistrictUpdateManyWithoutCityNestedInput = {
    create?: XOR<DistrictCreateWithoutCityInput, DistrictUncheckedCreateWithoutCityInput> | DistrictCreateWithoutCityInput[] | DistrictUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DistrictCreateOrConnectWithoutCityInput | DistrictCreateOrConnectWithoutCityInput[]
    upsert?: DistrictUpsertWithWhereUniqueWithoutCityInput | DistrictUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: DistrictCreateManyCityInputEnvelope
    set?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
    disconnect?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
    delete?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
    connect?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
    update?: DistrictUpdateWithWhereUniqueWithoutCityInput | DistrictUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: DistrictUpdateManyWithWhereWithoutCityInput | DistrictUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: DistrictScalarWhereInput | DistrictScalarWhereInput[]
  }

  export type DistrictUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<DistrictCreateWithoutCityInput, DistrictUncheckedCreateWithoutCityInput> | DistrictCreateWithoutCityInput[] | DistrictUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DistrictCreateOrConnectWithoutCityInput | DistrictCreateOrConnectWithoutCityInput[]
    upsert?: DistrictUpsertWithWhereUniqueWithoutCityInput | DistrictUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: DistrictCreateManyCityInputEnvelope
    set?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
    disconnect?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
    delete?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
    connect?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
    update?: DistrictUpdateWithWhereUniqueWithoutCityInput | DistrictUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: DistrictUpdateManyWithWhereWithoutCityInput | DistrictUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: DistrictScalarWhereInput | DistrictScalarWhereInput[]
  }

  export type CityCreateNestedOneWithoutDistrictsInput = {
    create?: XOR<CityCreateWithoutDistrictsInput, CityUncheckedCreateWithoutDistrictsInput>
    connectOrCreate?: CityCreateOrConnectWithoutDistrictsInput
    connect?: CityWhereUniqueInput
  }

  export type ZoneDistrictCreateNestedManyWithoutDistrictInput = {
    create?: XOR<ZoneDistrictCreateWithoutDistrictInput, ZoneDistrictUncheckedCreateWithoutDistrictInput> | ZoneDistrictCreateWithoutDistrictInput[] | ZoneDistrictUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: ZoneDistrictCreateOrConnectWithoutDistrictInput | ZoneDistrictCreateOrConnectWithoutDistrictInput[]
    createMany?: ZoneDistrictCreateManyDistrictInputEnvelope
    connect?: ZoneDistrictWhereUniqueInput | ZoneDistrictWhereUniqueInput[]
  }

  export type CalendarZoneDistrictCreateNestedManyWithoutDistrictInput = {
    create?: XOR<CalendarZoneDistrictCreateWithoutDistrictInput, CalendarZoneDistrictUncheckedCreateWithoutDistrictInput> | CalendarZoneDistrictCreateWithoutDistrictInput[] | CalendarZoneDistrictUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: CalendarZoneDistrictCreateOrConnectWithoutDistrictInput | CalendarZoneDistrictCreateOrConnectWithoutDistrictInput[]
    createMany?: CalendarZoneDistrictCreateManyDistrictInputEnvelope
    connect?: CalendarZoneDistrictWhereUniqueInput | CalendarZoneDistrictWhereUniqueInput[]
  }

  export type ZoneDistrictUncheckedCreateNestedManyWithoutDistrictInput = {
    create?: XOR<ZoneDistrictCreateWithoutDistrictInput, ZoneDistrictUncheckedCreateWithoutDistrictInput> | ZoneDistrictCreateWithoutDistrictInput[] | ZoneDistrictUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: ZoneDistrictCreateOrConnectWithoutDistrictInput | ZoneDistrictCreateOrConnectWithoutDistrictInput[]
    createMany?: ZoneDistrictCreateManyDistrictInputEnvelope
    connect?: ZoneDistrictWhereUniqueInput | ZoneDistrictWhereUniqueInput[]
  }

  export type CalendarZoneDistrictUncheckedCreateNestedManyWithoutDistrictInput = {
    create?: XOR<CalendarZoneDistrictCreateWithoutDistrictInput, CalendarZoneDistrictUncheckedCreateWithoutDistrictInput> | CalendarZoneDistrictCreateWithoutDistrictInput[] | CalendarZoneDistrictUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: CalendarZoneDistrictCreateOrConnectWithoutDistrictInput | CalendarZoneDistrictCreateOrConnectWithoutDistrictInput[]
    createMany?: CalendarZoneDistrictCreateManyDistrictInputEnvelope
    connect?: CalendarZoneDistrictWhereUniqueInput | CalendarZoneDistrictWhereUniqueInput[]
  }

  export type CityUpdateOneRequiredWithoutDistrictsNestedInput = {
    create?: XOR<CityCreateWithoutDistrictsInput, CityUncheckedCreateWithoutDistrictsInput>
    connectOrCreate?: CityCreateOrConnectWithoutDistrictsInput
    upsert?: CityUpsertWithoutDistrictsInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutDistrictsInput, CityUpdateWithoutDistrictsInput>, CityUncheckedUpdateWithoutDistrictsInput>
  }

  export type ZoneDistrictUpdateManyWithoutDistrictNestedInput = {
    create?: XOR<ZoneDistrictCreateWithoutDistrictInput, ZoneDistrictUncheckedCreateWithoutDistrictInput> | ZoneDistrictCreateWithoutDistrictInput[] | ZoneDistrictUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: ZoneDistrictCreateOrConnectWithoutDistrictInput | ZoneDistrictCreateOrConnectWithoutDistrictInput[]
    upsert?: ZoneDistrictUpsertWithWhereUniqueWithoutDistrictInput | ZoneDistrictUpsertWithWhereUniqueWithoutDistrictInput[]
    createMany?: ZoneDistrictCreateManyDistrictInputEnvelope
    set?: ZoneDistrictWhereUniqueInput | ZoneDistrictWhereUniqueInput[]
    disconnect?: ZoneDistrictWhereUniqueInput | ZoneDistrictWhereUniqueInput[]
    delete?: ZoneDistrictWhereUniqueInput | ZoneDistrictWhereUniqueInput[]
    connect?: ZoneDistrictWhereUniqueInput | ZoneDistrictWhereUniqueInput[]
    update?: ZoneDistrictUpdateWithWhereUniqueWithoutDistrictInput | ZoneDistrictUpdateWithWhereUniqueWithoutDistrictInput[]
    updateMany?: ZoneDistrictUpdateManyWithWhereWithoutDistrictInput | ZoneDistrictUpdateManyWithWhereWithoutDistrictInput[]
    deleteMany?: ZoneDistrictScalarWhereInput | ZoneDistrictScalarWhereInput[]
  }

  export type CalendarZoneDistrictUpdateManyWithoutDistrictNestedInput = {
    create?: XOR<CalendarZoneDistrictCreateWithoutDistrictInput, CalendarZoneDistrictUncheckedCreateWithoutDistrictInput> | CalendarZoneDistrictCreateWithoutDistrictInput[] | CalendarZoneDistrictUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: CalendarZoneDistrictCreateOrConnectWithoutDistrictInput | CalendarZoneDistrictCreateOrConnectWithoutDistrictInput[]
    upsert?: CalendarZoneDistrictUpsertWithWhereUniqueWithoutDistrictInput | CalendarZoneDistrictUpsertWithWhereUniqueWithoutDistrictInput[]
    createMany?: CalendarZoneDistrictCreateManyDistrictInputEnvelope
    set?: CalendarZoneDistrictWhereUniqueInput | CalendarZoneDistrictWhereUniqueInput[]
    disconnect?: CalendarZoneDistrictWhereUniqueInput | CalendarZoneDistrictWhereUniqueInput[]
    delete?: CalendarZoneDistrictWhereUniqueInput | CalendarZoneDistrictWhereUniqueInput[]
    connect?: CalendarZoneDistrictWhereUniqueInput | CalendarZoneDistrictWhereUniqueInput[]
    update?: CalendarZoneDistrictUpdateWithWhereUniqueWithoutDistrictInput | CalendarZoneDistrictUpdateWithWhereUniqueWithoutDistrictInput[]
    updateMany?: CalendarZoneDistrictUpdateManyWithWhereWithoutDistrictInput | CalendarZoneDistrictUpdateManyWithWhereWithoutDistrictInput[]
    deleteMany?: CalendarZoneDistrictScalarWhereInput | CalendarZoneDistrictScalarWhereInput[]
  }

  export type ZoneDistrictUncheckedUpdateManyWithoutDistrictNestedInput = {
    create?: XOR<ZoneDistrictCreateWithoutDistrictInput, ZoneDistrictUncheckedCreateWithoutDistrictInput> | ZoneDistrictCreateWithoutDistrictInput[] | ZoneDistrictUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: ZoneDistrictCreateOrConnectWithoutDistrictInput | ZoneDistrictCreateOrConnectWithoutDistrictInput[]
    upsert?: ZoneDistrictUpsertWithWhereUniqueWithoutDistrictInput | ZoneDistrictUpsertWithWhereUniqueWithoutDistrictInput[]
    createMany?: ZoneDistrictCreateManyDistrictInputEnvelope
    set?: ZoneDistrictWhereUniqueInput | ZoneDistrictWhereUniqueInput[]
    disconnect?: ZoneDistrictWhereUniqueInput | ZoneDistrictWhereUniqueInput[]
    delete?: ZoneDistrictWhereUniqueInput | ZoneDistrictWhereUniqueInput[]
    connect?: ZoneDistrictWhereUniqueInput | ZoneDistrictWhereUniqueInput[]
    update?: ZoneDistrictUpdateWithWhereUniqueWithoutDistrictInput | ZoneDistrictUpdateWithWhereUniqueWithoutDistrictInput[]
    updateMany?: ZoneDistrictUpdateManyWithWhereWithoutDistrictInput | ZoneDistrictUpdateManyWithWhereWithoutDistrictInput[]
    deleteMany?: ZoneDistrictScalarWhereInput | ZoneDistrictScalarWhereInput[]
  }

  export type CalendarZoneDistrictUncheckedUpdateManyWithoutDistrictNestedInput = {
    create?: XOR<CalendarZoneDistrictCreateWithoutDistrictInput, CalendarZoneDistrictUncheckedCreateWithoutDistrictInput> | CalendarZoneDistrictCreateWithoutDistrictInput[] | CalendarZoneDistrictUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: CalendarZoneDistrictCreateOrConnectWithoutDistrictInput | CalendarZoneDistrictCreateOrConnectWithoutDistrictInput[]
    upsert?: CalendarZoneDistrictUpsertWithWhereUniqueWithoutDistrictInput | CalendarZoneDistrictUpsertWithWhereUniqueWithoutDistrictInput[]
    createMany?: CalendarZoneDistrictCreateManyDistrictInputEnvelope
    set?: CalendarZoneDistrictWhereUniqueInput | CalendarZoneDistrictWhereUniqueInput[]
    disconnect?: CalendarZoneDistrictWhereUniqueInput | CalendarZoneDistrictWhereUniqueInput[]
    delete?: CalendarZoneDistrictWhereUniqueInput | CalendarZoneDistrictWhereUniqueInput[]
    connect?: CalendarZoneDistrictWhereUniqueInput | CalendarZoneDistrictWhereUniqueInput[]
    update?: CalendarZoneDistrictUpdateWithWhereUniqueWithoutDistrictInput | CalendarZoneDistrictUpdateWithWhereUniqueWithoutDistrictInput[]
    updateMany?: CalendarZoneDistrictUpdateManyWithWhereWithoutDistrictInput | CalendarZoneDistrictUpdateManyWithWhereWithoutDistrictInput[]
    deleteMany?: CalendarZoneDistrictScalarWhereInput | CalendarZoneDistrictScalarWhereInput[]
  }

  export type ZoneCreateNestedOneWithoutZoneDistrictsInput = {
    create?: XOR<ZoneCreateWithoutZoneDistrictsInput, ZoneUncheckedCreateWithoutZoneDistrictsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutZoneDistrictsInput
    connect?: ZoneWhereUniqueInput
  }

  export type DistrictCreateNestedOneWithoutZoneDistrictsInput = {
    create?: XOR<DistrictCreateWithoutZoneDistrictsInput, DistrictUncheckedCreateWithoutZoneDistrictsInput>
    connectOrCreate?: DistrictCreateOrConnectWithoutZoneDistrictsInput
    connect?: DistrictWhereUniqueInput
  }

  export type ZoneUpdateOneRequiredWithoutZoneDistrictsNestedInput = {
    create?: XOR<ZoneCreateWithoutZoneDistrictsInput, ZoneUncheckedCreateWithoutZoneDistrictsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutZoneDistrictsInput
    upsert?: ZoneUpsertWithoutZoneDistrictsInput
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutZoneDistrictsInput, ZoneUpdateWithoutZoneDistrictsInput>, ZoneUncheckedUpdateWithoutZoneDistrictsInput>
  }

  export type DistrictUpdateOneRequiredWithoutZoneDistrictsNestedInput = {
    create?: XOR<DistrictCreateWithoutZoneDistrictsInput, DistrictUncheckedCreateWithoutZoneDistrictsInput>
    connectOrCreate?: DistrictCreateOrConnectWithoutZoneDistrictsInput
    upsert?: DistrictUpsertWithoutZoneDistrictsInput
    connect?: DistrictWhereUniqueInput
    update?: XOR<XOR<DistrictUpdateToOneWithWhereWithoutZoneDistrictsInput, DistrictUpdateWithoutZoneDistrictsInput>, DistrictUncheckedUpdateWithoutZoneDistrictsInput>
  }

  export type CropCreateNestedOneWithoutCalendarsInput = {
    create?: XOR<CropCreateWithoutCalendarsInput, CropUncheckedCreateWithoutCalendarsInput>
    connectOrCreate?: CropCreateOrConnectWithoutCalendarsInput
    connect?: CropWhereUniqueInput
  }

  export type StageCreateNestedManyWithoutCalendarInput = {
    create?: XOR<StageCreateWithoutCalendarInput, StageUncheckedCreateWithoutCalendarInput> | StageCreateWithoutCalendarInput[] | StageUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: StageCreateOrConnectWithoutCalendarInput | StageCreateOrConnectWithoutCalendarInput[]
    createMany?: StageCreateManyCalendarInputEnvelope
    connect?: StageWhereUniqueInput | StageWhereUniqueInput[]
  }

  export type CalendarZoneCreateNestedManyWithoutCalendarInput = {
    create?: XOR<CalendarZoneCreateWithoutCalendarInput, CalendarZoneUncheckedCreateWithoutCalendarInput> | CalendarZoneCreateWithoutCalendarInput[] | CalendarZoneUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: CalendarZoneCreateOrConnectWithoutCalendarInput | CalendarZoneCreateOrConnectWithoutCalendarInput[]
    createMany?: CalendarZoneCreateManyCalendarInputEnvelope
    connect?: CalendarZoneWhereUniqueInput | CalendarZoneWhereUniqueInput[]
  }

  export type CalendarIndicatorCreateNestedManyWithoutCalendarInput = {
    create?: XOR<CalendarIndicatorCreateWithoutCalendarInput, CalendarIndicatorUncheckedCreateWithoutCalendarInput> | CalendarIndicatorCreateWithoutCalendarInput[] | CalendarIndicatorUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: CalendarIndicatorCreateOrConnectWithoutCalendarInput | CalendarIndicatorCreateOrConnectWithoutCalendarInput[]
    createMany?: CalendarIndicatorCreateManyCalendarInputEnvelope
    connect?: CalendarIndicatorWhereUniqueInput | CalendarIndicatorWhereUniqueInput[]
  }

  export type StageUncheckedCreateNestedManyWithoutCalendarInput = {
    create?: XOR<StageCreateWithoutCalendarInput, StageUncheckedCreateWithoutCalendarInput> | StageCreateWithoutCalendarInput[] | StageUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: StageCreateOrConnectWithoutCalendarInput | StageCreateOrConnectWithoutCalendarInput[]
    createMany?: StageCreateManyCalendarInputEnvelope
    connect?: StageWhereUniqueInput | StageWhereUniqueInput[]
  }

  export type CalendarZoneUncheckedCreateNestedManyWithoutCalendarInput = {
    create?: XOR<CalendarZoneCreateWithoutCalendarInput, CalendarZoneUncheckedCreateWithoutCalendarInput> | CalendarZoneCreateWithoutCalendarInput[] | CalendarZoneUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: CalendarZoneCreateOrConnectWithoutCalendarInput | CalendarZoneCreateOrConnectWithoutCalendarInput[]
    createMany?: CalendarZoneCreateManyCalendarInputEnvelope
    connect?: CalendarZoneWhereUniqueInput | CalendarZoneWhereUniqueInput[]
  }

  export type CalendarIndicatorUncheckedCreateNestedManyWithoutCalendarInput = {
    create?: XOR<CalendarIndicatorCreateWithoutCalendarInput, CalendarIndicatorUncheckedCreateWithoutCalendarInput> | CalendarIndicatorCreateWithoutCalendarInput[] | CalendarIndicatorUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: CalendarIndicatorCreateOrConnectWithoutCalendarInput | CalendarIndicatorCreateOrConnectWithoutCalendarInput[]
    createMany?: CalendarIndicatorCreateManyCalendarInputEnvelope
    connect?: CalendarIndicatorWhereUniqueInput | CalendarIndicatorWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumCalendarFileTypeFieldUpdateOperationsInput = {
    set?: $Enums.CalendarFileType
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CropUpdateOneRequiredWithoutCalendarsNestedInput = {
    create?: XOR<CropCreateWithoutCalendarsInput, CropUncheckedCreateWithoutCalendarsInput>
    connectOrCreate?: CropCreateOrConnectWithoutCalendarsInput
    upsert?: CropUpsertWithoutCalendarsInput
    connect?: CropWhereUniqueInput
    update?: XOR<XOR<CropUpdateToOneWithWhereWithoutCalendarsInput, CropUpdateWithoutCalendarsInput>, CropUncheckedUpdateWithoutCalendarsInput>
  }

  export type StageUpdateManyWithoutCalendarNestedInput = {
    create?: XOR<StageCreateWithoutCalendarInput, StageUncheckedCreateWithoutCalendarInput> | StageCreateWithoutCalendarInput[] | StageUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: StageCreateOrConnectWithoutCalendarInput | StageCreateOrConnectWithoutCalendarInput[]
    upsert?: StageUpsertWithWhereUniqueWithoutCalendarInput | StageUpsertWithWhereUniqueWithoutCalendarInput[]
    createMany?: StageCreateManyCalendarInputEnvelope
    set?: StageWhereUniqueInput | StageWhereUniqueInput[]
    disconnect?: StageWhereUniqueInput | StageWhereUniqueInput[]
    delete?: StageWhereUniqueInput | StageWhereUniqueInput[]
    connect?: StageWhereUniqueInput | StageWhereUniqueInput[]
    update?: StageUpdateWithWhereUniqueWithoutCalendarInput | StageUpdateWithWhereUniqueWithoutCalendarInput[]
    updateMany?: StageUpdateManyWithWhereWithoutCalendarInput | StageUpdateManyWithWhereWithoutCalendarInput[]
    deleteMany?: StageScalarWhereInput | StageScalarWhereInput[]
  }

  export type CalendarZoneUpdateManyWithoutCalendarNestedInput = {
    create?: XOR<CalendarZoneCreateWithoutCalendarInput, CalendarZoneUncheckedCreateWithoutCalendarInput> | CalendarZoneCreateWithoutCalendarInput[] | CalendarZoneUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: CalendarZoneCreateOrConnectWithoutCalendarInput | CalendarZoneCreateOrConnectWithoutCalendarInput[]
    upsert?: CalendarZoneUpsertWithWhereUniqueWithoutCalendarInput | CalendarZoneUpsertWithWhereUniqueWithoutCalendarInput[]
    createMany?: CalendarZoneCreateManyCalendarInputEnvelope
    set?: CalendarZoneWhereUniqueInput | CalendarZoneWhereUniqueInput[]
    disconnect?: CalendarZoneWhereUniqueInput | CalendarZoneWhereUniqueInput[]
    delete?: CalendarZoneWhereUniqueInput | CalendarZoneWhereUniqueInput[]
    connect?: CalendarZoneWhereUniqueInput | CalendarZoneWhereUniqueInput[]
    update?: CalendarZoneUpdateWithWhereUniqueWithoutCalendarInput | CalendarZoneUpdateWithWhereUniqueWithoutCalendarInput[]
    updateMany?: CalendarZoneUpdateManyWithWhereWithoutCalendarInput | CalendarZoneUpdateManyWithWhereWithoutCalendarInput[]
    deleteMany?: CalendarZoneScalarWhereInput | CalendarZoneScalarWhereInput[]
  }

  export type CalendarIndicatorUpdateManyWithoutCalendarNestedInput = {
    create?: XOR<CalendarIndicatorCreateWithoutCalendarInput, CalendarIndicatorUncheckedCreateWithoutCalendarInput> | CalendarIndicatorCreateWithoutCalendarInput[] | CalendarIndicatorUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: CalendarIndicatorCreateOrConnectWithoutCalendarInput | CalendarIndicatorCreateOrConnectWithoutCalendarInput[]
    upsert?: CalendarIndicatorUpsertWithWhereUniqueWithoutCalendarInput | CalendarIndicatorUpsertWithWhereUniqueWithoutCalendarInput[]
    createMany?: CalendarIndicatorCreateManyCalendarInputEnvelope
    set?: CalendarIndicatorWhereUniqueInput | CalendarIndicatorWhereUniqueInput[]
    disconnect?: CalendarIndicatorWhereUniqueInput | CalendarIndicatorWhereUniqueInput[]
    delete?: CalendarIndicatorWhereUniqueInput | CalendarIndicatorWhereUniqueInput[]
    connect?: CalendarIndicatorWhereUniqueInput | CalendarIndicatorWhereUniqueInput[]
    update?: CalendarIndicatorUpdateWithWhereUniqueWithoutCalendarInput | CalendarIndicatorUpdateWithWhereUniqueWithoutCalendarInput[]
    updateMany?: CalendarIndicatorUpdateManyWithWhereWithoutCalendarInput | CalendarIndicatorUpdateManyWithWhereWithoutCalendarInput[]
    deleteMany?: CalendarIndicatorScalarWhereInput | CalendarIndicatorScalarWhereInput[]
  }

  export type StageUncheckedUpdateManyWithoutCalendarNestedInput = {
    create?: XOR<StageCreateWithoutCalendarInput, StageUncheckedCreateWithoutCalendarInput> | StageCreateWithoutCalendarInput[] | StageUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: StageCreateOrConnectWithoutCalendarInput | StageCreateOrConnectWithoutCalendarInput[]
    upsert?: StageUpsertWithWhereUniqueWithoutCalendarInput | StageUpsertWithWhereUniqueWithoutCalendarInput[]
    createMany?: StageCreateManyCalendarInputEnvelope
    set?: StageWhereUniqueInput | StageWhereUniqueInput[]
    disconnect?: StageWhereUniqueInput | StageWhereUniqueInput[]
    delete?: StageWhereUniqueInput | StageWhereUniqueInput[]
    connect?: StageWhereUniqueInput | StageWhereUniqueInput[]
    update?: StageUpdateWithWhereUniqueWithoutCalendarInput | StageUpdateWithWhereUniqueWithoutCalendarInput[]
    updateMany?: StageUpdateManyWithWhereWithoutCalendarInput | StageUpdateManyWithWhereWithoutCalendarInput[]
    deleteMany?: StageScalarWhereInput | StageScalarWhereInput[]
  }

  export type CalendarZoneUncheckedUpdateManyWithoutCalendarNestedInput = {
    create?: XOR<CalendarZoneCreateWithoutCalendarInput, CalendarZoneUncheckedCreateWithoutCalendarInput> | CalendarZoneCreateWithoutCalendarInput[] | CalendarZoneUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: CalendarZoneCreateOrConnectWithoutCalendarInput | CalendarZoneCreateOrConnectWithoutCalendarInput[]
    upsert?: CalendarZoneUpsertWithWhereUniqueWithoutCalendarInput | CalendarZoneUpsertWithWhereUniqueWithoutCalendarInput[]
    createMany?: CalendarZoneCreateManyCalendarInputEnvelope
    set?: CalendarZoneWhereUniqueInput | CalendarZoneWhereUniqueInput[]
    disconnect?: CalendarZoneWhereUniqueInput | CalendarZoneWhereUniqueInput[]
    delete?: CalendarZoneWhereUniqueInput | CalendarZoneWhereUniqueInput[]
    connect?: CalendarZoneWhereUniqueInput | CalendarZoneWhereUniqueInput[]
    update?: CalendarZoneUpdateWithWhereUniqueWithoutCalendarInput | CalendarZoneUpdateWithWhereUniqueWithoutCalendarInput[]
    updateMany?: CalendarZoneUpdateManyWithWhereWithoutCalendarInput | CalendarZoneUpdateManyWithWhereWithoutCalendarInput[]
    deleteMany?: CalendarZoneScalarWhereInput | CalendarZoneScalarWhereInput[]
  }

  export type CalendarIndicatorUncheckedUpdateManyWithoutCalendarNestedInput = {
    create?: XOR<CalendarIndicatorCreateWithoutCalendarInput, CalendarIndicatorUncheckedCreateWithoutCalendarInput> | CalendarIndicatorCreateWithoutCalendarInput[] | CalendarIndicatorUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: CalendarIndicatorCreateOrConnectWithoutCalendarInput | CalendarIndicatorCreateOrConnectWithoutCalendarInput[]
    upsert?: CalendarIndicatorUpsertWithWhereUniqueWithoutCalendarInput | CalendarIndicatorUpsertWithWhereUniqueWithoutCalendarInput[]
    createMany?: CalendarIndicatorCreateManyCalendarInputEnvelope
    set?: CalendarIndicatorWhereUniqueInput | CalendarIndicatorWhereUniqueInput[]
    disconnect?: CalendarIndicatorWhereUniqueInput | CalendarIndicatorWhereUniqueInput[]
    delete?: CalendarIndicatorWhereUniqueInput | CalendarIndicatorWhereUniqueInput[]
    connect?: CalendarIndicatorWhereUniqueInput | CalendarIndicatorWhereUniqueInput[]
    update?: CalendarIndicatorUpdateWithWhereUniqueWithoutCalendarInput | CalendarIndicatorUpdateWithWhereUniqueWithoutCalendarInput[]
    updateMany?: CalendarIndicatorUpdateManyWithWhereWithoutCalendarInput | CalendarIndicatorUpdateManyWithWhereWithoutCalendarInput[]
    deleteMany?: CalendarIndicatorScalarWhereInput | CalendarIndicatorScalarWhereInput[]
  }

  export type CalendarCreateNestedOneWithoutCalendarZonesInput = {
    create?: XOR<CalendarCreateWithoutCalendarZonesInput, CalendarUncheckedCreateWithoutCalendarZonesInput>
    connectOrCreate?: CalendarCreateOrConnectWithoutCalendarZonesInput
    connect?: CalendarWhereUniqueInput
  }

  export type ZoneCreateNestedOneWithoutCalendarZonesInput = {
    create?: XOR<ZoneCreateWithoutCalendarZonesInput, ZoneUncheckedCreateWithoutCalendarZonesInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutCalendarZonesInput
    connect?: ZoneWhereUniqueInput
  }

  export type CalendarZoneDistrictCreateNestedManyWithoutCalendarZoneInput = {
    create?: XOR<CalendarZoneDistrictCreateWithoutCalendarZoneInput, CalendarZoneDistrictUncheckedCreateWithoutCalendarZoneInput> | CalendarZoneDistrictCreateWithoutCalendarZoneInput[] | CalendarZoneDistrictUncheckedCreateWithoutCalendarZoneInput[]
    connectOrCreate?: CalendarZoneDistrictCreateOrConnectWithoutCalendarZoneInput | CalendarZoneDistrictCreateOrConnectWithoutCalendarZoneInput[]
    createMany?: CalendarZoneDistrictCreateManyCalendarZoneInputEnvelope
    connect?: CalendarZoneDistrictWhereUniqueInput | CalendarZoneDistrictWhereUniqueInput[]
  }

  export type CalendarZoneDistrictUncheckedCreateNestedManyWithoutCalendarZoneInput = {
    create?: XOR<CalendarZoneDistrictCreateWithoutCalendarZoneInput, CalendarZoneDistrictUncheckedCreateWithoutCalendarZoneInput> | CalendarZoneDistrictCreateWithoutCalendarZoneInput[] | CalendarZoneDistrictUncheckedCreateWithoutCalendarZoneInput[]
    connectOrCreate?: CalendarZoneDistrictCreateOrConnectWithoutCalendarZoneInput | CalendarZoneDistrictCreateOrConnectWithoutCalendarZoneInput[]
    createMany?: CalendarZoneDistrictCreateManyCalendarZoneInputEnvelope
    connect?: CalendarZoneDistrictWhereUniqueInput | CalendarZoneDistrictWhereUniqueInput[]
  }

  export type CalendarUpdateOneRequiredWithoutCalendarZonesNestedInput = {
    create?: XOR<CalendarCreateWithoutCalendarZonesInput, CalendarUncheckedCreateWithoutCalendarZonesInput>
    connectOrCreate?: CalendarCreateOrConnectWithoutCalendarZonesInput
    upsert?: CalendarUpsertWithoutCalendarZonesInput
    connect?: CalendarWhereUniqueInput
    update?: XOR<XOR<CalendarUpdateToOneWithWhereWithoutCalendarZonesInput, CalendarUpdateWithoutCalendarZonesInput>, CalendarUncheckedUpdateWithoutCalendarZonesInput>
  }

  export type ZoneUpdateOneRequiredWithoutCalendarZonesNestedInput = {
    create?: XOR<ZoneCreateWithoutCalendarZonesInput, ZoneUncheckedCreateWithoutCalendarZonesInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutCalendarZonesInput
    upsert?: ZoneUpsertWithoutCalendarZonesInput
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutCalendarZonesInput, ZoneUpdateWithoutCalendarZonesInput>, ZoneUncheckedUpdateWithoutCalendarZonesInput>
  }

  export type CalendarZoneDistrictUpdateManyWithoutCalendarZoneNestedInput = {
    create?: XOR<CalendarZoneDistrictCreateWithoutCalendarZoneInput, CalendarZoneDistrictUncheckedCreateWithoutCalendarZoneInput> | CalendarZoneDistrictCreateWithoutCalendarZoneInput[] | CalendarZoneDistrictUncheckedCreateWithoutCalendarZoneInput[]
    connectOrCreate?: CalendarZoneDistrictCreateOrConnectWithoutCalendarZoneInput | CalendarZoneDistrictCreateOrConnectWithoutCalendarZoneInput[]
    upsert?: CalendarZoneDistrictUpsertWithWhereUniqueWithoutCalendarZoneInput | CalendarZoneDistrictUpsertWithWhereUniqueWithoutCalendarZoneInput[]
    createMany?: CalendarZoneDistrictCreateManyCalendarZoneInputEnvelope
    set?: CalendarZoneDistrictWhereUniqueInput | CalendarZoneDistrictWhereUniqueInput[]
    disconnect?: CalendarZoneDistrictWhereUniqueInput | CalendarZoneDistrictWhereUniqueInput[]
    delete?: CalendarZoneDistrictWhereUniqueInput | CalendarZoneDistrictWhereUniqueInput[]
    connect?: CalendarZoneDistrictWhereUniqueInput | CalendarZoneDistrictWhereUniqueInput[]
    update?: CalendarZoneDistrictUpdateWithWhereUniqueWithoutCalendarZoneInput | CalendarZoneDistrictUpdateWithWhereUniqueWithoutCalendarZoneInput[]
    updateMany?: CalendarZoneDistrictUpdateManyWithWhereWithoutCalendarZoneInput | CalendarZoneDistrictUpdateManyWithWhereWithoutCalendarZoneInput[]
    deleteMany?: CalendarZoneDistrictScalarWhereInput | CalendarZoneDistrictScalarWhereInput[]
  }

  export type CalendarZoneDistrictUncheckedUpdateManyWithoutCalendarZoneNestedInput = {
    create?: XOR<CalendarZoneDistrictCreateWithoutCalendarZoneInput, CalendarZoneDistrictUncheckedCreateWithoutCalendarZoneInput> | CalendarZoneDistrictCreateWithoutCalendarZoneInput[] | CalendarZoneDistrictUncheckedCreateWithoutCalendarZoneInput[]
    connectOrCreate?: CalendarZoneDistrictCreateOrConnectWithoutCalendarZoneInput | CalendarZoneDistrictCreateOrConnectWithoutCalendarZoneInput[]
    upsert?: CalendarZoneDistrictUpsertWithWhereUniqueWithoutCalendarZoneInput | CalendarZoneDistrictUpsertWithWhereUniqueWithoutCalendarZoneInput[]
    createMany?: CalendarZoneDistrictCreateManyCalendarZoneInputEnvelope
    set?: CalendarZoneDistrictWhereUniqueInput | CalendarZoneDistrictWhereUniqueInput[]
    disconnect?: CalendarZoneDistrictWhereUniqueInput | CalendarZoneDistrictWhereUniqueInput[]
    delete?: CalendarZoneDistrictWhereUniqueInput | CalendarZoneDistrictWhereUniqueInput[]
    connect?: CalendarZoneDistrictWhereUniqueInput | CalendarZoneDistrictWhereUniqueInput[]
    update?: CalendarZoneDistrictUpdateWithWhereUniqueWithoutCalendarZoneInput | CalendarZoneDistrictUpdateWithWhereUniqueWithoutCalendarZoneInput[]
    updateMany?: CalendarZoneDistrictUpdateManyWithWhereWithoutCalendarZoneInput | CalendarZoneDistrictUpdateManyWithWhereWithoutCalendarZoneInput[]
    deleteMany?: CalendarZoneDistrictScalarWhereInput | CalendarZoneDistrictScalarWhereInput[]
  }

  export type CalendarZoneCreateNestedOneWithoutDistrictsInput = {
    create?: XOR<CalendarZoneCreateWithoutDistrictsInput, CalendarZoneUncheckedCreateWithoutDistrictsInput>
    connectOrCreate?: CalendarZoneCreateOrConnectWithoutDistrictsInput
    connect?: CalendarZoneWhereUniqueInput
  }

  export type DistrictCreateNestedOneWithoutCalendarZoneDistrictsInput = {
    create?: XOR<DistrictCreateWithoutCalendarZoneDistrictsInput, DistrictUncheckedCreateWithoutCalendarZoneDistrictsInput>
    connectOrCreate?: DistrictCreateOrConnectWithoutCalendarZoneDistrictsInput
    connect?: DistrictWhereUniqueInput
  }

  export type CalendarZoneUpdateOneRequiredWithoutDistrictsNestedInput = {
    create?: XOR<CalendarZoneCreateWithoutDistrictsInput, CalendarZoneUncheckedCreateWithoutDistrictsInput>
    connectOrCreate?: CalendarZoneCreateOrConnectWithoutDistrictsInput
    upsert?: CalendarZoneUpsertWithoutDistrictsInput
    connect?: CalendarZoneWhereUniqueInput
    update?: XOR<XOR<CalendarZoneUpdateToOneWithWhereWithoutDistrictsInput, CalendarZoneUpdateWithoutDistrictsInput>, CalendarZoneUncheckedUpdateWithoutDistrictsInput>
  }

  export type DistrictUpdateOneRequiredWithoutCalendarZoneDistrictsNestedInput = {
    create?: XOR<DistrictCreateWithoutCalendarZoneDistrictsInput, DistrictUncheckedCreateWithoutCalendarZoneDistrictsInput>
    connectOrCreate?: DistrictCreateOrConnectWithoutCalendarZoneDistrictsInput
    upsert?: DistrictUpsertWithoutCalendarZoneDistrictsInput
    connect?: DistrictWhereUniqueInput
    update?: XOR<XOR<DistrictUpdateToOneWithWhereWithoutCalendarZoneDistrictsInput, DistrictUpdateWithoutCalendarZoneDistrictsInput>, DistrictUncheckedUpdateWithoutCalendarZoneDistrictsInput>
  }

  export type CalendarCreateNestedOneWithoutCalendarIndicatorsInput = {
    create?: XOR<CalendarCreateWithoutCalendarIndicatorsInput, CalendarUncheckedCreateWithoutCalendarIndicatorsInput>
    connectOrCreate?: CalendarCreateOrConnectWithoutCalendarIndicatorsInput
    connect?: CalendarWhereUniqueInput
  }

  export type IndicatorCreateNestedOneWithoutCalendarIndicatorsInput = {
    create?: XOR<IndicatorCreateWithoutCalendarIndicatorsInput, IndicatorUncheckedCreateWithoutCalendarIndicatorsInput>
    connectOrCreate?: IndicatorCreateOrConnectWithoutCalendarIndicatorsInput
    connect?: IndicatorWhereUniqueInput
  }

  export type CalendarUpdateOneRequiredWithoutCalendarIndicatorsNestedInput = {
    create?: XOR<CalendarCreateWithoutCalendarIndicatorsInput, CalendarUncheckedCreateWithoutCalendarIndicatorsInput>
    connectOrCreate?: CalendarCreateOrConnectWithoutCalendarIndicatorsInput
    upsert?: CalendarUpsertWithoutCalendarIndicatorsInput
    connect?: CalendarWhereUniqueInput
    update?: XOR<XOR<CalendarUpdateToOneWithWhereWithoutCalendarIndicatorsInput, CalendarUpdateWithoutCalendarIndicatorsInput>, CalendarUncheckedUpdateWithoutCalendarIndicatorsInput>
  }

  export type IndicatorUpdateOneRequiredWithoutCalendarIndicatorsNestedInput = {
    create?: XOR<IndicatorCreateWithoutCalendarIndicatorsInput, IndicatorUncheckedCreateWithoutCalendarIndicatorsInput>
    connectOrCreate?: IndicatorCreateOrConnectWithoutCalendarIndicatorsInput
    upsert?: IndicatorUpsertWithoutCalendarIndicatorsInput
    connect?: IndicatorWhereUniqueInput
    update?: XOR<XOR<IndicatorUpdateToOneWithWhereWithoutCalendarIndicatorsInput, IndicatorUpdateWithoutCalendarIndicatorsInput>, IndicatorUncheckedUpdateWithoutCalendarIndicatorsInput>
  }

  export type CalendarCreateNestedOneWithoutStagesInput = {
    create?: XOR<CalendarCreateWithoutStagesInput, CalendarUncheckedCreateWithoutStagesInput>
    connectOrCreate?: CalendarCreateOrConnectWithoutStagesInput
    connect?: CalendarWhereUniqueInput
  }

  export type StageImageCreateNestedManyWithoutStageInput = {
    create?: XOR<StageImageCreateWithoutStageInput, StageImageUncheckedCreateWithoutStageInput> | StageImageCreateWithoutStageInput[] | StageImageUncheckedCreateWithoutStageInput[]
    connectOrCreate?: StageImageCreateOrConnectWithoutStageInput | StageImageCreateOrConnectWithoutStageInput[]
    createMany?: StageImageCreateManyStageInputEnvelope
    connect?: StageImageWhereUniqueInput | StageImageWhereUniqueInput[]
  }

  export type StageThresholdCreateNestedManyWithoutStageInput = {
    create?: XOR<StageThresholdCreateWithoutStageInput, StageThresholdUncheckedCreateWithoutStageInput> | StageThresholdCreateWithoutStageInput[] | StageThresholdUncheckedCreateWithoutStageInput[]
    connectOrCreate?: StageThresholdCreateOrConnectWithoutStageInput | StageThresholdCreateOrConnectWithoutStageInput[]
    createMany?: StageThresholdCreateManyStageInputEnvelope
    connect?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
  }

  export type StageImageUncheckedCreateNestedManyWithoutStageInput = {
    create?: XOR<StageImageCreateWithoutStageInput, StageImageUncheckedCreateWithoutStageInput> | StageImageCreateWithoutStageInput[] | StageImageUncheckedCreateWithoutStageInput[]
    connectOrCreate?: StageImageCreateOrConnectWithoutStageInput | StageImageCreateOrConnectWithoutStageInput[]
    createMany?: StageImageCreateManyStageInputEnvelope
    connect?: StageImageWhereUniqueInput | StageImageWhereUniqueInput[]
  }

  export type StageThresholdUncheckedCreateNestedManyWithoutStageInput = {
    create?: XOR<StageThresholdCreateWithoutStageInput, StageThresholdUncheckedCreateWithoutStageInput> | StageThresholdCreateWithoutStageInput[] | StageThresholdUncheckedCreateWithoutStageInput[]
    connectOrCreate?: StageThresholdCreateOrConnectWithoutStageInput | StageThresholdCreateOrConnectWithoutStageInput[]
    createMany?: StageThresholdCreateManyStageInputEnvelope
    connect?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
  }

  export type EnumStageStatusFieldUpdateOperationsInput = {
    set?: $Enums.StageStatus
  }

  export type NullableEnumTenDayFieldUpdateOperationsInput = {
    set?: $Enums.TenDay | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CalendarUpdateOneRequiredWithoutStagesNestedInput = {
    create?: XOR<CalendarCreateWithoutStagesInput, CalendarUncheckedCreateWithoutStagesInput>
    connectOrCreate?: CalendarCreateOrConnectWithoutStagesInput
    upsert?: CalendarUpsertWithoutStagesInput
    connect?: CalendarWhereUniqueInput
    update?: XOR<XOR<CalendarUpdateToOneWithWhereWithoutStagesInput, CalendarUpdateWithoutStagesInput>, CalendarUncheckedUpdateWithoutStagesInput>
  }

  export type StageImageUpdateManyWithoutStageNestedInput = {
    create?: XOR<StageImageCreateWithoutStageInput, StageImageUncheckedCreateWithoutStageInput> | StageImageCreateWithoutStageInput[] | StageImageUncheckedCreateWithoutStageInput[]
    connectOrCreate?: StageImageCreateOrConnectWithoutStageInput | StageImageCreateOrConnectWithoutStageInput[]
    upsert?: StageImageUpsertWithWhereUniqueWithoutStageInput | StageImageUpsertWithWhereUniqueWithoutStageInput[]
    createMany?: StageImageCreateManyStageInputEnvelope
    set?: StageImageWhereUniqueInput | StageImageWhereUniqueInput[]
    disconnect?: StageImageWhereUniqueInput | StageImageWhereUniqueInput[]
    delete?: StageImageWhereUniqueInput | StageImageWhereUniqueInput[]
    connect?: StageImageWhereUniqueInput | StageImageWhereUniqueInput[]
    update?: StageImageUpdateWithWhereUniqueWithoutStageInput | StageImageUpdateWithWhereUniqueWithoutStageInput[]
    updateMany?: StageImageUpdateManyWithWhereWithoutStageInput | StageImageUpdateManyWithWhereWithoutStageInput[]
    deleteMany?: StageImageScalarWhereInput | StageImageScalarWhereInput[]
  }

  export type StageThresholdUpdateManyWithoutStageNestedInput = {
    create?: XOR<StageThresholdCreateWithoutStageInput, StageThresholdUncheckedCreateWithoutStageInput> | StageThresholdCreateWithoutStageInput[] | StageThresholdUncheckedCreateWithoutStageInput[]
    connectOrCreate?: StageThresholdCreateOrConnectWithoutStageInput | StageThresholdCreateOrConnectWithoutStageInput[]
    upsert?: StageThresholdUpsertWithWhereUniqueWithoutStageInput | StageThresholdUpsertWithWhereUniqueWithoutStageInput[]
    createMany?: StageThresholdCreateManyStageInputEnvelope
    set?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    disconnect?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    delete?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    connect?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    update?: StageThresholdUpdateWithWhereUniqueWithoutStageInput | StageThresholdUpdateWithWhereUniqueWithoutStageInput[]
    updateMany?: StageThresholdUpdateManyWithWhereWithoutStageInput | StageThresholdUpdateManyWithWhereWithoutStageInput[]
    deleteMany?: StageThresholdScalarWhereInput | StageThresholdScalarWhereInput[]
  }

  export type StageImageUncheckedUpdateManyWithoutStageNestedInput = {
    create?: XOR<StageImageCreateWithoutStageInput, StageImageUncheckedCreateWithoutStageInput> | StageImageCreateWithoutStageInput[] | StageImageUncheckedCreateWithoutStageInput[]
    connectOrCreate?: StageImageCreateOrConnectWithoutStageInput | StageImageCreateOrConnectWithoutStageInput[]
    upsert?: StageImageUpsertWithWhereUniqueWithoutStageInput | StageImageUpsertWithWhereUniqueWithoutStageInput[]
    createMany?: StageImageCreateManyStageInputEnvelope
    set?: StageImageWhereUniqueInput | StageImageWhereUniqueInput[]
    disconnect?: StageImageWhereUniqueInput | StageImageWhereUniqueInput[]
    delete?: StageImageWhereUniqueInput | StageImageWhereUniqueInput[]
    connect?: StageImageWhereUniqueInput | StageImageWhereUniqueInput[]
    update?: StageImageUpdateWithWhereUniqueWithoutStageInput | StageImageUpdateWithWhereUniqueWithoutStageInput[]
    updateMany?: StageImageUpdateManyWithWhereWithoutStageInput | StageImageUpdateManyWithWhereWithoutStageInput[]
    deleteMany?: StageImageScalarWhereInput | StageImageScalarWhereInput[]
  }

  export type StageThresholdUncheckedUpdateManyWithoutStageNestedInput = {
    create?: XOR<StageThresholdCreateWithoutStageInput, StageThresholdUncheckedCreateWithoutStageInput> | StageThresholdCreateWithoutStageInput[] | StageThresholdUncheckedCreateWithoutStageInput[]
    connectOrCreate?: StageThresholdCreateOrConnectWithoutStageInput | StageThresholdCreateOrConnectWithoutStageInput[]
    upsert?: StageThresholdUpsertWithWhereUniqueWithoutStageInput | StageThresholdUpsertWithWhereUniqueWithoutStageInput[]
    createMany?: StageThresholdCreateManyStageInputEnvelope
    set?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    disconnect?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    delete?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    connect?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    update?: StageThresholdUpdateWithWhereUniqueWithoutStageInput | StageThresholdUpdateWithWhereUniqueWithoutStageInput[]
    updateMany?: StageThresholdUpdateManyWithWhereWithoutStageInput | StageThresholdUpdateManyWithWhereWithoutStageInput[]
    deleteMany?: StageThresholdScalarWhereInput | StageThresholdScalarWhereInput[]
  }

  export type StageCreateNestedOneWithoutImagesInput = {
    create?: XOR<StageCreateWithoutImagesInput, StageUncheckedCreateWithoutImagesInput>
    connectOrCreate?: StageCreateOrConnectWithoutImagesInput
    connect?: StageWhereUniqueInput
  }

  export type EnumStageImageTypeFieldUpdateOperationsInput = {
    set?: $Enums.StageImageType
  }

  export type StageUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<StageCreateWithoutImagesInput, StageUncheckedCreateWithoutImagesInput>
    connectOrCreate?: StageCreateOrConnectWithoutImagesInput
    upsert?: StageUpsertWithoutImagesInput
    connect?: StageWhereUniqueInput
    update?: XOR<XOR<StageUpdateToOneWithWhereWithoutImagesInput, StageUpdateWithoutImagesInput>, StageUncheckedUpdateWithoutImagesInput>
  }

  export type StageCreateNestedOneWithoutThresholdsInput = {
    create?: XOR<StageCreateWithoutThresholdsInput, StageUncheckedCreateWithoutThresholdsInput>
    connectOrCreate?: StageCreateOrConnectWithoutThresholdsInput
    connect?: StageWhereUniqueInput
  }

  export type IndicatorCreateNestedOneWithoutThresholdsInput = {
    create?: XOR<IndicatorCreateWithoutThresholdsInput, IndicatorUncheckedCreateWithoutThresholdsInput>
    connectOrCreate?: IndicatorCreateOrConnectWithoutThresholdsInput
    connect?: IndicatorWhereUniqueInput
  }

  export type EnumThresholdOperatorFieldUpdateOperationsInput = {
    set?: $Enums.ThresholdOperator
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StageUpdateOneRequiredWithoutThresholdsNestedInput = {
    create?: XOR<StageCreateWithoutThresholdsInput, StageUncheckedCreateWithoutThresholdsInput>
    connectOrCreate?: StageCreateOrConnectWithoutThresholdsInput
    upsert?: StageUpsertWithoutThresholdsInput
    connect?: StageWhereUniqueInput
    update?: XOR<XOR<StageUpdateToOneWithWhereWithoutThresholdsInput, StageUpdateWithoutThresholdsInput>, StageUncheckedUpdateWithoutThresholdsInput>
  }

  export type IndicatorUpdateOneRequiredWithoutThresholdsNestedInput = {
    create?: XOR<IndicatorCreateWithoutThresholdsInput, IndicatorUncheckedCreateWithoutThresholdsInput>
    connectOrCreate?: IndicatorCreateOrConnectWithoutThresholdsInput
    upsert?: IndicatorUpsertWithoutThresholdsInput
    connect?: IndicatorWhereUniqueInput
    update?: XOR<XOR<IndicatorUpdateToOneWithWhereWithoutThresholdsInput, IndicatorUpdateWithoutThresholdsInput>, IndicatorUncheckedUpdateWithoutThresholdsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumCalendarFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CalendarFileType | EnumCalendarFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CalendarFileType[] | ListEnumCalendarFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalendarFileType[] | ListEnumCalendarFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCalendarFileTypeFilter<$PrismaModel> | $Enums.CalendarFileType
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumCalendarFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CalendarFileType | EnumCalendarFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CalendarFileType[] | ListEnumCalendarFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalendarFileType[] | ListEnumCalendarFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCalendarFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.CalendarFileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCalendarFileTypeFilter<$PrismaModel>
    _max?: NestedEnumCalendarFileTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumStageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StageStatus | EnumStageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StageStatus[] | ListEnumStageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StageStatus[] | ListEnumStageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStageStatusFilter<$PrismaModel> | $Enums.StageStatus
  }

  export type NestedEnumTenDayNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TenDay | EnumTenDayFieldRefInput<$PrismaModel> | null
    in?: $Enums.TenDay[] | ListEnumTenDayFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TenDay[] | ListEnumTenDayFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTenDayNullableFilter<$PrismaModel> | $Enums.TenDay | null
  }

  export type NestedEnumStageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StageStatus | EnumStageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StageStatus[] | ListEnumStageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StageStatus[] | ListEnumStageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStageStatusWithAggregatesFilter<$PrismaModel> | $Enums.StageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStageStatusFilter<$PrismaModel>
    _max?: NestedEnumStageStatusFilter<$PrismaModel>
  }

  export type NestedEnumTenDayNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenDay | EnumTenDayFieldRefInput<$PrismaModel> | null
    in?: $Enums.TenDay[] | ListEnumTenDayFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TenDay[] | ListEnumTenDayFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTenDayNullableWithAggregatesFilter<$PrismaModel> | $Enums.TenDay | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTenDayNullableFilter<$PrismaModel>
    _max?: NestedEnumTenDayNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumStageImageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StageImageType | EnumStageImageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StageImageType[] | ListEnumStageImageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StageImageType[] | ListEnumStageImageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStageImageTypeFilter<$PrismaModel> | $Enums.StageImageType
  }

  export type NestedEnumStageImageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StageImageType | EnumStageImageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StageImageType[] | ListEnumStageImageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StageImageType[] | ListEnumStageImageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStageImageTypeWithAggregatesFilter<$PrismaModel> | $Enums.StageImageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStageImageTypeFilter<$PrismaModel>
    _max?: NestedEnumStageImageTypeFilter<$PrismaModel>
  }

  export type NestedEnumThresholdOperatorFilter<$PrismaModel = never> = {
    equals?: $Enums.ThresholdOperator | EnumThresholdOperatorFieldRefInput<$PrismaModel>
    in?: $Enums.ThresholdOperator[] | ListEnumThresholdOperatorFieldRefInput<$PrismaModel>
    notIn?: $Enums.ThresholdOperator[] | ListEnumThresholdOperatorFieldRefInput<$PrismaModel>
    not?: NestedEnumThresholdOperatorFilter<$PrismaModel> | $Enums.ThresholdOperator
  }

  export type NestedEnumThresholdOperatorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ThresholdOperator | EnumThresholdOperatorFieldRefInput<$PrismaModel>
    in?: $Enums.ThresholdOperator[] | ListEnumThresholdOperatorFieldRefInput<$PrismaModel>
    notIn?: $Enums.ThresholdOperator[] | ListEnumThresholdOperatorFieldRefInput<$PrismaModel>
    not?: NestedEnumThresholdOperatorWithAggregatesFilter<$PrismaModel> | $Enums.ThresholdOperator
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumThresholdOperatorFilter<$PrismaModel>
    _max?: NestedEnumThresholdOperatorFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type CalendarCreateWithoutCropInput = {
    id?: string
    title: string
    creatorId: string
    creatorName: string
    isShared?: boolean
    isPublished?: boolean
    fileType?: $Enums.CalendarFileType
    allowCenterUse?: boolean
    publishedAt?: Date | string | null
    lastEditedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    stages?: StageCreateNestedManyWithoutCalendarInput
    calendarZones?: CalendarZoneCreateNestedManyWithoutCalendarInput
    calendarIndicators?: CalendarIndicatorCreateNestedManyWithoutCalendarInput
  }

  export type CalendarUncheckedCreateWithoutCropInput = {
    id?: string
    title: string
    creatorId: string
    creatorName: string
    isShared?: boolean
    isPublished?: boolean
    fileType?: $Enums.CalendarFileType
    allowCenterUse?: boolean
    publishedAt?: Date | string | null
    lastEditedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    stages?: StageUncheckedCreateNestedManyWithoutCalendarInput
    calendarZones?: CalendarZoneUncheckedCreateNestedManyWithoutCalendarInput
    calendarIndicators?: CalendarIndicatorUncheckedCreateNestedManyWithoutCalendarInput
  }

  export type CalendarCreateOrConnectWithoutCropInput = {
    where: CalendarWhereUniqueInput
    create: XOR<CalendarCreateWithoutCropInput, CalendarUncheckedCreateWithoutCropInput>
  }

  export type CalendarCreateManyCropInputEnvelope = {
    data: CalendarCreateManyCropInput | CalendarCreateManyCropInput[]
    skipDuplicates?: boolean
  }

  export type CalendarUpsertWithWhereUniqueWithoutCropInput = {
    where: CalendarWhereUniqueInput
    update: XOR<CalendarUpdateWithoutCropInput, CalendarUncheckedUpdateWithoutCropInput>
    create: XOR<CalendarCreateWithoutCropInput, CalendarUncheckedCreateWithoutCropInput>
  }

  export type CalendarUpdateWithWhereUniqueWithoutCropInput = {
    where: CalendarWhereUniqueInput
    data: XOR<CalendarUpdateWithoutCropInput, CalendarUncheckedUpdateWithoutCropInput>
  }

  export type CalendarUpdateManyWithWhereWithoutCropInput = {
    where: CalendarScalarWhereInput
    data: XOR<CalendarUpdateManyMutationInput, CalendarUncheckedUpdateManyWithoutCropInput>
  }

  export type CalendarScalarWhereInput = {
    AND?: CalendarScalarWhereInput | CalendarScalarWhereInput[]
    OR?: CalendarScalarWhereInput[]
    NOT?: CalendarScalarWhereInput | CalendarScalarWhereInput[]
    id?: StringFilter<"Calendar"> | string
    cropId?: StringFilter<"Calendar"> | string
    title?: StringFilter<"Calendar"> | string
    creatorId?: StringFilter<"Calendar"> | string
    creatorName?: StringFilter<"Calendar"> | string
    isShared?: BoolFilter<"Calendar"> | boolean
    isPublished?: BoolFilter<"Calendar"> | boolean
    fileType?: EnumCalendarFileTypeFilter<"Calendar"> | $Enums.CalendarFileType
    allowCenterUse?: BoolFilter<"Calendar"> | boolean
    publishedAt?: DateTimeNullableFilter<"Calendar"> | Date | string | null
    lastEditedAt?: DateTimeFilter<"Calendar"> | Date | string
    createdAt?: DateTimeFilter<"Calendar"> | Date | string
    updatedAt?: DateTimeFilter<"Calendar"> | Date | string
  }

  export type IndicatorCreateWithoutCategoryInput = {
    id?: string
    name: string
    unit: string
    description?: string | null
    source?: string
    defaultMin?: number | null
    defaultMax?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    thresholds?: StageThresholdCreateNestedManyWithoutIndicatorInput
    calendarIndicators?: CalendarIndicatorCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    unit: string
    description?: string | null
    source?: string
    defaultMin?: number | null
    defaultMax?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    thresholds?: StageThresholdUncheckedCreateNestedManyWithoutIndicatorInput
    calendarIndicators?: CalendarIndicatorUncheckedCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorCreateOrConnectWithoutCategoryInput = {
    where: IndicatorWhereUniqueInput
    create: XOR<IndicatorCreateWithoutCategoryInput, IndicatorUncheckedCreateWithoutCategoryInput>
  }

  export type IndicatorCreateManyCategoryInputEnvelope = {
    data: IndicatorCreateManyCategoryInput | IndicatorCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type IndicatorUpsertWithWhereUniqueWithoutCategoryInput = {
    where: IndicatorWhereUniqueInput
    update: XOR<IndicatorUpdateWithoutCategoryInput, IndicatorUncheckedUpdateWithoutCategoryInput>
    create: XOR<IndicatorCreateWithoutCategoryInput, IndicatorUncheckedCreateWithoutCategoryInput>
  }

  export type IndicatorUpdateWithWhereUniqueWithoutCategoryInput = {
    where: IndicatorWhereUniqueInput
    data: XOR<IndicatorUpdateWithoutCategoryInput, IndicatorUncheckedUpdateWithoutCategoryInput>
  }

  export type IndicatorUpdateManyWithWhereWithoutCategoryInput = {
    where: IndicatorScalarWhereInput
    data: XOR<IndicatorUpdateManyMutationInput, IndicatorUncheckedUpdateManyWithoutCategoryInput>
  }

  export type IndicatorScalarWhereInput = {
    AND?: IndicatorScalarWhereInput | IndicatorScalarWhereInput[]
    OR?: IndicatorScalarWhereInput[]
    NOT?: IndicatorScalarWhereInput | IndicatorScalarWhereInput[]
    id?: StringFilter<"Indicator"> | string
    categoryId?: StringFilter<"Indicator"> | string
    name?: StringFilter<"Indicator"> | string
    unit?: StringFilter<"Indicator"> | string
    description?: StringNullableFilter<"Indicator"> | string | null
    source?: StringFilter<"Indicator"> | string
    defaultMin?: FloatNullableFilter<"Indicator"> | number | null
    defaultMax?: FloatNullableFilter<"Indicator"> | number | null
    createdAt?: DateTimeFilter<"Indicator"> | Date | string
    updatedAt?: DateTimeFilter<"Indicator"> | Date | string
  }

  export type IndicatorCategoryCreateWithoutIndicatorsInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndicatorCategoryUncheckedCreateWithoutIndicatorsInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndicatorCategoryCreateOrConnectWithoutIndicatorsInput = {
    where: IndicatorCategoryWhereUniqueInput
    create: XOR<IndicatorCategoryCreateWithoutIndicatorsInput, IndicatorCategoryUncheckedCreateWithoutIndicatorsInput>
  }

  export type StageThresholdCreateWithoutIndicatorInput = {
    id?: string
    operator: $Enums.ThresholdOperator
    value: number
    unit?: string | null
    durationDays?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    stage: StageCreateNestedOneWithoutThresholdsInput
  }

  export type StageThresholdUncheckedCreateWithoutIndicatorInput = {
    id?: string
    stageId: string
    operator: $Enums.ThresholdOperator
    value: number
    unit?: string | null
    durationDays?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageThresholdCreateOrConnectWithoutIndicatorInput = {
    where: StageThresholdWhereUniqueInput
    create: XOR<StageThresholdCreateWithoutIndicatorInput, StageThresholdUncheckedCreateWithoutIndicatorInput>
  }

  export type StageThresholdCreateManyIndicatorInputEnvelope = {
    data: StageThresholdCreateManyIndicatorInput | StageThresholdCreateManyIndicatorInput[]
    skipDuplicates?: boolean
  }

  export type CalendarIndicatorCreateWithoutIndicatorInput = {
    id?: string
    nameSnapshot: string
    createdAt?: Date | string
    updatedAt?: Date | string
    calendar: CalendarCreateNestedOneWithoutCalendarIndicatorsInput
  }

  export type CalendarIndicatorUncheckedCreateWithoutIndicatorInput = {
    id?: string
    calendarId: string
    nameSnapshot: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarIndicatorCreateOrConnectWithoutIndicatorInput = {
    where: CalendarIndicatorWhereUniqueInput
    create: XOR<CalendarIndicatorCreateWithoutIndicatorInput, CalendarIndicatorUncheckedCreateWithoutIndicatorInput>
  }

  export type CalendarIndicatorCreateManyIndicatorInputEnvelope = {
    data: CalendarIndicatorCreateManyIndicatorInput | CalendarIndicatorCreateManyIndicatorInput[]
    skipDuplicates?: boolean
  }

  export type IndicatorCategoryUpsertWithoutIndicatorsInput = {
    update: XOR<IndicatorCategoryUpdateWithoutIndicatorsInput, IndicatorCategoryUncheckedUpdateWithoutIndicatorsInput>
    create: XOR<IndicatorCategoryCreateWithoutIndicatorsInput, IndicatorCategoryUncheckedCreateWithoutIndicatorsInput>
    where?: IndicatorCategoryWhereInput
  }

  export type IndicatorCategoryUpdateToOneWithWhereWithoutIndicatorsInput = {
    where?: IndicatorCategoryWhereInput
    data: XOR<IndicatorCategoryUpdateWithoutIndicatorsInput, IndicatorCategoryUncheckedUpdateWithoutIndicatorsInput>
  }

  export type IndicatorCategoryUpdateWithoutIndicatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicatorCategoryUncheckedUpdateWithoutIndicatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageThresholdUpsertWithWhereUniqueWithoutIndicatorInput = {
    where: StageThresholdWhereUniqueInput
    update: XOR<StageThresholdUpdateWithoutIndicatorInput, StageThresholdUncheckedUpdateWithoutIndicatorInput>
    create: XOR<StageThresholdCreateWithoutIndicatorInput, StageThresholdUncheckedCreateWithoutIndicatorInput>
  }

  export type StageThresholdUpdateWithWhereUniqueWithoutIndicatorInput = {
    where: StageThresholdWhereUniqueInput
    data: XOR<StageThresholdUpdateWithoutIndicatorInput, StageThresholdUncheckedUpdateWithoutIndicatorInput>
  }

  export type StageThresholdUpdateManyWithWhereWithoutIndicatorInput = {
    where: StageThresholdScalarWhereInput
    data: XOR<StageThresholdUpdateManyMutationInput, StageThresholdUncheckedUpdateManyWithoutIndicatorInput>
  }

  export type StageThresholdScalarWhereInput = {
    AND?: StageThresholdScalarWhereInput | StageThresholdScalarWhereInput[]
    OR?: StageThresholdScalarWhereInput[]
    NOT?: StageThresholdScalarWhereInput | StageThresholdScalarWhereInput[]
    id?: StringFilter<"StageThreshold"> | string
    stageId?: StringFilter<"StageThreshold"> | string
    indicatorId?: StringFilter<"StageThreshold"> | string
    operator?: EnumThresholdOperatorFilter<"StageThreshold"> | $Enums.ThresholdOperator
    value?: FloatFilter<"StageThreshold"> | number
    unit?: StringNullableFilter<"StageThreshold"> | string | null
    durationDays?: IntFilter<"StageThreshold"> | number
    createdAt?: DateTimeFilter<"StageThreshold"> | Date | string
    updatedAt?: DateTimeFilter<"StageThreshold"> | Date | string
  }

  export type CalendarIndicatorUpsertWithWhereUniqueWithoutIndicatorInput = {
    where: CalendarIndicatorWhereUniqueInput
    update: XOR<CalendarIndicatorUpdateWithoutIndicatorInput, CalendarIndicatorUncheckedUpdateWithoutIndicatorInput>
    create: XOR<CalendarIndicatorCreateWithoutIndicatorInput, CalendarIndicatorUncheckedCreateWithoutIndicatorInput>
  }

  export type CalendarIndicatorUpdateWithWhereUniqueWithoutIndicatorInput = {
    where: CalendarIndicatorWhereUniqueInput
    data: XOR<CalendarIndicatorUpdateWithoutIndicatorInput, CalendarIndicatorUncheckedUpdateWithoutIndicatorInput>
  }

  export type CalendarIndicatorUpdateManyWithWhereWithoutIndicatorInput = {
    where: CalendarIndicatorScalarWhereInput
    data: XOR<CalendarIndicatorUpdateManyMutationInput, CalendarIndicatorUncheckedUpdateManyWithoutIndicatorInput>
  }

  export type CalendarIndicatorScalarWhereInput = {
    AND?: CalendarIndicatorScalarWhereInput | CalendarIndicatorScalarWhereInput[]
    OR?: CalendarIndicatorScalarWhereInput[]
    NOT?: CalendarIndicatorScalarWhereInput | CalendarIndicatorScalarWhereInput[]
    id?: StringFilter<"CalendarIndicator"> | string
    calendarId?: StringFilter<"CalendarIndicator"> | string
    indicatorId?: StringFilter<"CalendarIndicator"> | string
    nameSnapshot?: StringFilter<"CalendarIndicator"> | string
    createdAt?: DateTimeFilter<"CalendarIndicator"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarIndicator"> | Date | string
  }

  export type ZoneDistrictCreateWithoutZoneInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    district: DistrictCreateNestedOneWithoutZoneDistrictsInput
  }

  export type ZoneDistrictUncheckedCreateWithoutZoneInput = {
    districtId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZoneDistrictCreateOrConnectWithoutZoneInput = {
    where: ZoneDistrictWhereUniqueInput
    create: XOR<ZoneDistrictCreateWithoutZoneInput, ZoneDistrictUncheckedCreateWithoutZoneInput>
  }

  export type ZoneDistrictCreateManyZoneInputEnvelope = {
    data: ZoneDistrictCreateManyZoneInput | ZoneDistrictCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type CalendarZoneCreateWithoutZoneInput = {
    id?: string
    zoneName: string
    cityCount?: number
    districtCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    calendar: CalendarCreateNestedOneWithoutCalendarZonesInput
    districts?: CalendarZoneDistrictCreateNestedManyWithoutCalendarZoneInput
  }

  export type CalendarZoneUncheckedCreateWithoutZoneInput = {
    id?: string
    calendarId: string
    zoneName: string
    cityCount?: number
    districtCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    districts?: CalendarZoneDistrictUncheckedCreateNestedManyWithoutCalendarZoneInput
  }

  export type CalendarZoneCreateOrConnectWithoutZoneInput = {
    where: CalendarZoneWhereUniqueInput
    create: XOR<CalendarZoneCreateWithoutZoneInput, CalendarZoneUncheckedCreateWithoutZoneInput>
  }

  export type CalendarZoneCreateManyZoneInputEnvelope = {
    data: CalendarZoneCreateManyZoneInput | CalendarZoneCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type ZoneDistrictUpsertWithWhereUniqueWithoutZoneInput = {
    where: ZoneDistrictWhereUniqueInput
    update: XOR<ZoneDistrictUpdateWithoutZoneInput, ZoneDistrictUncheckedUpdateWithoutZoneInput>
    create: XOR<ZoneDistrictCreateWithoutZoneInput, ZoneDistrictUncheckedCreateWithoutZoneInput>
  }

  export type ZoneDistrictUpdateWithWhereUniqueWithoutZoneInput = {
    where: ZoneDistrictWhereUniqueInput
    data: XOR<ZoneDistrictUpdateWithoutZoneInput, ZoneDistrictUncheckedUpdateWithoutZoneInput>
  }

  export type ZoneDistrictUpdateManyWithWhereWithoutZoneInput = {
    where: ZoneDistrictScalarWhereInput
    data: XOR<ZoneDistrictUpdateManyMutationInput, ZoneDistrictUncheckedUpdateManyWithoutZoneInput>
  }

  export type ZoneDistrictScalarWhereInput = {
    AND?: ZoneDistrictScalarWhereInput | ZoneDistrictScalarWhereInput[]
    OR?: ZoneDistrictScalarWhereInput[]
    NOT?: ZoneDistrictScalarWhereInput | ZoneDistrictScalarWhereInput[]
    zoneId?: StringFilter<"ZoneDistrict"> | string
    districtId?: IntFilter<"ZoneDistrict"> | number
    createdAt?: DateTimeFilter<"ZoneDistrict"> | Date | string
    updatedAt?: DateTimeFilter<"ZoneDistrict"> | Date | string
  }

  export type CalendarZoneUpsertWithWhereUniqueWithoutZoneInput = {
    where: CalendarZoneWhereUniqueInput
    update: XOR<CalendarZoneUpdateWithoutZoneInput, CalendarZoneUncheckedUpdateWithoutZoneInput>
    create: XOR<CalendarZoneCreateWithoutZoneInput, CalendarZoneUncheckedCreateWithoutZoneInput>
  }

  export type CalendarZoneUpdateWithWhereUniqueWithoutZoneInput = {
    where: CalendarZoneWhereUniqueInput
    data: XOR<CalendarZoneUpdateWithoutZoneInput, CalendarZoneUncheckedUpdateWithoutZoneInput>
  }

  export type CalendarZoneUpdateManyWithWhereWithoutZoneInput = {
    where: CalendarZoneScalarWhereInput
    data: XOR<CalendarZoneUpdateManyMutationInput, CalendarZoneUncheckedUpdateManyWithoutZoneInput>
  }

  export type CalendarZoneScalarWhereInput = {
    AND?: CalendarZoneScalarWhereInput | CalendarZoneScalarWhereInput[]
    OR?: CalendarZoneScalarWhereInput[]
    NOT?: CalendarZoneScalarWhereInput | CalendarZoneScalarWhereInput[]
    id?: StringFilter<"CalendarZone"> | string
    calendarId?: StringFilter<"CalendarZone"> | string
    zoneId?: StringFilter<"CalendarZone"> | string
    zoneName?: StringFilter<"CalendarZone"> | string
    cityCount?: IntFilter<"CalendarZone"> | number
    districtCount?: IntFilter<"CalendarZone"> | number
    createdAt?: DateTimeFilter<"CalendarZone"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarZone"> | Date | string
  }

  export type DistrictCreateWithoutCityInput = {
    id: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    zoneDistricts?: ZoneDistrictCreateNestedManyWithoutDistrictInput
    calendarZoneDistricts?: CalendarZoneDistrictCreateNestedManyWithoutDistrictInput
  }

  export type DistrictUncheckedCreateWithoutCityInput = {
    id: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    zoneDistricts?: ZoneDistrictUncheckedCreateNestedManyWithoutDistrictInput
    calendarZoneDistricts?: CalendarZoneDistrictUncheckedCreateNestedManyWithoutDistrictInput
  }

  export type DistrictCreateOrConnectWithoutCityInput = {
    where: DistrictWhereUniqueInput
    create: XOR<DistrictCreateWithoutCityInput, DistrictUncheckedCreateWithoutCityInput>
  }

  export type DistrictCreateManyCityInputEnvelope = {
    data: DistrictCreateManyCityInput | DistrictCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type DistrictUpsertWithWhereUniqueWithoutCityInput = {
    where: DistrictWhereUniqueInput
    update: XOR<DistrictUpdateWithoutCityInput, DistrictUncheckedUpdateWithoutCityInput>
    create: XOR<DistrictCreateWithoutCityInput, DistrictUncheckedCreateWithoutCityInput>
  }

  export type DistrictUpdateWithWhereUniqueWithoutCityInput = {
    where: DistrictWhereUniqueInput
    data: XOR<DistrictUpdateWithoutCityInput, DistrictUncheckedUpdateWithoutCityInput>
  }

  export type DistrictUpdateManyWithWhereWithoutCityInput = {
    where: DistrictScalarWhereInput
    data: XOR<DistrictUpdateManyMutationInput, DistrictUncheckedUpdateManyWithoutCityInput>
  }

  export type DistrictScalarWhereInput = {
    AND?: DistrictScalarWhereInput | DistrictScalarWhereInput[]
    OR?: DistrictScalarWhereInput[]
    NOT?: DistrictScalarWhereInput | DistrictScalarWhereInput[]
    id?: IntFilter<"District"> | number
    name?: StringFilter<"District"> | string
    cityId?: IntFilter<"District"> | number
    createdAt?: DateTimeFilter<"District"> | Date | string
    updatedAt?: DateTimeFilter<"District"> | Date | string
  }

  export type CityCreateWithoutDistrictsInput = {
    id: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CityUncheckedCreateWithoutDistrictsInput = {
    id: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CityCreateOrConnectWithoutDistrictsInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutDistrictsInput, CityUncheckedCreateWithoutDistrictsInput>
  }

  export type ZoneDistrictCreateWithoutDistrictInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    zone: ZoneCreateNestedOneWithoutZoneDistrictsInput
  }

  export type ZoneDistrictUncheckedCreateWithoutDistrictInput = {
    zoneId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZoneDistrictCreateOrConnectWithoutDistrictInput = {
    where: ZoneDistrictWhereUniqueInput
    create: XOR<ZoneDistrictCreateWithoutDistrictInput, ZoneDistrictUncheckedCreateWithoutDistrictInput>
  }

  export type ZoneDistrictCreateManyDistrictInputEnvelope = {
    data: ZoneDistrictCreateManyDistrictInput | ZoneDistrictCreateManyDistrictInput[]
    skipDuplicates?: boolean
  }

  export type CalendarZoneDistrictCreateWithoutDistrictInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    calendarZone: CalendarZoneCreateNestedOneWithoutDistrictsInput
  }

  export type CalendarZoneDistrictUncheckedCreateWithoutDistrictInput = {
    calendarZoneId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarZoneDistrictCreateOrConnectWithoutDistrictInput = {
    where: CalendarZoneDistrictWhereUniqueInput
    create: XOR<CalendarZoneDistrictCreateWithoutDistrictInput, CalendarZoneDistrictUncheckedCreateWithoutDistrictInput>
  }

  export type CalendarZoneDistrictCreateManyDistrictInputEnvelope = {
    data: CalendarZoneDistrictCreateManyDistrictInput | CalendarZoneDistrictCreateManyDistrictInput[]
    skipDuplicates?: boolean
  }

  export type CityUpsertWithoutDistrictsInput = {
    update: XOR<CityUpdateWithoutDistrictsInput, CityUncheckedUpdateWithoutDistrictsInput>
    create: XOR<CityCreateWithoutDistrictsInput, CityUncheckedCreateWithoutDistrictsInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutDistrictsInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutDistrictsInput, CityUncheckedUpdateWithoutDistrictsInput>
  }

  export type CityUpdateWithoutDistrictsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUncheckedUpdateWithoutDistrictsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneDistrictUpsertWithWhereUniqueWithoutDistrictInput = {
    where: ZoneDistrictWhereUniqueInput
    update: XOR<ZoneDistrictUpdateWithoutDistrictInput, ZoneDistrictUncheckedUpdateWithoutDistrictInput>
    create: XOR<ZoneDistrictCreateWithoutDistrictInput, ZoneDistrictUncheckedCreateWithoutDistrictInput>
  }

  export type ZoneDistrictUpdateWithWhereUniqueWithoutDistrictInput = {
    where: ZoneDistrictWhereUniqueInput
    data: XOR<ZoneDistrictUpdateWithoutDistrictInput, ZoneDistrictUncheckedUpdateWithoutDistrictInput>
  }

  export type ZoneDistrictUpdateManyWithWhereWithoutDistrictInput = {
    where: ZoneDistrictScalarWhereInput
    data: XOR<ZoneDistrictUpdateManyMutationInput, ZoneDistrictUncheckedUpdateManyWithoutDistrictInput>
  }

  export type CalendarZoneDistrictUpsertWithWhereUniqueWithoutDistrictInput = {
    where: CalendarZoneDistrictWhereUniqueInput
    update: XOR<CalendarZoneDistrictUpdateWithoutDistrictInput, CalendarZoneDistrictUncheckedUpdateWithoutDistrictInput>
    create: XOR<CalendarZoneDistrictCreateWithoutDistrictInput, CalendarZoneDistrictUncheckedCreateWithoutDistrictInput>
  }

  export type CalendarZoneDistrictUpdateWithWhereUniqueWithoutDistrictInput = {
    where: CalendarZoneDistrictWhereUniqueInput
    data: XOR<CalendarZoneDistrictUpdateWithoutDistrictInput, CalendarZoneDistrictUncheckedUpdateWithoutDistrictInput>
  }

  export type CalendarZoneDistrictUpdateManyWithWhereWithoutDistrictInput = {
    where: CalendarZoneDistrictScalarWhereInput
    data: XOR<CalendarZoneDistrictUpdateManyMutationInput, CalendarZoneDistrictUncheckedUpdateManyWithoutDistrictInput>
  }

  export type CalendarZoneDistrictScalarWhereInput = {
    AND?: CalendarZoneDistrictScalarWhereInput | CalendarZoneDistrictScalarWhereInput[]
    OR?: CalendarZoneDistrictScalarWhereInput[]
    NOT?: CalendarZoneDistrictScalarWhereInput | CalendarZoneDistrictScalarWhereInput[]
    calendarZoneId?: StringFilter<"CalendarZoneDistrict"> | string
    districtId?: IntFilter<"CalendarZoneDistrict"> | number
    createdAt?: DateTimeFilter<"CalendarZoneDistrict"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarZoneDistrict"> | Date | string
  }

  export type ZoneCreateWithoutZoneDistrictsInput = {
    id?: string
    zoneName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    calendarZones?: CalendarZoneCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutZoneDistrictsInput = {
    id?: string
    zoneName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    calendarZones?: CalendarZoneUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutZoneDistrictsInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutZoneDistrictsInput, ZoneUncheckedCreateWithoutZoneDistrictsInput>
  }

  export type DistrictCreateWithoutZoneDistrictsInput = {
    id: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutDistrictsInput
    calendarZoneDistricts?: CalendarZoneDistrictCreateNestedManyWithoutDistrictInput
  }

  export type DistrictUncheckedCreateWithoutZoneDistrictsInput = {
    id: number
    name: string
    cityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    calendarZoneDistricts?: CalendarZoneDistrictUncheckedCreateNestedManyWithoutDistrictInput
  }

  export type DistrictCreateOrConnectWithoutZoneDistrictsInput = {
    where: DistrictWhereUniqueInput
    create: XOR<DistrictCreateWithoutZoneDistrictsInput, DistrictUncheckedCreateWithoutZoneDistrictsInput>
  }

  export type ZoneUpsertWithoutZoneDistrictsInput = {
    update: XOR<ZoneUpdateWithoutZoneDistrictsInput, ZoneUncheckedUpdateWithoutZoneDistrictsInput>
    create: XOR<ZoneCreateWithoutZoneDistrictsInput, ZoneUncheckedCreateWithoutZoneDistrictsInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutZoneDistrictsInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutZoneDistrictsInput, ZoneUncheckedUpdateWithoutZoneDistrictsInput>
  }

  export type ZoneUpdateWithoutZoneDistrictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendarZones?: CalendarZoneUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutZoneDistrictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendarZones?: CalendarZoneUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type DistrictUpsertWithoutZoneDistrictsInput = {
    update: XOR<DistrictUpdateWithoutZoneDistrictsInput, DistrictUncheckedUpdateWithoutZoneDistrictsInput>
    create: XOR<DistrictCreateWithoutZoneDistrictsInput, DistrictUncheckedCreateWithoutZoneDistrictsInput>
    where?: DistrictWhereInput
  }

  export type DistrictUpdateToOneWithWhereWithoutZoneDistrictsInput = {
    where?: DistrictWhereInput
    data: XOR<DistrictUpdateWithoutZoneDistrictsInput, DistrictUncheckedUpdateWithoutZoneDistrictsInput>
  }

  export type DistrictUpdateWithoutZoneDistrictsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutDistrictsNestedInput
    calendarZoneDistricts?: CalendarZoneDistrictUpdateManyWithoutDistrictNestedInput
  }

  export type DistrictUncheckedUpdateWithoutZoneDistrictsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendarZoneDistricts?: CalendarZoneDistrictUncheckedUpdateManyWithoutDistrictNestedInput
  }

  export type CropCreateWithoutCalendarsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CropUncheckedCreateWithoutCalendarsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CropCreateOrConnectWithoutCalendarsInput = {
    where: CropWhereUniqueInput
    create: XOR<CropCreateWithoutCalendarsInput, CropUncheckedCreateWithoutCalendarsInput>
  }

  export type StageCreateWithoutCalendarInput = {
    id?: string
    order?: number
    name: string
    description?: string | null
    status?: $Enums.StageStatus
    color?: string
    startTenDay?: $Enums.TenDay | null
    startMonth?: number | null
    endTenDay?: $Enums.TenDay | null
    endMonth?: number | null
    analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: StageImageCreateNestedManyWithoutStageInput
    thresholds?: StageThresholdCreateNestedManyWithoutStageInput
  }

  export type StageUncheckedCreateWithoutCalendarInput = {
    id?: string
    order?: number
    name: string
    description?: string | null
    status?: $Enums.StageStatus
    color?: string
    startTenDay?: $Enums.TenDay | null
    startMonth?: number | null
    endTenDay?: $Enums.TenDay | null
    endMonth?: number | null
    analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: StageImageUncheckedCreateNestedManyWithoutStageInput
    thresholds?: StageThresholdUncheckedCreateNestedManyWithoutStageInput
  }

  export type StageCreateOrConnectWithoutCalendarInput = {
    where: StageWhereUniqueInput
    create: XOR<StageCreateWithoutCalendarInput, StageUncheckedCreateWithoutCalendarInput>
  }

  export type StageCreateManyCalendarInputEnvelope = {
    data: StageCreateManyCalendarInput | StageCreateManyCalendarInput[]
    skipDuplicates?: boolean
  }

  export type CalendarZoneCreateWithoutCalendarInput = {
    id?: string
    zoneName: string
    cityCount?: number
    districtCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    zone: ZoneCreateNestedOneWithoutCalendarZonesInput
    districts?: CalendarZoneDistrictCreateNestedManyWithoutCalendarZoneInput
  }

  export type CalendarZoneUncheckedCreateWithoutCalendarInput = {
    id?: string
    zoneId: string
    zoneName: string
    cityCount?: number
    districtCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    districts?: CalendarZoneDistrictUncheckedCreateNestedManyWithoutCalendarZoneInput
  }

  export type CalendarZoneCreateOrConnectWithoutCalendarInput = {
    where: CalendarZoneWhereUniqueInput
    create: XOR<CalendarZoneCreateWithoutCalendarInput, CalendarZoneUncheckedCreateWithoutCalendarInput>
  }

  export type CalendarZoneCreateManyCalendarInputEnvelope = {
    data: CalendarZoneCreateManyCalendarInput | CalendarZoneCreateManyCalendarInput[]
    skipDuplicates?: boolean
  }

  export type CalendarIndicatorCreateWithoutCalendarInput = {
    id?: string
    nameSnapshot: string
    createdAt?: Date | string
    updatedAt?: Date | string
    indicator: IndicatorCreateNestedOneWithoutCalendarIndicatorsInput
  }

  export type CalendarIndicatorUncheckedCreateWithoutCalendarInput = {
    id?: string
    indicatorId: string
    nameSnapshot: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarIndicatorCreateOrConnectWithoutCalendarInput = {
    where: CalendarIndicatorWhereUniqueInput
    create: XOR<CalendarIndicatorCreateWithoutCalendarInput, CalendarIndicatorUncheckedCreateWithoutCalendarInput>
  }

  export type CalendarIndicatorCreateManyCalendarInputEnvelope = {
    data: CalendarIndicatorCreateManyCalendarInput | CalendarIndicatorCreateManyCalendarInput[]
    skipDuplicates?: boolean
  }

  export type CropUpsertWithoutCalendarsInput = {
    update: XOR<CropUpdateWithoutCalendarsInput, CropUncheckedUpdateWithoutCalendarsInput>
    create: XOR<CropCreateWithoutCalendarsInput, CropUncheckedCreateWithoutCalendarsInput>
    where?: CropWhereInput
  }

  export type CropUpdateToOneWithWhereWithoutCalendarsInput = {
    where?: CropWhereInput
    data: XOR<CropUpdateWithoutCalendarsInput, CropUncheckedUpdateWithoutCalendarsInput>
  }

  export type CropUpdateWithoutCalendarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropUncheckedUpdateWithoutCalendarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageUpsertWithWhereUniqueWithoutCalendarInput = {
    where: StageWhereUniqueInput
    update: XOR<StageUpdateWithoutCalendarInput, StageUncheckedUpdateWithoutCalendarInput>
    create: XOR<StageCreateWithoutCalendarInput, StageUncheckedCreateWithoutCalendarInput>
  }

  export type StageUpdateWithWhereUniqueWithoutCalendarInput = {
    where: StageWhereUniqueInput
    data: XOR<StageUpdateWithoutCalendarInput, StageUncheckedUpdateWithoutCalendarInput>
  }

  export type StageUpdateManyWithWhereWithoutCalendarInput = {
    where: StageScalarWhereInput
    data: XOR<StageUpdateManyMutationInput, StageUncheckedUpdateManyWithoutCalendarInput>
  }

  export type StageScalarWhereInput = {
    AND?: StageScalarWhereInput | StageScalarWhereInput[]
    OR?: StageScalarWhereInput[]
    NOT?: StageScalarWhereInput | StageScalarWhereInput[]
    id?: StringFilter<"Stage"> | string
    calendarId?: StringFilter<"Stage"> | string
    order?: IntFilter<"Stage"> | number
    name?: StringFilter<"Stage"> | string
    description?: StringNullableFilter<"Stage"> | string | null
    status?: EnumStageStatusFilter<"Stage"> | $Enums.StageStatus
    color?: StringFilter<"Stage"> | string
    startTenDay?: EnumTenDayNullableFilter<"Stage"> | $Enums.TenDay | null
    startMonth?: IntNullableFilter<"Stage"> | number | null
    endTenDay?: EnumTenDayNullableFilter<"Stage"> | $Enums.TenDay | null
    endMonth?: IntNullableFilter<"Stage"> | number | null
    analysis?: JsonNullableFilter<"Stage">
    createdAt?: DateTimeFilter<"Stage"> | Date | string
    updatedAt?: DateTimeFilter<"Stage"> | Date | string
  }

  export type CalendarZoneUpsertWithWhereUniqueWithoutCalendarInput = {
    where: CalendarZoneWhereUniqueInput
    update: XOR<CalendarZoneUpdateWithoutCalendarInput, CalendarZoneUncheckedUpdateWithoutCalendarInput>
    create: XOR<CalendarZoneCreateWithoutCalendarInput, CalendarZoneUncheckedCreateWithoutCalendarInput>
  }

  export type CalendarZoneUpdateWithWhereUniqueWithoutCalendarInput = {
    where: CalendarZoneWhereUniqueInput
    data: XOR<CalendarZoneUpdateWithoutCalendarInput, CalendarZoneUncheckedUpdateWithoutCalendarInput>
  }

  export type CalendarZoneUpdateManyWithWhereWithoutCalendarInput = {
    where: CalendarZoneScalarWhereInput
    data: XOR<CalendarZoneUpdateManyMutationInput, CalendarZoneUncheckedUpdateManyWithoutCalendarInput>
  }

  export type CalendarIndicatorUpsertWithWhereUniqueWithoutCalendarInput = {
    where: CalendarIndicatorWhereUniqueInput
    update: XOR<CalendarIndicatorUpdateWithoutCalendarInput, CalendarIndicatorUncheckedUpdateWithoutCalendarInput>
    create: XOR<CalendarIndicatorCreateWithoutCalendarInput, CalendarIndicatorUncheckedCreateWithoutCalendarInput>
  }

  export type CalendarIndicatorUpdateWithWhereUniqueWithoutCalendarInput = {
    where: CalendarIndicatorWhereUniqueInput
    data: XOR<CalendarIndicatorUpdateWithoutCalendarInput, CalendarIndicatorUncheckedUpdateWithoutCalendarInput>
  }

  export type CalendarIndicatorUpdateManyWithWhereWithoutCalendarInput = {
    where: CalendarIndicatorScalarWhereInput
    data: XOR<CalendarIndicatorUpdateManyMutationInput, CalendarIndicatorUncheckedUpdateManyWithoutCalendarInput>
  }

  export type CalendarCreateWithoutCalendarZonesInput = {
    id?: string
    title: string
    creatorId: string
    creatorName: string
    isShared?: boolean
    isPublished?: boolean
    fileType?: $Enums.CalendarFileType
    allowCenterUse?: boolean
    publishedAt?: Date | string | null
    lastEditedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    crop: CropCreateNestedOneWithoutCalendarsInput
    stages?: StageCreateNestedManyWithoutCalendarInput
    calendarIndicators?: CalendarIndicatorCreateNestedManyWithoutCalendarInput
  }

  export type CalendarUncheckedCreateWithoutCalendarZonesInput = {
    id?: string
    cropId: string
    title: string
    creatorId: string
    creatorName: string
    isShared?: boolean
    isPublished?: boolean
    fileType?: $Enums.CalendarFileType
    allowCenterUse?: boolean
    publishedAt?: Date | string | null
    lastEditedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    stages?: StageUncheckedCreateNestedManyWithoutCalendarInput
    calendarIndicators?: CalendarIndicatorUncheckedCreateNestedManyWithoutCalendarInput
  }

  export type CalendarCreateOrConnectWithoutCalendarZonesInput = {
    where: CalendarWhereUniqueInput
    create: XOR<CalendarCreateWithoutCalendarZonesInput, CalendarUncheckedCreateWithoutCalendarZonesInput>
  }

  export type ZoneCreateWithoutCalendarZonesInput = {
    id?: string
    zoneName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    zoneDistricts?: ZoneDistrictCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutCalendarZonesInput = {
    id?: string
    zoneName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    zoneDistricts?: ZoneDistrictUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutCalendarZonesInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutCalendarZonesInput, ZoneUncheckedCreateWithoutCalendarZonesInput>
  }

  export type CalendarZoneDistrictCreateWithoutCalendarZoneInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    district: DistrictCreateNestedOneWithoutCalendarZoneDistrictsInput
  }

  export type CalendarZoneDistrictUncheckedCreateWithoutCalendarZoneInput = {
    districtId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarZoneDistrictCreateOrConnectWithoutCalendarZoneInput = {
    where: CalendarZoneDistrictWhereUniqueInput
    create: XOR<CalendarZoneDistrictCreateWithoutCalendarZoneInput, CalendarZoneDistrictUncheckedCreateWithoutCalendarZoneInput>
  }

  export type CalendarZoneDistrictCreateManyCalendarZoneInputEnvelope = {
    data: CalendarZoneDistrictCreateManyCalendarZoneInput | CalendarZoneDistrictCreateManyCalendarZoneInput[]
    skipDuplicates?: boolean
  }

  export type CalendarUpsertWithoutCalendarZonesInput = {
    update: XOR<CalendarUpdateWithoutCalendarZonesInput, CalendarUncheckedUpdateWithoutCalendarZonesInput>
    create: XOR<CalendarCreateWithoutCalendarZonesInput, CalendarUncheckedCreateWithoutCalendarZonesInput>
    where?: CalendarWhereInput
  }

  export type CalendarUpdateToOneWithWhereWithoutCalendarZonesInput = {
    where?: CalendarWhereInput
    data: XOR<CalendarUpdateWithoutCalendarZonesInput, CalendarUncheckedUpdateWithoutCalendarZonesInput>
  }

  export type CalendarUpdateWithoutCalendarZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    creatorName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crop?: CropUpdateOneRequiredWithoutCalendarsNestedInput
    stages?: StageUpdateManyWithoutCalendarNestedInput
    calendarIndicators?: CalendarIndicatorUpdateManyWithoutCalendarNestedInput
  }

  export type CalendarUncheckedUpdateWithoutCalendarZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    creatorName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stages?: StageUncheckedUpdateManyWithoutCalendarNestedInput
    calendarIndicators?: CalendarIndicatorUncheckedUpdateManyWithoutCalendarNestedInput
  }

  export type ZoneUpsertWithoutCalendarZonesInput = {
    update: XOR<ZoneUpdateWithoutCalendarZonesInput, ZoneUncheckedUpdateWithoutCalendarZonesInput>
    create: XOR<ZoneCreateWithoutCalendarZonesInput, ZoneUncheckedCreateWithoutCalendarZonesInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutCalendarZonesInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutCalendarZonesInput, ZoneUncheckedUpdateWithoutCalendarZonesInput>
  }

  export type ZoneUpdateWithoutCalendarZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zoneDistricts?: ZoneDistrictUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutCalendarZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zoneDistricts?: ZoneDistrictUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type CalendarZoneDistrictUpsertWithWhereUniqueWithoutCalendarZoneInput = {
    where: CalendarZoneDistrictWhereUniqueInput
    update: XOR<CalendarZoneDistrictUpdateWithoutCalendarZoneInput, CalendarZoneDistrictUncheckedUpdateWithoutCalendarZoneInput>
    create: XOR<CalendarZoneDistrictCreateWithoutCalendarZoneInput, CalendarZoneDistrictUncheckedCreateWithoutCalendarZoneInput>
  }

  export type CalendarZoneDistrictUpdateWithWhereUniqueWithoutCalendarZoneInput = {
    where: CalendarZoneDistrictWhereUniqueInput
    data: XOR<CalendarZoneDistrictUpdateWithoutCalendarZoneInput, CalendarZoneDistrictUncheckedUpdateWithoutCalendarZoneInput>
  }

  export type CalendarZoneDistrictUpdateManyWithWhereWithoutCalendarZoneInput = {
    where: CalendarZoneDistrictScalarWhereInput
    data: XOR<CalendarZoneDistrictUpdateManyMutationInput, CalendarZoneDistrictUncheckedUpdateManyWithoutCalendarZoneInput>
  }

  export type CalendarZoneCreateWithoutDistrictsInput = {
    id?: string
    zoneName: string
    cityCount?: number
    districtCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    calendar: CalendarCreateNestedOneWithoutCalendarZonesInput
    zone: ZoneCreateNestedOneWithoutCalendarZonesInput
  }

  export type CalendarZoneUncheckedCreateWithoutDistrictsInput = {
    id?: string
    calendarId: string
    zoneId: string
    zoneName: string
    cityCount?: number
    districtCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarZoneCreateOrConnectWithoutDistrictsInput = {
    where: CalendarZoneWhereUniqueInput
    create: XOR<CalendarZoneCreateWithoutDistrictsInput, CalendarZoneUncheckedCreateWithoutDistrictsInput>
  }

  export type DistrictCreateWithoutCalendarZoneDistrictsInput = {
    id: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutDistrictsInput
    zoneDistricts?: ZoneDistrictCreateNestedManyWithoutDistrictInput
  }

  export type DistrictUncheckedCreateWithoutCalendarZoneDistrictsInput = {
    id: number
    name: string
    cityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    zoneDistricts?: ZoneDistrictUncheckedCreateNestedManyWithoutDistrictInput
  }

  export type DistrictCreateOrConnectWithoutCalendarZoneDistrictsInput = {
    where: DistrictWhereUniqueInput
    create: XOR<DistrictCreateWithoutCalendarZoneDistrictsInput, DistrictUncheckedCreateWithoutCalendarZoneDistrictsInput>
  }

  export type CalendarZoneUpsertWithoutDistrictsInput = {
    update: XOR<CalendarZoneUpdateWithoutDistrictsInput, CalendarZoneUncheckedUpdateWithoutDistrictsInput>
    create: XOR<CalendarZoneCreateWithoutDistrictsInput, CalendarZoneUncheckedCreateWithoutDistrictsInput>
    where?: CalendarZoneWhereInput
  }

  export type CalendarZoneUpdateToOneWithWhereWithoutDistrictsInput = {
    where?: CalendarZoneWhereInput
    data: XOR<CalendarZoneUpdateWithoutDistrictsInput, CalendarZoneUncheckedUpdateWithoutDistrictsInput>
  }

  export type CalendarZoneUpdateWithoutDistrictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    cityCount?: IntFieldUpdateOperationsInput | number
    districtCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendar?: CalendarUpdateOneRequiredWithoutCalendarZonesNestedInput
    zone?: ZoneUpdateOneRequiredWithoutCalendarZonesNestedInput
  }

  export type CalendarZoneUncheckedUpdateWithoutDistrictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    cityCount?: IntFieldUpdateOperationsInput | number
    districtCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DistrictUpsertWithoutCalendarZoneDistrictsInput = {
    update: XOR<DistrictUpdateWithoutCalendarZoneDistrictsInput, DistrictUncheckedUpdateWithoutCalendarZoneDistrictsInput>
    create: XOR<DistrictCreateWithoutCalendarZoneDistrictsInput, DistrictUncheckedCreateWithoutCalendarZoneDistrictsInput>
    where?: DistrictWhereInput
  }

  export type DistrictUpdateToOneWithWhereWithoutCalendarZoneDistrictsInput = {
    where?: DistrictWhereInput
    data: XOR<DistrictUpdateWithoutCalendarZoneDistrictsInput, DistrictUncheckedUpdateWithoutCalendarZoneDistrictsInput>
  }

  export type DistrictUpdateWithoutCalendarZoneDistrictsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutDistrictsNestedInput
    zoneDistricts?: ZoneDistrictUpdateManyWithoutDistrictNestedInput
  }

  export type DistrictUncheckedUpdateWithoutCalendarZoneDistrictsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zoneDistricts?: ZoneDistrictUncheckedUpdateManyWithoutDistrictNestedInput
  }

  export type CalendarCreateWithoutCalendarIndicatorsInput = {
    id?: string
    title: string
    creatorId: string
    creatorName: string
    isShared?: boolean
    isPublished?: boolean
    fileType?: $Enums.CalendarFileType
    allowCenterUse?: boolean
    publishedAt?: Date | string | null
    lastEditedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    crop: CropCreateNestedOneWithoutCalendarsInput
    stages?: StageCreateNestedManyWithoutCalendarInput
    calendarZones?: CalendarZoneCreateNestedManyWithoutCalendarInput
  }

  export type CalendarUncheckedCreateWithoutCalendarIndicatorsInput = {
    id?: string
    cropId: string
    title: string
    creatorId: string
    creatorName: string
    isShared?: boolean
    isPublished?: boolean
    fileType?: $Enums.CalendarFileType
    allowCenterUse?: boolean
    publishedAt?: Date | string | null
    lastEditedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    stages?: StageUncheckedCreateNestedManyWithoutCalendarInput
    calendarZones?: CalendarZoneUncheckedCreateNestedManyWithoutCalendarInput
  }

  export type CalendarCreateOrConnectWithoutCalendarIndicatorsInput = {
    where: CalendarWhereUniqueInput
    create: XOR<CalendarCreateWithoutCalendarIndicatorsInput, CalendarUncheckedCreateWithoutCalendarIndicatorsInput>
  }

  export type IndicatorCreateWithoutCalendarIndicatorsInput = {
    id?: string
    name: string
    unit: string
    description?: string | null
    source?: string
    defaultMin?: number | null
    defaultMax?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category: IndicatorCategoryCreateNestedOneWithoutIndicatorsInput
    thresholds?: StageThresholdCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorUncheckedCreateWithoutCalendarIndicatorsInput = {
    id?: string
    categoryId: string
    name: string
    unit: string
    description?: string | null
    source?: string
    defaultMin?: number | null
    defaultMax?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    thresholds?: StageThresholdUncheckedCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorCreateOrConnectWithoutCalendarIndicatorsInput = {
    where: IndicatorWhereUniqueInput
    create: XOR<IndicatorCreateWithoutCalendarIndicatorsInput, IndicatorUncheckedCreateWithoutCalendarIndicatorsInput>
  }

  export type CalendarUpsertWithoutCalendarIndicatorsInput = {
    update: XOR<CalendarUpdateWithoutCalendarIndicatorsInput, CalendarUncheckedUpdateWithoutCalendarIndicatorsInput>
    create: XOR<CalendarCreateWithoutCalendarIndicatorsInput, CalendarUncheckedCreateWithoutCalendarIndicatorsInput>
    where?: CalendarWhereInput
  }

  export type CalendarUpdateToOneWithWhereWithoutCalendarIndicatorsInput = {
    where?: CalendarWhereInput
    data: XOR<CalendarUpdateWithoutCalendarIndicatorsInput, CalendarUncheckedUpdateWithoutCalendarIndicatorsInput>
  }

  export type CalendarUpdateWithoutCalendarIndicatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    creatorName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crop?: CropUpdateOneRequiredWithoutCalendarsNestedInput
    stages?: StageUpdateManyWithoutCalendarNestedInput
    calendarZones?: CalendarZoneUpdateManyWithoutCalendarNestedInput
  }

  export type CalendarUncheckedUpdateWithoutCalendarIndicatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    creatorName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stages?: StageUncheckedUpdateManyWithoutCalendarNestedInput
    calendarZones?: CalendarZoneUncheckedUpdateManyWithoutCalendarNestedInput
  }

  export type IndicatorUpsertWithoutCalendarIndicatorsInput = {
    update: XOR<IndicatorUpdateWithoutCalendarIndicatorsInput, IndicatorUncheckedUpdateWithoutCalendarIndicatorsInput>
    create: XOR<IndicatorCreateWithoutCalendarIndicatorsInput, IndicatorUncheckedCreateWithoutCalendarIndicatorsInput>
    where?: IndicatorWhereInput
  }

  export type IndicatorUpdateToOneWithWhereWithoutCalendarIndicatorsInput = {
    where?: IndicatorWhereInput
    data: XOR<IndicatorUpdateWithoutCalendarIndicatorsInput, IndicatorUncheckedUpdateWithoutCalendarIndicatorsInput>
  }

  export type IndicatorUpdateWithoutCalendarIndicatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    defaultMin?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultMax?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: IndicatorCategoryUpdateOneRequiredWithoutIndicatorsNestedInput
    thresholds?: StageThresholdUpdateManyWithoutIndicatorNestedInput
  }

  export type IndicatorUncheckedUpdateWithoutCalendarIndicatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    defaultMin?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultMax?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thresholds?: StageThresholdUncheckedUpdateManyWithoutIndicatorNestedInput
  }

  export type CalendarCreateWithoutStagesInput = {
    id?: string
    title: string
    creatorId: string
    creatorName: string
    isShared?: boolean
    isPublished?: boolean
    fileType?: $Enums.CalendarFileType
    allowCenterUse?: boolean
    publishedAt?: Date | string | null
    lastEditedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    crop: CropCreateNestedOneWithoutCalendarsInput
    calendarZones?: CalendarZoneCreateNestedManyWithoutCalendarInput
    calendarIndicators?: CalendarIndicatorCreateNestedManyWithoutCalendarInput
  }

  export type CalendarUncheckedCreateWithoutStagesInput = {
    id?: string
    cropId: string
    title: string
    creatorId: string
    creatorName: string
    isShared?: boolean
    isPublished?: boolean
    fileType?: $Enums.CalendarFileType
    allowCenterUse?: boolean
    publishedAt?: Date | string | null
    lastEditedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    calendarZones?: CalendarZoneUncheckedCreateNestedManyWithoutCalendarInput
    calendarIndicators?: CalendarIndicatorUncheckedCreateNestedManyWithoutCalendarInput
  }

  export type CalendarCreateOrConnectWithoutStagesInput = {
    where: CalendarWhereUniqueInput
    create: XOR<CalendarCreateWithoutStagesInput, CalendarUncheckedCreateWithoutStagesInput>
  }

  export type StageImageCreateWithoutStageInput = {
    id?: string
    type: $Enums.StageImageType
    url: string
    thumbnail?: string | null
    name?: string | null
    source?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageImageUncheckedCreateWithoutStageInput = {
    id?: string
    type: $Enums.StageImageType
    url: string
    thumbnail?: string | null
    name?: string | null
    source?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageImageCreateOrConnectWithoutStageInput = {
    where: StageImageWhereUniqueInput
    create: XOR<StageImageCreateWithoutStageInput, StageImageUncheckedCreateWithoutStageInput>
  }

  export type StageImageCreateManyStageInputEnvelope = {
    data: StageImageCreateManyStageInput | StageImageCreateManyStageInput[]
    skipDuplicates?: boolean
  }

  export type StageThresholdCreateWithoutStageInput = {
    id?: string
    operator: $Enums.ThresholdOperator
    value: number
    unit?: string | null
    durationDays?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    indicator: IndicatorCreateNestedOneWithoutThresholdsInput
  }

  export type StageThresholdUncheckedCreateWithoutStageInput = {
    id?: string
    indicatorId: string
    operator: $Enums.ThresholdOperator
    value: number
    unit?: string | null
    durationDays?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageThresholdCreateOrConnectWithoutStageInput = {
    where: StageThresholdWhereUniqueInput
    create: XOR<StageThresholdCreateWithoutStageInput, StageThresholdUncheckedCreateWithoutStageInput>
  }

  export type StageThresholdCreateManyStageInputEnvelope = {
    data: StageThresholdCreateManyStageInput | StageThresholdCreateManyStageInput[]
    skipDuplicates?: boolean
  }

  export type CalendarUpsertWithoutStagesInput = {
    update: XOR<CalendarUpdateWithoutStagesInput, CalendarUncheckedUpdateWithoutStagesInput>
    create: XOR<CalendarCreateWithoutStagesInput, CalendarUncheckedCreateWithoutStagesInput>
    where?: CalendarWhereInput
  }

  export type CalendarUpdateToOneWithWhereWithoutStagesInput = {
    where?: CalendarWhereInput
    data: XOR<CalendarUpdateWithoutStagesInput, CalendarUncheckedUpdateWithoutStagesInput>
  }

  export type CalendarUpdateWithoutStagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    creatorName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crop?: CropUpdateOneRequiredWithoutCalendarsNestedInput
    calendarZones?: CalendarZoneUpdateManyWithoutCalendarNestedInput
    calendarIndicators?: CalendarIndicatorUpdateManyWithoutCalendarNestedInput
  }

  export type CalendarUncheckedUpdateWithoutStagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    creatorName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendarZones?: CalendarZoneUncheckedUpdateManyWithoutCalendarNestedInput
    calendarIndicators?: CalendarIndicatorUncheckedUpdateManyWithoutCalendarNestedInput
  }

  export type StageImageUpsertWithWhereUniqueWithoutStageInput = {
    where: StageImageWhereUniqueInput
    update: XOR<StageImageUpdateWithoutStageInput, StageImageUncheckedUpdateWithoutStageInput>
    create: XOR<StageImageCreateWithoutStageInput, StageImageUncheckedCreateWithoutStageInput>
  }

  export type StageImageUpdateWithWhereUniqueWithoutStageInput = {
    where: StageImageWhereUniqueInput
    data: XOR<StageImageUpdateWithoutStageInput, StageImageUncheckedUpdateWithoutStageInput>
  }

  export type StageImageUpdateManyWithWhereWithoutStageInput = {
    where: StageImageScalarWhereInput
    data: XOR<StageImageUpdateManyMutationInput, StageImageUncheckedUpdateManyWithoutStageInput>
  }

  export type StageImageScalarWhereInput = {
    AND?: StageImageScalarWhereInput | StageImageScalarWhereInput[]
    OR?: StageImageScalarWhereInput[]
    NOT?: StageImageScalarWhereInput | StageImageScalarWhereInput[]
    id?: StringFilter<"StageImage"> | string
    stageId?: StringFilter<"StageImage"> | string
    type?: EnumStageImageTypeFilter<"StageImage"> | $Enums.StageImageType
    url?: StringFilter<"StageImage"> | string
    thumbnail?: StringNullableFilter<"StageImage"> | string | null
    name?: StringNullableFilter<"StageImage"> | string | null
    source?: StringNullableFilter<"StageImage"> | string | null
    sortOrder?: IntFilter<"StageImage"> | number
    createdAt?: DateTimeFilter<"StageImage"> | Date | string
    updatedAt?: DateTimeFilter<"StageImage"> | Date | string
  }

  export type StageThresholdUpsertWithWhereUniqueWithoutStageInput = {
    where: StageThresholdWhereUniqueInput
    update: XOR<StageThresholdUpdateWithoutStageInput, StageThresholdUncheckedUpdateWithoutStageInput>
    create: XOR<StageThresholdCreateWithoutStageInput, StageThresholdUncheckedCreateWithoutStageInput>
  }

  export type StageThresholdUpdateWithWhereUniqueWithoutStageInput = {
    where: StageThresholdWhereUniqueInput
    data: XOR<StageThresholdUpdateWithoutStageInput, StageThresholdUncheckedUpdateWithoutStageInput>
  }

  export type StageThresholdUpdateManyWithWhereWithoutStageInput = {
    where: StageThresholdScalarWhereInput
    data: XOR<StageThresholdUpdateManyMutationInput, StageThresholdUncheckedUpdateManyWithoutStageInput>
  }

  export type StageCreateWithoutImagesInput = {
    id?: string
    order?: number
    name: string
    description?: string | null
    status?: $Enums.StageStatus
    color?: string
    startTenDay?: $Enums.TenDay | null
    startMonth?: number | null
    endTenDay?: $Enums.TenDay | null
    endMonth?: number | null
    analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    calendar: CalendarCreateNestedOneWithoutStagesInput
    thresholds?: StageThresholdCreateNestedManyWithoutStageInput
  }

  export type StageUncheckedCreateWithoutImagesInput = {
    id?: string
    calendarId: string
    order?: number
    name: string
    description?: string | null
    status?: $Enums.StageStatus
    color?: string
    startTenDay?: $Enums.TenDay | null
    startMonth?: number | null
    endTenDay?: $Enums.TenDay | null
    endMonth?: number | null
    analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    thresholds?: StageThresholdUncheckedCreateNestedManyWithoutStageInput
  }

  export type StageCreateOrConnectWithoutImagesInput = {
    where: StageWhereUniqueInput
    create: XOR<StageCreateWithoutImagesInput, StageUncheckedCreateWithoutImagesInput>
  }

  export type StageUpsertWithoutImagesInput = {
    update: XOR<StageUpdateWithoutImagesInput, StageUncheckedUpdateWithoutImagesInput>
    create: XOR<StageCreateWithoutImagesInput, StageUncheckedCreateWithoutImagesInput>
    where?: StageWhereInput
  }

  export type StageUpdateToOneWithWhereWithoutImagesInput = {
    where?: StageWhereInput
    data: XOR<StageUpdateWithoutImagesInput, StageUncheckedUpdateWithoutImagesInput>
  }

  export type StageUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStageStatusFieldUpdateOperationsInput | $Enums.StageStatus
    color?: StringFieldUpdateOperationsInput | string
    startTenDay?: NullableEnumTenDayFieldUpdateOperationsInput | $Enums.TenDay | null
    startMonth?: NullableIntFieldUpdateOperationsInput | number | null
    endTenDay?: NullableEnumTenDayFieldUpdateOperationsInput | $Enums.TenDay | null
    endMonth?: NullableIntFieldUpdateOperationsInput | number | null
    analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendar?: CalendarUpdateOneRequiredWithoutStagesNestedInput
    thresholds?: StageThresholdUpdateManyWithoutStageNestedInput
  }

  export type StageUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStageStatusFieldUpdateOperationsInput | $Enums.StageStatus
    color?: StringFieldUpdateOperationsInput | string
    startTenDay?: NullableEnumTenDayFieldUpdateOperationsInput | $Enums.TenDay | null
    startMonth?: NullableIntFieldUpdateOperationsInput | number | null
    endTenDay?: NullableEnumTenDayFieldUpdateOperationsInput | $Enums.TenDay | null
    endMonth?: NullableIntFieldUpdateOperationsInput | number | null
    analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thresholds?: StageThresholdUncheckedUpdateManyWithoutStageNestedInput
  }

  export type StageCreateWithoutThresholdsInput = {
    id?: string
    order?: number
    name: string
    description?: string | null
    status?: $Enums.StageStatus
    color?: string
    startTenDay?: $Enums.TenDay | null
    startMonth?: number | null
    endTenDay?: $Enums.TenDay | null
    endMonth?: number | null
    analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    calendar: CalendarCreateNestedOneWithoutStagesInput
    images?: StageImageCreateNestedManyWithoutStageInput
  }

  export type StageUncheckedCreateWithoutThresholdsInput = {
    id?: string
    calendarId: string
    order?: number
    name: string
    description?: string | null
    status?: $Enums.StageStatus
    color?: string
    startTenDay?: $Enums.TenDay | null
    startMonth?: number | null
    endTenDay?: $Enums.TenDay | null
    endMonth?: number | null
    analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: StageImageUncheckedCreateNestedManyWithoutStageInput
  }

  export type StageCreateOrConnectWithoutThresholdsInput = {
    where: StageWhereUniqueInput
    create: XOR<StageCreateWithoutThresholdsInput, StageUncheckedCreateWithoutThresholdsInput>
  }

  export type IndicatorCreateWithoutThresholdsInput = {
    id?: string
    name: string
    unit: string
    description?: string | null
    source?: string
    defaultMin?: number | null
    defaultMax?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category: IndicatorCategoryCreateNestedOneWithoutIndicatorsInput
    calendarIndicators?: CalendarIndicatorCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorUncheckedCreateWithoutThresholdsInput = {
    id?: string
    categoryId: string
    name: string
    unit: string
    description?: string | null
    source?: string
    defaultMin?: number | null
    defaultMax?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    calendarIndicators?: CalendarIndicatorUncheckedCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorCreateOrConnectWithoutThresholdsInput = {
    where: IndicatorWhereUniqueInput
    create: XOR<IndicatorCreateWithoutThresholdsInput, IndicatorUncheckedCreateWithoutThresholdsInput>
  }

  export type StageUpsertWithoutThresholdsInput = {
    update: XOR<StageUpdateWithoutThresholdsInput, StageUncheckedUpdateWithoutThresholdsInput>
    create: XOR<StageCreateWithoutThresholdsInput, StageUncheckedCreateWithoutThresholdsInput>
    where?: StageWhereInput
  }

  export type StageUpdateToOneWithWhereWithoutThresholdsInput = {
    where?: StageWhereInput
    data: XOR<StageUpdateWithoutThresholdsInput, StageUncheckedUpdateWithoutThresholdsInput>
  }

  export type StageUpdateWithoutThresholdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStageStatusFieldUpdateOperationsInput | $Enums.StageStatus
    color?: StringFieldUpdateOperationsInput | string
    startTenDay?: NullableEnumTenDayFieldUpdateOperationsInput | $Enums.TenDay | null
    startMonth?: NullableIntFieldUpdateOperationsInput | number | null
    endTenDay?: NullableEnumTenDayFieldUpdateOperationsInput | $Enums.TenDay | null
    endMonth?: NullableIntFieldUpdateOperationsInput | number | null
    analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendar?: CalendarUpdateOneRequiredWithoutStagesNestedInput
    images?: StageImageUpdateManyWithoutStageNestedInput
  }

  export type StageUncheckedUpdateWithoutThresholdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStageStatusFieldUpdateOperationsInput | $Enums.StageStatus
    color?: StringFieldUpdateOperationsInput | string
    startTenDay?: NullableEnumTenDayFieldUpdateOperationsInput | $Enums.TenDay | null
    startMonth?: NullableIntFieldUpdateOperationsInput | number | null
    endTenDay?: NullableEnumTenDayFieldUpdateOperationsInput | $Enums.TenDay | null
    endMonth?: NullableIntFieldUpdateOperationsInput | number | null
    analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: StageImageUncheckedUpdateManyWithoutStageNestedInput
  }

  export type IndicatorUpsertWithoutThresholdsInput = {
    update: XOR<IndicatorUpdateWithoutThresholdsInput, IndicatorUncheckedUpdateWithoutThresholdsInput>
    create: XOR<IndicatorCreateWithoutThresholdsInput, IndicatorUncheckedCreateWithoutThresholdsInput>
    where?: IndicatorWhereInput
  }

  export type IndicatorUpdateToOneWithWhereWithoutThresholdsInput = {
    where?: IndicatorWhereInput
    data: XOR<IndicatorUpdateWithoutThresholdsInput, IndicatorUncheckedUpdateWithoutThresholdsInput>
  }

  export type IndicatorUpdateWithoutThresholdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    defaultMin?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultMax?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: IndicatorCategoryUpdateOneRequiredWithoutIndicatorsNestedInput
    calendarIndicators?: CalendarIndicatorUpdateManyWithoutIndicatorNestedInput
  }

  export type IndicatorUncheckedUpdateWithoutThresholdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    defaultMin?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultMax?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendarIndicators?: CalendarIndicatorUncheckedUpdateManyWithoutIndicatorNestedInput
  }

  export type CalendarCreateManyCropInput = {
    id?: string
    title: string
    creatorId: string
    creatorName: string
    isShared?: boolean
    isPublished?: boolean
    fileType?: $Enums.CalendarFileType
    allowCenterUse?: boolean
    publishedAt?: Date | string | null
    lastEditedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarUpdateWithoutCropInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    creatorName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stages?: StageUpdateManyWithoutCalendarNestedInput
    calendarZones?: CalendarZoneUpdateManyWithoutCalendarNestedInput
    calendarIndicators?: CalendarIndicatorUpdateManyWithoutCalendarNestedInput
  }

  export type CalendarUncheckedUpdateWithoutCropInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    creatorName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stages?: StageUncheckedUpdateManyWithoutCalendarNestedInput
    calendarZones?: CalendarZoneUncheckedUpdateManyWithoutCalendarNestedInput
    calendarIndicators?: CalendarIndicatorUncheckedUpdateManyWithoutCalendarNestedInput
  }

  export type CalendarUncheckedUpdateManyWithoutCropInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    creatorName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicatorCreateManyCategoryInput = {
    id?: string
    name: string
    unit: string
    description?: string | null
    source?: string
    defaultMin?: number | null
    defaultMax?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndicatorUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    defaultMin?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultMax?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thresholds?: StageThresholdUpdateManyWithoutIndicatorNestedInput
    calendarIndicators?: CalendarIndicatorUpdateManyWithoutIndicatorNestedInput
  }

  export type IndicatorUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    defaultMin?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultMax?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thresholds?: StageThresholdUncheckedUpdateManyWithoutIndicatorNestedInput
    calendarIndicators?: CalendarIndicatorUncheckedUpdateManyWithoutIndicatorNestedInput
  }

  export type IndicatorUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    defaultMin?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultMax?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageThresholdCreateManyIndicatorInput = {
    id?: string
    stageId: string
    operator: $Enums.ThresholdOperator
    value: number
    unit?: string | null
    durationDays?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarIndicatorCreateManyIndicatorInput = {
    id?: string
    calendarId: string
    nameSnapshot: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageThresholdUpdateWithoutIndicatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    operator?: EnumThresholdOperatorFieldUpdateOperationsInput | $Enums.ThresholdOperator
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    durationDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stage?: StageUpdateOneRequiredWithoutThresholdsNestedInput
  }

  export type StageThresholdUncheckedUpdateWithoutIndicatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    operator?: EnumThresholdOperatorFieldUpdateOperationsInput | $Enums.ThresholdOperator
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    durationDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageThresholdUncheckedUpdateManyWithoutIndicatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    operator?: EnumThresholdOperatorFieldUpdateOperationsInput | $Enums.ThresholdOperator
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    durationDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarIndicatorUpdateWithoutIndicatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendar?: CalendarUpdateOneRequiredWithoutCalendarIndicatorsNestedInput
  }

  export type CalendarIndicatorUncheckedUpdateWithoutIndicatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarIndicatorUncheckedUpdateManyWithoutIndicatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneDistrictCreateManyZoneInput = {
    districtId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarZoneCreateManyZoneInput = {
    id?: string
    calendarId: string
    zoneName: string
    cityCount?: number
    districtCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZoneDistrictUpdateWithoutZoneInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    district?: DistrictUpdateOneRequiredWithoutZoneDistrictsNestedInput
  }

  export type ZoneDistrictUncheckedUpdateWithoutZoneInput = {
    districtId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneDistrictUncheckedUpdateManyWithoutZoneInput = {
    districtId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarZoneUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    cityCount?: IntFieldUpdateOperationsInput | number
    districtCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendar?: CalendarUpdateOneRequiredWithoutCalendarZonesNestedInput
    districts?: CalendarZoneDistrictUpdateManyWithoutCalendarZoneNestedInput
  }

  export type CalendarZoneUncheckedUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    cityCount?: IntFieldUpdateOperationsInput | number
    districtCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    districts?: CalendarZoneDistrictUncheckedUpdateManyWithoutCalendarZoneNestedInput
  }

  export type CalendarZoneUncheckedUpdateManyWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    cityCount?: IntFieldUpdateOperationsInput | number
    districtCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DistrictCreateManyCityInput = {
    id: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DistrictUpdateWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zoneDistricts?: ZoneDistrictUpdateManyWithoutDistrictNestedInput
    calendarZoneDistricts?: CalendarZoneDistrictUpdateManyWithoutDistrictNestedInput
  }

  export type DistrictUncheckedUpdateWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zoneDistricts?: ZoneDistrictUncheckedUpdateManyWithoutDistrictNestedInput
    calendarZoneDistricts?: CalendarZoneDistrictUncheckedUpdateManyWithoutDistrictNestedInput
  }

  export type DistrictUncheckedUpdateManyWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneDistrictCreateManyDistrictInput = {
    zoneId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarZoneDistrictCreateManyDistrictInput = {
    calendarZoneId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZoneDistrictUpdateWithoutDistrictInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: ZoneUpdateOneRequiredWithoutZoneDistrictsNestedInput
  }

  export type ZoneDistrictUncheckedUpdateWithoutDistrictInput = {
    zoneId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneDistrictUncheckedUpdateManyWithoutDistrictInput = {
    zoneId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarZoneDistrictUpdateWithoutDistrictInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendarZone?: CalendarZoneUpdateOneRequiredWithoutDistrictsNestedInput
  }

  export type CalendarZoneDistrictUncheckedUpdateWithoutDistrictInput = {
    calendarZoneId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarZoneDistrictUncheckedUpdateManyWithoutDistrictInput = {
    calendarZoneId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageCreateManyCalendarInput = {
    id?: string
    order?: number
    name: string
    description?: string | null
    status?: $Enums.StageStatus
    color?: string
    startTenDay?: $Enums.TenDay | null
    startMonth?: number | null
    endTenDay?: $Enums.TenDay | null
    endMonth?: number | null
    analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarZoneCreateManyCalendarInput = {
    id?: string
    zoneId: string
    zoneName: string
    cityCount?: number
    districtCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarIndicatorCreateManyCalendarInput = {
    id?: string
    indicatorId: string
    nameSnapshot: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageUpdateWithoutCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStageStatusFieldUpdateOperationsInput | $Enums.StageStatus
    color?: StringFieldUpdateOperationsInput | string
    startTenDay?: NullableEnumTenDayFieldUpdateOperationsInput | $Enums.TenDay | null
    startMonth?: NullableIntFieldUpdateOperationsInput | number | null
    endTenDay?: NullableEnumTenDayFieldUpdateOperationsInput | $Enums.TenDay | null
    endMonth?: NullableIntFieldUpdateOperationsInput | number | null
    analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: StageImageUpdateManyWithoutStageNestedInput
    thresholds?: StageThresholdUpdateManyWithoutStageNestedInput
  }

  export type StageUncheckedUpdateWithoutCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStageStatusFieldUpdateOperationsInput | $Enums.StageStatus
    color?: StringFieldUpdateOperationsInput | string
    startTenDay?: NullableEnumTenDayFieldUpdateOperationsInput | $Enums.TenDay | null
    startMonth?: NullableIntFieldUpdateOperationsInput | number | null
    endTenDay?: NullableEnumTenDayFieldUpdateOperationsInput | $Enums.TenDay | null
    endMonth?: NullableIntFieldUpdateOperationsInput | number | null
    analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: StageImageUncheckedUpdateManyWithoutStageNestedInput
    thresholds?: StageThresholdUncheckedUpdateManyWithoutStageNestedInput
  }

  export type StageUncheckedUpdateManyWithoutCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStageStatusFieldUpdateOperationsInput | $Enums.StageStatus
    color?: StringFieldUpdateOperationsInput | string
    startTenDay?: NullableEnumTenDayFieldUpdateOperationsInput | $Enums.TenDay | null
    startMonth?: NullableIntFieldUpdateOperationsInput | number | null
    endTenDay?: NullableEnumTenDayFieldUpdateOperationsInput | $Enums.TenDay | null
    endMonth?: NullableIntFieldUpdateOperationsInput | number | null
    analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarZoneUpdateWithoutCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    cityCount?: IntFieldUpdateOperationsInput | number
    districtCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: ZoneUpdateOneRequiredWithoutCalendarZonesNestedInput
    districts?: CalendarZoneDistrictUpdateManyWithoutCalendarZoneNestedInput
  }

  export type CalendarZoneUncheckedUpdateWithoutCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    cityCount?: IntFieldUpdateOperationsInput | number
    districtCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    districts?: CalendarZoneDistrictUncheckedUpdateManyWithoutCalendarZoneNestedInput
  }

  export type CalendarZoneUncheckedUpdateManyWithoutCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    cityCount?: IntFieldUpdateOperationsInput | number
    districtCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarIndicatorUpdateWithoutCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicator?: IndicatorUpdateOneRequiredWithoutCalendarIndicatorsNestedInput
  }

  export type CalendarIndicatorUncheckedUpdateWithoutCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    indicatorId?: StringFieldUpdateOperationsInput | string
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarIndicatorUncheckedUpdateManyWithoutCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    indicatorId?: StringFieldUpdateOperationsInput | string
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarZoneDistrictCreateManyCalendarZoneInput = {
    districtId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarZoneDistrictUpdateWithoutCalendarZoneInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    district?: DistrictUpdateOneRequiredWithoutCalendarZoneDistrictsNestedInput
  }

  export type CalendarZoneDistrictUncheckedUpdateWithoutCalendarZoneInput = {
    districtId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarZoneDistrictUncheckedUpdateManyWithoutCalendarZoneInput = {
    districtId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageImageCreateManyStageInput = {
    id?: string
    type: $Enums.StageImageType
    url: string
    thumbnail?: string | null
    name?: string | null
    source?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageThresholdCreateManyStageInput = {
    id?: string
    indicatorId: string
    operator: $Enums.ThresholdOperator
    value: number
    unit?: string | null
    durationDays?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageImageUpdateWithoutStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStageImageTypeFieldUpdateOperationsInput | $Enums.StageImageType
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageImageUncheckedUpdateWithoutStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStageImageTypeFieldUpdateOperationsInput | $Enums.StageImageType
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageImageUncheckedUpdateManyWithoutStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStageImageTypeFieldUpdateOperationsInput | $Enums.StageImageType
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageThresholdUpdateWithoutStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    operator?: EnumThresholdOperatorFieldUpdateOperationsInput | $Enums.ThresholdOperator
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    durationDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicator?: IndicatorUpdateOneRequiredWithoutThresholdsNestedInput
  }

  export type StageThresholdUncheckedUpdateWithoutStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    indicatorId?: StringFieldUpdateOperationsInput | string
    operator?: EnumThresholdOperatorFieldUpdateOperationsInput | $Enums.ThresholdOperator
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    durationDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageThresholdUncheckedUpdateManyWithoutStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    indicatorId?: StringFieldUpdateOperationsInput | string
    operator?: EnumThresholdOperatorFieldUpdateOperationsInput | $Enums.ThresholdOperator
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    durationDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CropCountOutputTypeDefaultArgs instead
     */
    export type CropCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CropCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IndicatorCategoryCountOutputTypeDefaultArgs instead
     */
    export type IndicatorCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IndicatorCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IndicatorCountOutputTypeDefaultArgs instead
     */
    export type IndicatorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IndicatorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ZoneCountOutputTypeDefaultArgs instead
     */
    export type ZoneCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ZoneCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CityCountOutputTypeDefaultArgs instead
     */
    export type CityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DistrictCountOutputTypeDefaultArgs instead
     */
    export type DistrictCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DistrictCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CalendarCountOutputTypeDefaultArgs instead
     */
    export type CalendarCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CalendarCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CalendarZoneCountOutputTypeDefaultArgs instead
     */
    export type CalendarZoneCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CalendarZoneCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StageCountOutputTypeDefaultArgs instead
     */
    export type StageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CropDefaultArgs instead
     */
    export type CropArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CropDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IndicatorCategoryDefaultArgs instead
     */
    export type IndicatorCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IndicatorCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IndicatorDefaultArgs instead
     */
    export type IndicatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IndicatorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ZoneDefaultArgs instead
     */
    export type ZoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ZoneDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CityDefaultArgs instead
     */
    export type CityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DistrictDefaultArgs instead
     */
    export type DistrictArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DistrictDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ZoneDistrictDefaultArgs instead
     */
    export type ZoneDistrictArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ZoneDistrictDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CalendarDefaultArgs instead
     */
    export type CalendarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CalendarDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CalendarZoneDefaultArgs instead
     */
    export type CalendarZoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CalendarZoneDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CalendarZoneDistrictDefaultArgs instead
     */
    export type CalendarZoneDistrictArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CalendarZoneDistrictDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CalendarIndicatorDefaultArgs instead
     */
    export type CalendarIndicatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CalendarIndicatorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StageDefaultArgs instead
     */
    export type StageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StageImageDefaultArgs instead
     */
    export type StageImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StageImageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StageThresholdDefaultArgs instead
     */
    export type StageThresholdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StageThresholdDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GwlDefaultArgs instead
     */
    export type GwlArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GwlDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}