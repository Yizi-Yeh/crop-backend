
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Crop
 * 
 */
export type Crop = $Result.DefaultSelection<Prisma.$CropPayload>
/**
 * Model Creator
 * 
 */
export type Creator = $Result.DefaultSelection<Prisma.$CreatorPayload>
/**
 * Model Calendar
 * 
 */
export type Calendar = $Result.DefaultSelection<Prisma.$CalendarPayload>
/**
 * Model City
 * 
 */
export type City = $Result.DefaultSelection<Prisma.$CityPayload>
/**
 * Model District
 * 
 */
export type District = $Result.DefaultSelection<Prisma.$DistrictPayload>
/**
 * Model CalendarDistrict
 * 
 */
export type CalendarDistrict = $Result.DefaultSelection<Prisma.$CalendarDistrictPayload>
/**
 * Model Stage
 * 
 */
export type Stage = $Result.DefaultSelection<Prisma.$StagePayload>
/**
 * Model StageAlbum
 * 
 */
export type StageAlbum = $Result.DefaultSelection<Prisma.$StageAlbumPayload>
/**
 * Model StageThreshold
 * 
 */
export type StageThreshold = $Result.DefaultSelection<Prisma.$StageThresholdPayload>
/**
 * Model IndicatorCategory
 * 
 */
export type IndicatorCategory = $Result.DefaultSelection<Prisma.$IndicatorCategoryPayload>
/**
 * Model Indicator
 * 
 */
export type Indicator = $Result.DefaultSelection<Prisma.$IndicatorPayload>
/**
 * Model Gwl
 * 
 */
export type Gwl = $Result.DefaultSelection<Prisma.$GwlPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const CalendarFileType: {
  ORIGINAL: 'ORIGINAL',
  COPY: 'COPY'
};

export type CalendarFileType = (typeof CalendarFileType)[keyof typeof CalendarFileType]


export const Decade: {
  UPPER: 'UPPER',
  MIDDLE: 'MIDDLE',
  LOWER: 'LOWER'
};

export type Decade = (typeof Decade)[keyof typeof Decade]


export const StageStatus: {
  DRAFT: 'DRAFT',
  COMPLETE: 'COMPLETE'
};

export type StageStatus = (typeof StageStatus)[keyof typeof StageStatus]


export const ThresholdOperator: {
  GT: 'GT',
  LT: 'LT',
  GTE: 'GTE',
  LTE: 'LTE'
};

export type ThresholdOperator = (typeof ThresholdOperator)[keyof typeof ThresholdOperator]

}

export type CalendarFileType = $Enums.CalendarFileType

export const CalendarFileType: typeof $Enums.CalendarFileType

export type Decade = $Enums.Decade

export const Decade: typeof $Enums.Decade

export type StageStatus = $Enums.StageStatus

export const StageStatus: typeof $Enums.StageStatus

export type ThresholdOperator = $Enums.ThresholdOperator

export const ThresholdOperator: typeof $Enums.ThresholdOperator

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Crops
 * const crops = await prisma.crop.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Crops
   * const crops = await prisma.crop.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.crop`: Exposes CRUD operations for the **Crop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Crops
    * const crops = await prisma.crop.findMany()
    * ```
    */
  get crop(): Prisma.CropDelegate<ExtArgs>;

  /**
   * `prisma.creator`: Exposes CRUD operations for the **Creator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Creators
    * const creators = await prisma.creator.findMany()
    * ```
    */
  get creator(): Prisma.CreatorDelegate<ExtArgs>;

  /**
   * `prisma.calendar`: Exposes CRUD operations for the **Calendar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Calendars
    * const calendars = await prisma.calendar.findMany()
    * ```
    */
  get calendar(): Prisma.CalendarDelegate<ExtArgs>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<ExtArgs>;

  /**
   * `prisma.district`: Exposes CRUD operations for the **District** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Districts
    * const districts = await prisma.district.findMany()
    * ```
    */
  get district(): Prisma.DistrictDelegate<ExtArgs>;

  /**
   * `prisma.calendarDistrict`: Exposes CRUD operations for the **CalendarDistrict** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CalendarDistricts
    * const calendarDistricts = await prisma.calendarDistrict.findMany()
    * ```
    */
  get calendarDistrict(): Prisma.CalendarDistrictDelegate<ExtArgs>;

  /**
   * `prisma.stage`: Exposes CRUD operations for the **Stage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stages
    * const stages = await prisma.stage.findMany()
    * ```
    */
  get stage(): Prisma.StageDelegate<ExtArgs>;

  /**
   * `prisma.stageAlbum`: Exposes CRUD operations for the **StageAlbum** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StageAlbums
    * const stageAlbums = await prisma.stageAlbum.findMany()
    * ```
    */
  get stageAlbum(): Prisma.StageAlbumDelegate<ExtArgs>;

  /**
   * `prisma.stageThreshold`: Exposes CRUD operations for the **StageThreshold** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StageThresholds
    * const stageThresholds = await prisma.stageThreshold.findMany()
    * ```
    */
  get stageThreshold(): Prisma.StageThresholdDelegate<ExtArgs>;

  /**
   * `prisma.indicatorCategory`: Exposes CRUD operations for the **IndicatorCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IndicatorCategories
    * const indicatorCategories = await prisma.indicatorCategory.findMany()
    * ```
    */
  get indicatorCategory(): Prisma.IndicatorCategoryDelegate<ExtArgs>;

  /**
   * `prisma.indicator`: Exposes CRUD operations for the **Indicator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Indicators
    * const indicators = await prisma.indicator.findMany()
    * ```
    */
  get indicator(): Prisma.IndicatorDelegate<ExtArgs>;

  /**
   * `prisma.gwl`: Exposes CRUD operations for the **Gwl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gwls
    * const gwls = await prisma.gwl.findMany()
    * ```
    */
  get gwl(): Prisma.GwlDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Crop: 'Crop',
    Creator: 'Creator',
    Calendar: 'Calendar',
    City: 'City',
    District: 'District',
    CalendarDistrict: 'CalendarDistrict',
    Stage: 'Stage',
    StageAlbum: 'StageAlbum',
    StageThreshold: 'StageThreshold',
    IndicatorCategory: 'IndicatorCategory',
    Indicator: 'Indicator',
    Gwl: 'Gwl'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "crop" | "creator" | "calendar" | "city" | "district" | "calendarDistrict" | "stage" | "stageAlbum" | "stageThreshold" | "indicatorCategory" | "indicator" | "gwl"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Crop: {
        payload: Prisma.$CropPayload<ExtArgs>
        fields: Prisma.CropFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CropFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CropFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>
          }
          findFirst: {
            args: Prisma.CropFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CropFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>
          }
          findMany: {
            args: Prisma.CropFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>[]
          }
          create: {
            args: Prisma.CropCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>
          }
          createMany: {
            args: Prisma.CropCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CropCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>[]
          }
          delete: {
            args: Prisma.CropDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>
          }
          update: {
            args: Prisma.CropUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>
          }
          deleteMany: {
            args: Prisma.CropDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CropUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CropUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>
          }
          aggregate: {
            args: Prisma.CropAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrop>
          }
          groupBy: {
            args: Prisma.CropGroupByArgs<ExtArgs>
            result: $Utils.Optional<CropGroupByOutputType>[]
          }
          count: {
            args: Prisma.CropCountArgs<ExtArgs>
            result: $Utils.Optional<CropCountAggregateOutputType> | number
          }
        }
      }
      Creator: {
        payload: Prisma.$CreatorPayload<ExtArgs>
        fields: Prisma.CreatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>
          }
          findFirst: {
            args: Prisma.CreatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>
          }
          findMany: {
            args: Prisma.CreatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>[]
          }
          create: {
            args: Prisma.CreatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>
          }
          createMany: {
            args: Prisma.CreatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreatorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>[]
          }
          delete: {
            args: Prisma.CreatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>
          }
          update: {
            args: Prisma.CreatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>
          }
          deleteMany: {
            args: Prisma.CreatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CreatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>
          }
          aggregate: {
            args: Prisma.CreatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreator>
          }
          groupBy: {
            args: Prisma.CreatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreatorCountArgs<ExtArgs>
            result: $Utils.Optional<CreatorCountAggregateOutputType> | number
          }
        }
      }
      Calendar: {
        payload: Prisma.$CalendarPayload<ExtArgs>
        fields: Prisma.CalendarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalendarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalendarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>
          }
          findFirst: {
            args: Prisma.CalendarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalendarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>
          }
          findMany: {
            args: Prisma.CalendarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>[]
          }
          create: {
            args: Prisma.CalendarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>
          }
          createMany: {
            args: Prisma.CalendarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CalendarCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>[]
          }
          delete: {
            args: Prisma.CalendarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>
          }
          update: {
            args: Prisma.CalendarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>
          }
          deleteMany: {
            args: Prisma.CalendarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalendarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CalendarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>
          }
          aggregate: {
            args: Prisma.CalendarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalendar>
          }
          groupBy: {
            args: Prisma.CalendarGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalendarGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalendarCountArgs<ExtArgs>
            result: $Utils.Optional<CalendarCountAggregateOutputType> | number
          }
        }
      }
      City: {
        payload: Prisma.$CityPayload<ExtArgs>
        fields: Prisma.CityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findFirst: {
            args: Prisma.CityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findMany: {
            args: Prisma.CityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          create: {
            args: Prisma.CityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          createMany: {
            args: Prisma.CityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          delete: {
            args: Prisma.CityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          update: {
            args: Prisma.CityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          deleteMany: {
            args: Prisma.CityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          aggregate: {
            args: Prisma.CityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCity>
          }
          groupBy: {
            args: Prisma.CityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CityCountArgs<ExtArgs>
            result: $Utils.Optional<CityCountAggregateOutputType> | number
          }
        }
      }
      District: {
        payload: Prisma.$DistrictPayload<ExtArgs>
        fields: Prisma.DistrictFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DistrictFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DistrictFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          findFirst: {
            args: Prisma.DistrictFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DistrictFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          findMany: {
            args: Prisma.DistrictFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>[]
          }
          create: {
            args: Prisma.DistrictCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          createMany: {
            args: Prisma.DistrictCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DistrictCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>[]
          }
          delete: {
            args: Prisma.DistrictDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          update: {
            args: Prisma.DistrictUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          deleteMany: {
            args: Prisma.DistrictDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DistrictUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DistrictUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          aggregate: {
            args: Prisma.DistrictAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDistrict>
          }
          groupBy: {
            args: Prisma.DistrictGroupByArgs<ExtArgs>
            result: $Utils.Optional<DistrictGroupByOutputType>[]
          }
          count: {
            args: Prisma.DistrictCountArgs<ExtArgs>
            result: $Utils.Optional<DistrictCountAggregateOutputType> | number
          }
        }
      }
      CalendarDistrict: {
        payload: Prisma.$CalendarDistrictPayload<ExtArgs>
        fields: Prisma.CalendarDistrictFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalendarDistrictFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarDistrictPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalendarDistrictFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarDistrictPayload>
          }
          findFirst: {
            args: Prisma.CalendarDistrictFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarDistrictPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalendarDistrictFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarDistrictPayload>
          }
          findMany: {
            args: Prisma.CalendarDistrictFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarDistrictPayload>[]
          }
          create: {
            args: Prisma.CalendarDistrictCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarDistrictPayload>
          }
          createMany: {
            args: Prisma.CalendarDistrictCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CalendarDistrictCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarDistrictPayload>[]
          }
          delete: {
            args: Prisma.CalendarDistrictDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarDistrictPayload>
          }
          update: {
            args: Prisma.CalendarDistrictUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarDistrictPayload>
          }
          deleteMany: {
            args: Prisma.CalendarDistrictDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalendarDistrictUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CalendarDistrictUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarDistrictPayload>
          }
          aggregate: {
            args: Prisma.CalendarDistrictAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalendarDistrict>
          }
          groupBy: {
            args: Prisma.CalendarDistrictGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalendarDistrictGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalendarDistrictCountArgs<ExtArgs>
            result: $Utils.Optional<CalendarDistrictCountAggregateOutputType> | number
          }
        }
      }
      Stage: {
        payload: Prisma.$StagePayload<ExtArgs>
        fields: Prisma.StageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>
          }
          findFirst: {
            args: Prisma.StageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>
          }
          findMany: {
            args: Prisma.StageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>[]
          }
          create: {
            args: Prisma.StageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>
          }
          createMany: {
            args: Prisma.StageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>[]
          }
          delete: {
            args: Prisma.StageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>
          }
          update: {
            args: Prisma.StageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>
          }
          deleteMany: {
            args: Prisma.StageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>
          }
          aggregate: {
            args: Prisma.StageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStage>
          }
          groupBy: {
            args: Prisma.StageGroupByArgs<ExtArgs>
            result: $Utils.Optional<StageGroupByOutputType>[]
          }
          count: {
            args: Prisma.StageCountArgs<ExtArgs>
            result: $Utils.Optional<StageCountAggregateOutputType> | number
          }
        }
      }
      StageAlbum: {
        payload: Prisma.$StageAlbumPayload<ExtArgs>
        fields: Prisma.StageAlbumFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StageAlbumFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageAlbumPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StageAlbumFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageAlbumPayload>
          }
          findFirst: {
            args: Prisma.StageAlbumFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageAlbumPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StageAlbumFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageAlbumPayload>
          }
          findMany: {
            args: Prisma.StageAlbumFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageAlbumPayload>[]
          }
          create: {
            args: Prisma.StageAlbumCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageAlbumPayload>
          }
          createMany: {
            args: Prisma.StageAlbumCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StageAlbumCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageAlbumPayload>[]
          }
          delete: {
            args: Prisma.StageAlbumDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageAlbumPayload>
          }
          update: {
            args: Prisma.StageAlbumUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageAlbumPayload>
          }
          deleteMany: {
            args: Prisma.StageAlbumDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StageAlbumUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StageAlbumUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageAlbumPayload>
          }
          aggregate: {
            args: Prisma.StageAlbumAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStageAlbum>
          }
          groupBy: {
            args: Prisma.StageAlbumGroupByArgs<ExtArgs>
            result: $Utils.Optional<StageAlbumGroupByOutputType>[]
          }
          count: {
            args: Prisma.StageAlbumCountArgs<ExtArgs>
            result: $Utils.Optional<StageAlbumCountAggregateOutputType> | number
          }
        }
      }
      StageThreshold: {
        payload: Prisma.$StageThresholdPayload<ExtArgs>
        fields: Prisma.StageThresholdFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StageThresholdFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageThresholdPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StageThresholdFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageThresholdPayload>
          }
          findFirst: {
            args: Prisma.StageThresholdFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageThresholdPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StageThresholdFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageThresholdPayload>
          }
          findMany: {
            args: Prisma.StageThresholdFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageThresholdPayload>[]
          }
          create: {
            args: Prisma.StageThresholdCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageThresholdPayload>
          }
          createMany: {
            args: Prisma.StageThresholdCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StageThresholdCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageThresholdPayload>[]
          }
          delete: {
            args: Prisma.StageThresholdDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageThresholdPayload>
          }
          update: {
            args: Prisma.StageThresholdUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageThresholdPayload>
          }
          deleteMany: {
            args: Prisma.StageThresholdDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StageThresholdUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StageThresholdUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StageThresholdPayload>
          }
          aggregate: {
            args: Prisma.StageThresholdAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStageThreshold>
          }
          groupBy: {
            args: Prisma.StageThresholdGroupByArgs<ExtArgs>
            result: $Utils.Optional<StageThresholdGroupByOutputType>[]
          }
          count: {
            args: Prisma.StageThresholdCountArgs<ExtArgs>
            result: $Utils.Optional<StageThresholdCountAggregateOutputType> | number
          }
        }
      }
      IndicatorCategory: {
        payload: Prisma.$IndicatorCategoryPayload<ExtArgs>
        fields: Prisma.IndicatorCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IndicatorCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IndicatorCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCategoryPayload>
          }
          findFirst: {
            args: Prisma.IndicatorCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IndicatorCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCategoryPayload>
          }
          findMany: {
            args: Prisma.IndicatorCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCategoryPayload>[]
          }
          create: {
            args: Prisma.IndicatorCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCategoryPayload>
          }
          createMany: {
            args: Prisma.IndicatorCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IndicatorCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCategoryPayload>[]
          }
          delete: {
            args: Prisma.IndicatorCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCategoryPayload>
          }
          update: {
            args: Prisma.IndicatorCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCategoryPayload>
          }
          deleteMany: {
            args: Prisma.IndicatorCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IndicatorCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IndicatorCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCategoryPayload>
          }
          aggregate: {
            args: Prisma.IndicatorCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIndicatorCategory>
          }
          groupBy: {
            args: Prisma.IndicatorCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<IndicatorCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.IndicatorCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<IndicatorCategoryCountAggregateOutputType> | number
          }
        }
      }
      Indicator: {
        payload: Prisma.$IndicatorPayload<ExtArgs>
        fields: Prisma.IndicatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IndicatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IndicatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>
          }
          findFirst: {
            args: Prisma.IndicatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IndicatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>
          }
          findMany: {
            args: Prisma.IndicatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>[]
          }
          create: {
            args: Prisma.IndicatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>
          }
          createMany: {
            args: Prisma.IndicatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IndicatorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>[]
          }
          delete: {
            args: Prisma.IndicatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>
          }
          update: {
            args: Prisma.IndicatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>
          }
          deleteMany: {
            args: Prisma.IndicatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IndicatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IndicatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>
          }
          aggregate: {
            args: Prisma.IndicatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIndicator>
          }
          groupBy: {
            args: Prisma.IndicatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<IndicatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.IndicatorCountArgs<ExtArgs>
            result: $Utils.Optional<IndicatorCountAggregateOutputType> | number
          }
        }
      }
      Gwl: {
        payload: Prisma.$GwlPayload<ExtArgs>
        fields: Prisma.GwlFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GwlFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GwlPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GwlFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GwlPayload>
          }
          findFirst: {
            args: Prisma.GwlFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GwlPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GwlFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GwlPayload>
          }
          findMany: {
            args: Prisma.GwlFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GwlPayload>[]
          }
          create: {
            args: Prisma.GwlCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GwlPayload>
          }
          createMany: {
            args: Prisma.GwlCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GwlCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GwlPayload>[]
          }
          delete: {
            args: Prisma.GwlDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GwlPayload>
          }
          update: {
            args: Prisma.GwlUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GwlPayload>
          }
          deleteMany: {
            args: Prisma.GwlDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GwlUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GwlUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GwlPayload>
          }
          aggregate: {
            args: Prisma.GwlAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGwl>
          }
          groupBy: {
            args: Prisma.GwlGroupByArgs<ExtArgs>
            result: $Utils.Optional<GwlGroupByOutputType>[]
          }
          count: {
            args: Prisma.GwlCountArgs<ExtArgs>
            result: $Utils.Optional<GwlCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CropCountOutputType
   */

  export type CropCountOutputType = {
    calendars: number
  }

  export type CropCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calendars?: boolean | CropCountOutputTypeCountCalendarsArgs
  }

  // Custom InputTypes
  /**
   * CropCountOutputType without action
   */
  export type CropCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropCountOutputType
     */
    select?: CropCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CropCountOutputType without action
   */
  export type CropCountOutputTypeCountCalendarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarWhereInput
  }


  /**
   * Count Type CreatorCountOutputType
   */

  export type CreatorCountOutputType = {
    calendars: number
  }

  export type CreatorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calendars?: boolean | CreatorCountOutputTypeCountCalendarsArgs
  }

  // Custom InputTypes
  /**
   * CreatorCountOutputType without action
   */
  export type CreatorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorCountOutputType
     */
    select?: CreatorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CreatorCountOutputType without action
   */
  export type CreatorCountOutputTypeCountCalendarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarWhereInput
  }


  /**
   * Count Type CalendarCountOutputType
   */

  export type CalendarCountOutputType = {
    stages: number
    districts: number
  }

  export type CalendarCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stages?: boolean | CalendarCountOutputTypeCountStagesArgs
    districts?: boolean | CalendarCountOutputTypeCountDistrictsArgs
  }

  // Custom InputTypes
  /**
   * CalendarCountOutputType without action
   */
  export type CalendarCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarCountOutputType
     */
    select?: CalendarCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CalendarCountOutputType without action
   */
  export type CalendarCountOutputTypeCountStagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StageWhereInput
  }

  /**
   * CalendarCountOutputType without action
   */
  export type CalendarCountOutputTypeCountDistrictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarDistrictWhereInput
  }


  /**
   * Count Type CityCountOutputType
   */

  export type CityCountOutputType = {
    districts: number
    calendarDistricts: number
  }

  export type CityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    districts?: boolean | CityCountOutputTypeCountDistrictsArgs
    calendarDistricts?: boolean | CityCountOutputTypeCountCalendarDistrictsArgs
  }

  // Custom InputTypes
  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityCountOutputType
     */
    select?: CityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountDistrictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DistrictWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountCalendarDistrictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarDistrictWhereInput
  }


  /**
   * Count Type DistrictCountOutputType
   */

  export type DistrictCountOutputType = {
    calendarDistricts: number
  }

  export type DistrictCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calendarDistricts?: boolean | DistrictCountOutputTypeCountCalendarDistrictsArgs
  }

  // Custom InputTypes
  /**
   * DistrictCountOutputType without action
   */
  export type DistrictCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistrictCountOutputType
     */
    select?: DistrictCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DistrictCountOutputType without action
   */
  export type DistrictCountOutputTypeCountCalendarDistrictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarDistrictWhereInput
  }


  /**
   * Count Type StageCountOutputType
   */

  export type StageCountOutputType = {
    thresholds: number
    albums: number
  }

  export type StageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thresholds?: boolean | StageCountOutputTypeCountThresholdsArgs
    albums?: boolean | StageCountOutputTypeCountAlbumsArgs
  }

  // Custom InputTypes
  /**
   * StageCountOutputType without action
   */
  export type StageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageCountOutputType
     */
    select?: StageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StageCountOutputType without action
   */
  export type StageCountOutputTypeCountThresholdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StageThresholdWhereInput
  }

  /**
   * StageCountOutputType without action
   */
  export type StageCountOutputTypeCountAlbumsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StageAlbumWhereInput
  }


  /**
   * Count Type IndicatorCategoryCountOutputType
   */

  export type IndicatorCategoryCountOutputType = {
    indicators: number
  }

  export type IndicatorCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicators?: boolean | IndicatorCategoryCountOutputTypeCountIndicatorsArgs
  }

  // Custom InputTypes
  /**
   * IndicatorCategoryCountOutputType without action
   */
  export type IndicatorCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCategoryCountOutputType
     */
    select?: IndicatorCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IndicatorCategoryCountOutputType without action
   */
  export type IndicatorCategoryCountOutputTypeCountIndicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicatorWhereInput
  }


  /**
   * Count Type IndicatorCountOutputType
   */

  export type IndicatorCountOutputType = {
    thresholds: number
  }

  export type IndicatorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thresholds?: boolean | IndicatorCountOutputTypeCountThresholdsArgs
  }

  // Custom InputTypes
  /**
   * IndicatorCountOutputType without action
   */
  export type IndicatorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCountOutputType
     */
    select?: IndicatorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IndicatorCountOutputType without action
   */
  export type IndicatorCountOutputTypeCountThresholdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StageThresholdWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Crop
   */

  export type AggregateCrop = {
    _count: CropCountAggregateOutputType | null
    _min: CropMinAggregateOutputType | null
    _max: CropMaxAggregateOutputType | null
  }

  export type CropMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CropMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CropCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CropMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CropMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CropCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CropAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Crop to aggregate.
     */
    where?: CropWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crops to fetch.
     */
    orderBy?: CropOrderByWithRelationInput | CropOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CropWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Crops
    **/
    _count?: true | CropCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CropMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CropMaxAggregateInputType
  }

  export type GetCropAggregateType<T extends CropAggregateArgs> = {
        [P in keyof T & keyof AggregateCrop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrop[P]>
      : GetScalarType<T[P], AggregateCrop[P]>
  }




  export type CropGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CropWhereInput
    orderBy?: CropOrderByWithAggregationInput | CropOrderByWithAggregationInput[]
    by: CropScalarFieldEnum[] | CropScalarFieldEnum
    having?: CropScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CropCountAggregateInputType | true
    _min?: CropMinAggregateInputType
    _max?: CropMaxAggregateInputType
  }

  export type CropGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: CropCountAggregateOutputType | null
    _min: CropMinAggregateOutputType | null
    _max: CropMaxAggregateOutputType | null
  }

  type GetCropGroupByPayload<T extends CropGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CropGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CropGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CropGroupByOutputType[P]>
            : GetScalarType<T[P], CropGroupByOutputType[P]>
        }
      >
    >


  export type CropSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    calendars?: boolean | Crop$calendarsArgs<ExtArgs>
    _count?: boolean | CropCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crop"]>

  export type CropSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["crop"]>

  export type CropSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CropInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calendars?: boolean | Crop$calendarsArgs<ExtArgs>
    _count?: boolean | CropCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CropIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CropPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Crop"
    objects: {
      calendars: Prisma.$CalendarPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["crop"]>
    composites: {}
  }

  type CropGetPayload<S extends boolean | null | undefined | CropDefaultArgs> = $Result.GetResult<Prisma.$CropPayload, S>

  type CropCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CropFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CropCountAggregateInputType | true
    }

  export interface CropDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Crop'], meta: { name: 'Crop' } }
    /**
     * Find zero or one Crop that matches the filter.
     * @param {CropFindUniqueArgs} args - Arguments to find a Crop
     * @example
     * // Get one Crop
     * const crop = await prisma.crop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CropFindUniqueArgs>(args: SelectSubset<T, CropFindUniqueArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Crop that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CropFindUniqueOrThrowArgs} args - Arguments to find a Crop
     * @example
     * // Get one Crop
     * const crop = await prisma.crop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CropFindUniqueOrThrowArgs>(args: SelectSubset<T, CropFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Crop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropFindFirstArgs} args - Arguments to find a Crop
     * @example
     * // Get one Crop
     * const crop = await prisma.crop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CropFindFirstArgs>(args?: SelectSubset<T, CropFindFirstArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Crop that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropFindFirstOrThrowArgs} args - Arguments to find a Crop
     * @example
     * // Get one Crop
     * const crop = await prisma.crop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CropFindFirstOrThrowArgs>(args?: SelectSubset<T, CropFindFirstOrThrowArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Crops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Crops
     * const crops = await prisma.crop.findMany()
     * 
     * // Get first 10 Crops
     * const crops = await prisma.crop.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cropWithIdOnly = await prisma.crop.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CropFindManyArgs>(args?: SelectSubset<T, CropFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Crop.
     * @param {CropCreateArgs} args - Arguments to create a Crop.
     * @example
     * // Create one Crop
     * const Crop = await prisma.crop.create({
     *   data: {
     *     // ... data to create a Crop
     *   }
     * })
     * 
     */
    create<T extends CropCreateArgs>(args: SelectSubset<T, CropCreateArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Crops.
     * @param {CropCreateManyArgs} args - Arguments to create many Crops.
     * @example
     * // Create many Crops
     * const crop = await prisma.crop.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CropCreateManyArgs>(args?: SelectSubset<T, CropCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Crops and returns the data saved in the database.
     * @param {CropCreateManyAndReturnArgs} args - Arguments to create many Crops.
     * @example
     * // Create many Crops
     * const crop = await prisma.crop.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Crops and only return the `id`
     * const cropWithIdOnly = await prisma.crop.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CropCreateManyAndReturnArgs>(args?: SelectSubset<T, CropCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Crop.
     * @param {CropDeleteArgs} args - Arguments to delete one Crop.
     * @example
     * // Delete one Crop
     * const Crop = await prisma.crop.delete({
     *   where: {
     *     // ... filter to delete one Crop
     *   }
     * })
     * 
     */
    delete<T extends CropDeleteArgs>(args: SelectSubset<T, CropDeleteArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Crop.
     * @param {CropUpdateArgs} args - Arguments to update one Crop.
     * @example
     * // Update one Crop
     * const crop = await prisma.crop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CropUpdateArgs>(args: SelectSubset<T, CropUpdateArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Crops.
     * @param {CropDeleteManyArgs} args - Arguments to filter Crops to delete.
     * @example
     * // Delete a few Crops
     * const { count } = await prisma.crop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CropDeleteManyArgs>(args?: SelectSubset<T, CropDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Crops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Crops
     * const crop = await prisma.crop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CropUpdateManyArgs>(args: SelectSubset<T, CropUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Crop.
     * @param {CropUpsertArgs} args - Arguments to update or create a Crop.
     * @example
     * // Update or create a Crop
     * const crop = await prisma.crop.upsert({
     *   create: {
     *     // ... data to create a Crop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Crop we want to update
     *   }
     * })
     */
    upsert<T extends CropUpsertArgs>(args: SelectSubset<T, CropUpsertArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Crops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropCountArgs} args - Arguments to filter Crops to count.
     * @example
     * // Count the number of Crops
     * const count = await prisma.crop.count({
     *   where: {
     *     // ... the filter for the Crops we want to count
     *   }
     * })
    **/
    count<T extends CropCountArgs>(
      args?: Subset<T, CropCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CropCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Crop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CropAggregateArgs>(args: Subset<T, CropAggregateArgs>): Prisma.PrismaPromise<GetCropAggregateType<T>>

    /**
     * Group by Crop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CropGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CropGroupByArgs['orderBy'] }
        : { orderBy?: CropGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CropGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCropGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Crop model
   */
  readonly fields: CropFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Crop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CropClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    calendars<T extends Crop$calendarsArgs<ExtArgs> = {}>(args?: Subset<T, Crop$calendarsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Crop model
   */ 
  interface CropFieldRefs {
    readonly id: FieldRef<"Crop", 'String'>
    readonly name: FieldRef<"Crop", 'String'>
    readonly createdAt: FieldRef<"Crop", 'DateTime'>
    readonly updatedAt: FieldRef<"Crop", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Crop findUnique
   */
  export type CropFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * Filter, which Crop to fetch.
     */
    where: CropWhereUniqueInput
  }

  /**
   * Crop findUniqueOrThrow
   */
  export type CropFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * Filter, which Crop to fetch.
     */
    where: CropWhereUniqueInput
  }

  /**
   * Crop findFirst
   */
  export type CropFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * Filter, which Crop to fetch.
     */
    where?: CropWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crops to fetch.
     */
    orderBy?: CropOrderByWithRelationInput | CropOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Crops.
     */
    cursor?: CropWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Crops.
     */
    distinct?: CropScalarFieldEnum | CropScalarFieldEnum[]
  }

  /**
   * Crop findFirstOrThrow
   */
  export type CropFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * Filter, which Crop to fetch.
     */
    where?: CropWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crops to fetch.
     */
    orderBy?: CropOrderByWithRelationInput | CropOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Crops.
     */
    cursor?: CropWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Crops.
     */
    distinct?: CropScalarFieldEnum | CropScalarFieldEnum[]
  }

  /**
   * Crop findMany
   */
  export type CropFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * Filter, which Crops to fetch.
     */
    where?: CropWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crops to fetch.
     */
    orderBy?: CropOrderByWithRelationInput | CropOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Crops.
     */
    cursor?: CropWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crops.
     */
    skip?: number
    distinct?: CropScalarFieldEnum | CropScalarFieldEnum[]
  }

  /**
   * Crop create
   */
  export type CropCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * The data needed to create a Crop.
     */
    data: XOR<CropCreateInput, CropUncheckedCreateInput>
  }

  /**
   * Crop createMany
   */
  export type CropCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Crops.
     */
    data: CropCreateManyInput | CropCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Crop createManyAndReturn
   */
  export type CropCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Crops.
     */
    data: CropCreateManyInput | CropCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Crop update
   */
  export type CropUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * The data needed to update a Crop.
     */
    data: XOR<CropUpdateInput, CropUncheckedUpdateInput>
    /**
     * Choose, which Crop to update.
     */
    where: CropWhereUniqueInput
  }

  /**
   * Crop updateMany
   */
  export type CropUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Crops.
     */
    data: XOR<CropUpdateManyMutationInput, CropUncheckedUpdateManyInput>
    /**
     * Filter which Crops to update
     */
    where?: CropWhereInput
  }

  /**
   * Crop upsert
   */
  export type CropUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * The filter to search for the Crop to update in case it exists.
     */
    where: CropWhereUniqueInput
    /**
     * In case the Crop found by the `where` argument doesn't exist, create a new Crop with this data.
     */
    create: XOR<CropCreateInput, CropUncheckedCreateInput>
    /**
     * In case the Crop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CropUpdateInput, CropUncheckedUpdateInput>
  }

  /**
   * Crop delete
   */
  export type CropDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * Filter which Crop to delete.
     */
    where: CropWhereUniqueInput
  }

  /**
   * Crop deleteMany
   */
  export type CropDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Crops to delete
     */
    where?: CropWhereInput
  }

  /**
   * Crop.calendars
   */
  export type Crop$calendarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    where?: CalendarWhereInput
    orderBy?: CalendarOrderByWithRelationInput | CalendarOrderByWithRelationInput[]
    cursor?: CalendarWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarScalarFieldEnum | CalendarScalarFieldEnum[]
  }

  /**
   * Crop without action
   */
  export type CropDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
  }


  /**
   * Model Creator
   */

  export type AggregateCreator = {
    _count: CreatorCountAggregateOutputType | null
    _min: CreatorMinAggregateOutputType | null
    _max: CreatorMaxAggregateOutputType | null
  }

  export type CreatorMinAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CreatorMaxAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CreatorCountAggregateOutputType = {
    id: number
    name: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CreatorMinAggregateInputType = {
    id?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CreatorMaxAggregateInputType = {
    id?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CreatorCountAggregateInputType = {
    id?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CreatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Creator to aggregate.
     */
    where?: CreatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creators to fetch.
     */
    orderBy?: CreatorOrderByWithRelationInput | CreatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Creators
    **/
    _count?: true | CreatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreatorMaxAggregateInputType
  }

  export type GetCreatorAggregateType<T extends CreatorAggregateArgs> = {
        [P in keyof T & keyof AggregateCreator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreator[P]>
      : GetScalarType<T[P], AggregateCreator[P]>
  }




  export type CreatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatorWhereInput
    orderBy?: CreatorOrderByWithAggregationInput | CreatorOrderByWithAggregationInput[]
    by: CreatorScalarFieldEnum[] | CreatorScalarFieldEnum
    having?: CreatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreatorCountAggregateInputType | true
    _min?: CreatorMinAggregateInputType
    _max?: CreatorMaxAggregateInputType
  }

  export type CreatorGroupByOutputType = {
    id: string
    name: string
    role: string
    createdAt: Date
    updatedAt: Date
    _count: CreatorCountAggregateOutputType | null
    _min: CreatorMinAggregateOutputType | null
    _max: CreatorMaxAggregateOutputType | null
  }

  type GetCreatorGroupByPayload<T extends CreatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreatorGroupByOutputType[P]>
            : GetScalarType<T[P], CreatorGroupByOutputType[P]>
        }
      >
    >


  export type CreatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    calendars?: boolean | Creator$calendarsArgs<ExtArgs>
    _count?: boolean | CreatorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creator"]>

  export type CreatorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["creator"]>

  export type CreatorSelectScalar = {
    id?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CreatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calendars?: boolean | Creator$calendarsArgs<ExtArgs>
    _count?: boolean | CreatorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CreatorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CreatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Creator"
    objects: {
      calendars: Prisma.$CalendarPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      role: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["creator"]>
    composites: {}
  }

  type CreatorGetPayload<S extends boolean | null | undefined | CreatorDefaultArgs> = $Result.GetResult<Prisma.$CreatorPayload, S>

  type CreatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CreatorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CreatorCountAggregateInputType | true
    }

  export interface CreatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Creator'], meta: { name: 'Creator' } }
    /**
     * Find zero or one Creator that matches the filter.
     * @param {CreatorFindUniqueArgs} args - Arguments to find a Creator
     * @example
     * // Get one Creator
     * const creator = await prisma.creator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreatorFindUniqueArgs>(args: SelectSubset<T, CreatorFindUniqueArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Creator that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CreatorFindUniqueOrThrowArgs} args - Arguments to find a Creator
     * @example
     * // Get one Creator
     * const creator = await prisma.creator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreatorFindUniqueOrThrowArgs>(args: SelectSubset<T, CreatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Creator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorFindFirstArgs} args - Arguments to find a Creator
     * @example
     * // Get one Creator
     * const creator = await prisma.creator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreatorFindFirstArgs>(args?: SelectSubset<T, CreatorFindFirstArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Creator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorFindFirstOrThrowArgs} args - Arguments to find a Creator
     * @example
     * // Get one Creator
     * const creator = await prisma.creator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreatorFindFirstOrThrowArgs>(args?: SelectSubset<T, CreatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Creators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Creators
     * const creators = await prisma.creator.findMany()
     * 
     * // Get first 10 Creators
     * const creators = await prisma.creator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creatorWithIdOnly = await prisma.creator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreatorFindManyArgs>(args?: SelectSubset<T, CreatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Creator.
     * @param {CreatorCreateArgs} args - Arguments to create a Creator.
     * @example
     * // Create one Creator
     * const Creator = await prisma.creator.create({
     *   data: {
     *     // ... data to create a Creator
     *   }
     * })
     * 
     */
    create<T extends CreatorCreateArgs>(args: SelectSubset<T, CreatorCreateArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Creators.
     * @param {CreatorCreateManyArgs} args - Arguments to create many Creators.
     * @example
     * // Create many Creators
     * const creator = await prisma.creator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreatorCreateManyArgs>(args?: SelectSubset<T, CreatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Creators and returns the data saved in the database.
     * @param {CreatorCreateManyAndReturnArgs} args - Arguments to create many Creators.
     * @example
     * // Create many Creators
     * const creator = await prisma.creator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Creators and only return the `id`
     * const creatorWithIdOnly = await prisma.creator.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreatorCreateManyAndReturnArgs>(args?: SelectSubset<T, CreatorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Creator.
     * @param {CreatorDeleteArgs} args - Arguments to delete one Creator.
     * @example
     * // Delete one Creator
     * const Creator = await prisma.creator.delete({
     *   where: {
     *     // ... filter to delete one Creator
     *   }
     * })
     * 
     */
    delete<T extends CreatorDeleteArgs>(args: SelectSubset<T, CreatorDeleteArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Creator.
     * @param {CreatorUpdateArgs} args - Arguments to update one Creator.
     * @example
     * // Update one Creator
     * const creator = await prisma.creator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreatorUpdateArgs>(args: SelectSubset<T, CreatorUpdateArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Creators.
     * @param {CreatorDeleteManyArgs} args - Arguments to filter Creators to delete.
     * @example
     * // Delete a few Creators
     * const { count } = await prisma.creator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreatorDeleteManyArgs>(args?: SelectSubset<T, CreatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Creators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Creators
     * const creator = await prisma.creator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreatorUpdateManyArgs>(args: SelectSubset<T, CreatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Creator.
     * @param {CreatorUpsertArgs} args - Arguments to update or create a Creator.
     * @example
     * // Update or create a Creator
     * const creator = await prisma.creator.upsert({
     *   create: {
     *     // ... data to create a Creator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Creator we want to update
     *   }
     * })
     */
    upsert<T extends CreatorUpsertArgs>(args: SelectSubset<T, CreatorUpsertArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Creators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorCountArgs} args - Arguments to filter Creators to count.
     * @example
     * // Count the number of Creators
     * const count = await prisma.creator.count({
     *   where: {
     *     // ... the filter for the Creators we want to count
     *   }
     * })
    **/
    count<T extends CreatorCountArgs>(
      args?: Subset<T, CreatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Creator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreatorAggregateArgs>(args: Subset<T, CreatorAggregateArgs>): Prisma.PrismaPromise<GetCreatorAggregateType<T>>

    /**
     * Group by Creator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreatorGroupByArgs['orderBy'] }
        : { orderBy?: CreatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Creator model
   */
  readonly fields: CreatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Creator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    calendars<T extends Creator$calendarsArgs<ExtArgs> = {}>(args?: Subset<T, Creator$calendarsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Creator model
   */ 
  interface CreatorFieldRefs {
    readonly id: FieldRef<"Creator", 'String'>
    readonly name: FieldRef<"Creator", 'String'>
    readonly role: FieldRef<"Creator", 'String'>
    readonly createdAt: FieldRef<"Creator", 'DateTime'>
    readonly updatedAt: FieldRef<"Creator", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Creator findUnique
   */
  export type CreatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * Filter, which Creator to fetch.
     */
    where: CreatorWhereUniqueInput
  }

  /**
   * Creator findUniqueOrThrow
   */
  export type CreatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * Filter, which Creator to fetch.
     */
    where: CreatorWhereUniqueInput
  }

  /**
   * Creator findFirst
   */
  export type CreatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * Filter, which Creator to fetch.
     */
    where?: CreatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creators to fetch.
     */
    orderBy?: CreatorOrderByWithRelationInput | CreatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Creators.
     */
    cursor?: CreatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Creators.
     */
    distinct?: CreatorScalarFieldEnum | CreatorScalarFieldEnum[]
  }

  /**
   * Creator findFirstOrThrow
   */
  export type CreatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * Filter, which Creator to fetch.
     */
    where?: CreatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creators to fetch.
     */
    orderBy?: CreatorOrderByWithRelationInput | CreatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Creators.
     */
    cursor?: CreatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Creators.
     */
    distinct?: CreatorScalarFieldEnum | CreatorScalarFieldEnum[]
  }

  /**
   * Creator findMany
   */
  export type CreatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * Filter, which Creators to fetch.
     */
    where?: CreatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creators to fetch.
     */
    orderBy?: CreatorOrderByWithRelationInput | CreatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Creators.
     */
    cursor?: CreatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creators.
     */
    skip?: number
    distinct?: CreatorScalarFieldEnum | CreatorScalarFieldEnum[]
  }

  /**
   * Creator create
   */
  export type CreatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * The data needed to create a Creator.
     */
    data: XOR<CreatorCreateInput, CreatorUncheckedCreateInput>
  }

  /**
   * Creator createMany
   */
  export type CreatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Creators.
     */
    data: CreatorCreateManyInput | CreatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Creator createManyAndReturn
   */
  export type CreatorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Creators.
     */
    data: CreatorCreateManyInput | CreatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Creator update
   */
  export type CreatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * The data needed to update a Creator.
     */
    data: XOR<CreatorUpdateInput, CreatorUncheckedUpdateInput>
    /**
     * Choose, which Creator to update.
     */
    where: CreatorWhereUniqueInput
  }

  /**
   * Creator updateMany
   */
  export type CreatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Creators.
     */
    data: XOR<CreatorUpdateManyMutationInput, CreatorUncheckedUpdateManyInput>
    /**
     * Filter which Creators to update
     */
    where?: CreatorWhereInput
  }

  /**
   * Creator upsert
   */
  export type CreatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * The filter to search for the Creator to update in case it exists.
     */
    where: CreatorWhereUniqueInput
    /**
     * In case the Creator found by the `where` argument doesn't exist, create a new Creator with this data.
     */
    create: XOR<CreatorCreateInput, CreatorUncheckedCreateInput>
    /**
     * In case the Creator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreatorUpdateInput, CreatorUncheckedUpdateInput>
  }

  /**
   * Creator delete
   */
  export type CreatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * Filter which Creator to delete.
     */
    where: CreatorWhereUniqueInput
  }

  /**
   * Creator deleteMany
   */
  export type CreatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Creators to delete
     */
    where?: CreatorWhereInput
  }

  /**
   * Creator.calendars
   */
  export type Creator$calendarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    where?: CalendarWhereInput
    orderBy?: CalendarOrderByWithRelationInput | CalendarOrderByWithRelationInput[]
    cursor?: CalendarWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarScalarFieldEnum | CalendarScalarFieldEnum[]
  }

  /**
   * Creator without action
   */
  export type CreatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
  }


  /**
   * Model Calendar
   */

  export type AggregateCalendar = {
    _count: CalendarCountAggregateOutputType | null
    _min: CalendarMinAggregateOutputType | null
    _max: CalendarMaxAggregateOutputType | null
  }

  export type CalendarMinAggregateOutputType = {
    id: string | null
    cropId: string | null
    creatorId: string | null
    sourceCalendarId: string | null
    title: string | null
    zoneName: string | null
    isShared: boolean | null
    isPublished: boolean | null
    fileType: $Enums.CalendarFileType | null
    allowCenterUse: boolean | null
    sharedAt: Date | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalendarMaxAggregateOutputType = {
    id: string | null
    cropId: string | null
    creatorId: string | null
    sourceCalendarId: string | null
    title: string | null
    zoneName: string | null
    isShared: boolean | null
    isPublished: boolean | null
    fileType: $Enums.CalendarFileType | null
    allowCenterUse: boolean | null
    sharedAt: Date | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalendarCountAggregateOutputType = {
    id: number
    cropId: number
    creatorId: number
    sourceCalendarId: number
    title: number
    zoneName: number
    isShared: number
    isPublished: number
    fileType: number
    allowCenterUse: number
    sharedAt: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CalendarMinAggregateInputType = {
    id?: true
    cropId?: true
    creatorId?: true
    sourceCalendarId?: true
    title?: true
    zoneName?: true
    isShared?: true
    isPublished?: true
    fileType?: true
    allowCenterUse?: true
    sharedAt?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalendarMaxAggregateInputType = {
    id?: true
    cropId?: true
    creatorId?: true
    sourceCalendarId?: true
    title?: true
    zoneName?: true
    isShared?: true
    isPublished?: true
    fileType?: true
    allowCenterUse?: true
    sharedAt?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalendarCountAggregateInputType = {
    id?: true
    cropId?: true
    creatorId?: true
    sourceCalendarId?: true
    title?: true
    zoneName?: true
    isShared?: true
    isPublished?: true
    fileType?: true
    allowCenterUse?: true
    sharedAt?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CalendarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Calendar to aggregate.
     */
    where?: CalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calendars to fetch.
     */
    orderBy?: CalendarOrderByWithRelationInput | CalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Calendars
    **/
    _count?: true | CalendarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarMaxAggregateInputType
  }

  export type GetCalendarAggregateType<T extends CalendarAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendar[P]>
      : GetScalarType<T[P], AggregateCalendar[P]>
  }




  export type CalendarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarWhereInput
    orderBy?: CalendarOrderByWithAggregationInput | CalendarOrderByWithAggregationInput[]
    by: CalendarScalarFieldEnum[] | CalendarScalarFieldEnum
    having?: CalendarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarCountAggregateInputType | true
    _min?: CalendarMinAggregateInputType
    _max?: CalendarMaxAggregateInputType
  }

  export type CalendarGroupByOutputType = {
    id: string
    cropId: string
    creatorId: string
    sourceCalendarId: string | null
    title: string
    zoneName: string
    isShared: boolean
    isPublished: boolean
    fileType: $Enums.CalendarFileType
    allowCenterUse: boolean
    sharedAt: Date | null
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CalendarCountAggregateOutputType | null
    _min: CalendarMinAggregateOutputType | null
    _max: CalendarMaxAggregateOutputType | null
  }

  type GetCalendarGroupByPayload<T extends CalendarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarGroupByOutputType[P]>
        }
      >
    >


  export type CalendarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cropId?: boolean
    creatorId?: boolean
    sourceCalendarId?: boolean
    title?: boolean
    zoneName?: boolean
    isShared?: boolean
    isPublished?: boolean
    fileType?: boolean
    allowCenterUse?: boolean
    sharedAt?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    crop?: boolean | CropDefaultArgs<ExtArgs>
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
    sourceCalendar?: boolean | Calendar$sourceCalendarArgs<ExtArgs>
    copy?: boolean | Calendar$copyArgs<ExtArgs>
    stages?: boolean | Calendar$stagesArgs<ExtArgs>
    districts?: boolean | Calendar$districtsArgs<ExtArgs>
    _count?: boolean | CalendarCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendar"]>

  export type CalendarSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cropId?: boolean
    creatorId?: boolean
    sourceCalendarId?: boolean
    title?: boolean
    zoneName?: boolean
    isShared?: boolean
    isPublished?: boolean
    fileType?: boolean
    allowCenterUse?: boolean
    sharedAt?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    crop?: boolean | CropDefaultArgs<ExtArgs>
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
    sourceCalendar?: boolean | Calendar$sourceCalendarArgs<ExtArgs>
  }, ExtArgs["result"]["calendar"]>

  export type CalendarSelectScalar = {
    id?: boolean
    cropId?: boolean
    creatorId?: boolean
    sourceCalendarId?: boolean
    title?: boolean
    zoneName?: boolean
    isShared?: boolean
    isPublished?: boolean
    fileType?: boolean
    allowCenterUse?: boolean
    sharedAt?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CalendarInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crop?: boolean | CropDefaultArgs<ExtArgs>
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
    sourceCalendar?: boolean | Calendar$sourceCalendarArgs<ExtArgs>
    copy?: boolean | Calendar$copyArgs<ExtArgs>
    stages?: boolean | Calendar$stagesArgs<ExtArgs>
    districts?: boolean | Calendar$districtsArgs<ExtArgs>
    _count?: boolean | CalendarCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CalendarIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crop?: boolean | CropDefaultArgs<ExtArgs>
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
    sourceCalendar?: boolean | Calendar$sourceCalendarArgs<ExtArgs>
  }

  export type $CalendarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Calendar"
    objects: {
      crop: Prisma.$CropPayload<ExtArgs>
      creator: Prisma.$CreatorPayload<ExtArgs>
      sourceCalendar: Prisma.$CalendarPayload<ExtArgs> | null
      copy: Prisma.$CalendarPayload<ExtArgs> | null
      stages: Prisma.$StagePayload<ExtArgs>[]
      districts: Prisma.$CalendarDistrictPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cropId: string
      creatorId: string
      sourceCalendarId: string | null
      title: string
      zoneName: string
      isShared: boolean
      isPublished: boolean
      fileType: $Enums.CalendarFileType
      allowCenterUse: boolean
      sharedAt: Date | null
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["calendar"]>
    composites: {}
  }

  type CalendarGetPayload<S extends boolean | null | undefined | CalendarDefaultArgs> = $Result.GetResult<Prisma.$CalendarPayload, S>

  type CalendarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CalendarFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CalendarCountAggregateInputType | true
    }

  export interface CalendarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Calendar'], meta: { name: 'Calendar' } }
    /**
     * Find zero or one Calendar that matches the filter.
     * @param {CalendarFindUniqueArgs} args - Arguments to find a Calendar
     * @example
     * // Get one Calendar
     * const calendar = await prisma.calendar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalendarFindUniqueArgs>(args: SelectSubset<T, CalendarFindUniqueArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Calendar that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CalendarFindUniqueOrThrowArgs} args - Arguments to find a Calendar
     * @example
     * // Get one Calendar
     * const calendar = await prisma.calendar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalendarFindUniqueOrThrowArgs>(args: SelectSubset<T, CalendarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Calendar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarFindFirstArgs} args - Arguments to find a Calendar
     * @example
     * // Get one Calendar
     * const calendar = await prisma.calendar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalendarFindFirstArgs>(args?: SelectSubset<T, CalendarFindFirstArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Calendar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarFindFirstOrThrowArgs} args - Arguments to find a Calendar
     * @example
     * // Get one Calendar
     * const calendar = await prisma.calendar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalendarFindFirstOrThrowArgs>(args?: SelectSubset<T, CalendarFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Calendars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Calendars
     * const calendars = await prisma.calendar.findMany()
     * 
     * // Get first 10 Calendars
     * const calendars = await prisma.calendar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarWithIdOnly = await prisma.calendar.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalendarFindManyArgs>(args?: SelectSubset<T, CalendarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Calendar.
     * @param {CalendarCreateArgs} args - Arguments to create a Calendar.
     * @example
     * // Create one Calendar
     * const Calendar = await prisma.calendar.create({
     *   data: {
     *     // ... data to create a Calendar
     *   }
     * })
     * 
     */
    create<T extends CalendarCreateArgs>(args: SelectSubset<T, CalendarCreateArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Calendars.
     * @param {CalendarCreateManyArgs} args - Arguments to create many Calendars.
     * @example
     * // Create many Calendars
     * const calendar = await prisma.calendar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalendarCreateManyArgs>(args?: SelectSubset<T, CalendarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Calendars and returns the data saved in the database.
     * @param {CalendarCreateManyAndReturnArgs} args - Arguments to create many Calendars.
     * @example
     * // Create many Calendars
     * const calendar = await prisma.calendar.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Calendars and only return the `id`
     * const calendarWithIdOnly = await prisma.calendar.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CalendarCreateManyAndReturnArgs>(args?: SelectSubset<T, CalendarCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Calendar.
     * @param {CalendarDeleteArgs} args - Arguments to delete one Calendar.
     * @example
     * // Delete one Calendar
     * const Calendar = await prisma.calendar.delete({
     *   where: {
     *     // ... filter to delete one Calendar
     *   }
     * })
     * 
     */
    delete<T extends CalendarDeleteArgs>(args: SelectSubset<T, CalendarDeleteArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Calendar.
     * @param {CalendarUpdateArgs} args - Arguments to update one Calendar.
     * @example
     * // Update one Calendar
     * const calendar = await prisma.calendar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalendarUpdateArgs>(args: SelectSubset<T, CalendarUpdateArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Calendars.
     * @param {CalendarDeleteManyArgs} args - Arguments to filter Calendars to delete.
     * @example
     * // Delete a few Calendars
     * const { count } = await prisma.calendar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalendarDeleteManyArgs>(args?: SelectSubset<T, CalendarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Calendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Calendars
     * const calendar = await prisma.calendar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalendarUpdateManyArgs>(args: SelectSubset<T, CalendarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Calendar.
     * @param {CalendarUpsertArgs} args - Arguments to update or create a Calendar.
     * @example
     * // Update or create a Calendar
     * const calendar = await prisma.calendar.upsert({
     *   create: {
     *     // ... data to create a Calendar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Calendar we want to update
     *   }
     * })
     */
    upsert<T extends CalendarUpsertArgs>(args: SelectSubset<T, CalendarUpsertArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Calendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarCountArgs} args - Arguments to filter Calendars to count.
     * @example
     * // Count the number of Calendars
     * const count = await prisma.calendar.count({
     *   where: {
     *     // ... the filter for the Calendars we want to count
     *   }
     * })
    **/
    count<T extends CalendarCountArgs>(
      args?: Subset<T, CalendarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Calendar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarAggregateArgs>(args: Subset<T, CalendarAggregateArgs>): Prisma.PrismaPromise<GetCalendarAggregateType<T>>

    /**
     * Group by Calendar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarGroupByArgs['orderBy'] }
        : { orderBy?: CalendarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Calendar model
   */
  readonly fields: CalendarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Calendar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalendarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    crop<T extends CropDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CropDefaultArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creator<T extends CreatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreatorDefaultArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sourceCalendar<T extends Calendar$sourceCalendarArgs<ExtArgs> = {}>(args?: Subset<T, Calendar$sourceCalendarArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    copy<T extends Calendar$copyArgs<ExtArgs> = {}>(args?: Subset<T, Calendar$copyArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    stages<T extends Calendar$stagesArgs<ExtArgs> = {}>(args?: Subset<T, Calendar$stagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findMany"> | Null>
    districts<T extends Calendar$districtsArgs<ExtArgs> = {}>(args?: Subset<T, Calendar$districtsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarDistrictPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Calendar model
   */ 
  interface CalendarFieldRefs {
    readonly id: FieldRef<"Calendar", 'String'>
    readonly cropId: FieldRef<"Calendar", 'String'>
    readonly creatorId: FieldRef<"Calendar", 'String'>
    readonly sourceCalendarId: FieldRef<"Calendar", 'String'>
    readonly title: FieldRef<"Calendar", 'String'>
    readonly zoneName: FieldRef<"Calendar", 'String'>
    readonly isShared: FieldRef<"Calendar", 'Boolean'>
    readonly isPublished: FieldRef<"Calendar", 'Boolean'>
    readonly fileType: FieldRef<"Calendar", 'CalendarFileType'>
    readonly allowCenterUse: FieldRef<"Calendar", 'Boolean'>
    readonly sharedAt: FieldRef<"Calendar", 'DateTime'>
    readonly publishedAt: FieldRef<"Calendar", 'DateTime'>
    readonly createdAt: FieldRef<"Calendar", 'DateTime'>
    readonly updatedAt: FieldRef<"Calendar", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Calendar findUnique
   */
  export type CalendarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * Filter, which Calendar to fetch.
     */
    where: CalendarWhereUniqueInput
  }

  /**
   * Calendar findUniqueOrThrow
   */
  export type CalendarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * Filter, which Calendar to fetch.
     */
    where: CalendarWhereUniqueInput
  }

  /**
   * Calendar findFirst
   */
  export type CalendarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * Filter, which Calendar to fetch.
     */
    where?: CalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calendars to fetch.
     */
    orderBy?: CalendarOrderByWithRelationInput | CalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Calendars.
     */
    cursor?: CalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Calendars.
     */
    distinct?: CalendarScalarFieldEnum | CalendarScalarFieldEnum[]
  }

  /**
   * Calendar findFirstOrThrow
   */
  export type CalendarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * Filter, which Calendar to fetch.
     */
    where?: CalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calendars to fetch.
     */
    orderBy?: CalendarOrderByWithRelationInput | CalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Calendars.
     */
    cursor?: CalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Calendars.
     */
    distinct?: CalendarScalarFieldEnum | CalendarScalarFieldEnum[]
  }

  /**
   * Calendar findMany
   */
  export type CalendarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * Filter, which Calendars to fetch.
     */
    where?: CalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calendars to fetch.
     */
    orderBy?: CalendarOrderByWithRelationInput | CalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Calendars.
     */
    cursor?: CalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calendars.
     */
    skip?: number
    distinct?: CalendarScalarFieldEnum | CalendarScalarFieldEnum[]
  }

  /**
   * Calendar create
   */
  export type CalendarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * The data needed to create a Calendar.
     */
    data: XOR<CalendarCreateInput, CalendarUncheckedCreateInput>
  }

  /**
   * Calendar createMany
   */
  export type CalendarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Calendars.
     */
    data: CalendarCreateManyInput | CalendarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Calendar createManyAndReturn
   */
  export type CalendarCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Calendars.
     */
    data: CalendarCreateManyInput | CalendarCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Calendar update
   */
  export type CalendarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * The data needed to update a Calendar.
     */
    data: XOR<CalendarUpdateInput, CalendarUncheckedUpdateInput>
    /**
     * Choose, which Calendar to update.
     */
    where: CalendarWhereUniqueInput
  }

  /**
   * Calendar updateMany
   */
  export type CalendarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Calendars.
     */
    data: XOR<CalendarUpdateManyMutationInput, CalendarUncheckedUpdateManyInput>
    /**
     * Filter which Calendars to update
     */
    where?: CalendarWhereInput
  }

  /**
   * Calendar upsert
   */
  export type CalendarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * The filter to search for the Calendar to update in case it exists.
     */
    where: CalendarWhereUniqueInput
    /**
     * In case the Calendar found by the `where` argument doesn't exist, create a new Calendar with this data.
     */
    create: XOR<CalendarCreateInput, CalendarUncheckedCreateInput>
    /**
     * In case the Calendar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarUpdateInput, CalendarUncheckedUpdateInput>
  }

  /**
   * Calendar delete
   */
  export type CalendarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * Filter which Calendar to delete.
     */
    where: CalendarWhereUniqueInput
  }

  /**
   * Calendar deleteMany
   */
  export type CalendarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Calendars to delete
     */
    where?: CalendarWhereInput
  }

  /**
   * Calendar.sourceCalendar
   */
  export type Calendar$sourceCalendarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    where?: CalendarWhereInput
  }

  /**
   * Calendar.copy
   */
  export type Calendar$copyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    where?: CalendarWhereInput
  }

  /**
   * Calendar.stages
   */
  export type Calendar$stagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    where?: StageWhereInput
    orderBy?: StageOrderByWithRelationInput | StageOrderByWithRelationInput[]
    cursor?: StageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StageScalarFieldEnum | StageScalarFieldEnum[]
  }

  /**
   * Calendar.districts
   */
  export type Calendar$districtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarDistrict
     */
    select?: CalendarDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarDistrictInclude<ExtArgs> | null
    where?: CalendarDistrictWhereInput
    orderBy?: CalendarDistrictOrderByWithRelationInput | CalendarDistrictOrderByWithRelationInput[]
    cursor?: CalendarDistrictWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarDistrictScalarFieldEnum | CalendarDistrictScalarFieldEnum[]
  }

  /**
   * Calendar without action
   */
  export type CalendarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
  }


  /**
   * Model City
   */

  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type CityMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type CityMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type CityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which City to aggregate.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
    orderBy?: CityOrderByWithAggregationInput | CityOrderByWithAggregationInput[]
    by: CityScalarFieldEnum[] | CityScalarFieldEnum
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }

  export type CityGroupByOutputType = {
    id: string
    name: string
    _count: CityCountAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type CitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    districts?: boolean | City$districtsArgs<ExtArgs>
    calendarDistricts?: boolean | City$calendarDistrictsArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["city"]>

  export type CitySelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type CityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    districts?: boolean | City$districtsArgs<ExtArgs>
    calendarDistricts?: boolean | City$calendarDistrictsArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "City"
    objects: {
      districts: Prisma.$DistrictPayload<ExtArgs>[]
      calendarDistricts: Prisma.$CalendarDistrictPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["city"]>
    composites: {}
  }

  type CityGetPayload<S extends boolean | null | undefined | CityDefaultArgs> = $Result.GetResult<Prisma.$CityPayload, S>

  type CityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CityCountAggregateInputType | true
    }

  export interface CityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['City'], meta: { name: 'City' } }
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CityFindUniqueArgs>(args: SelectSubset<T, CityFindUniqueArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one City that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CityFindUniqueOrThrowArgs>(args: SelectSubset<T, CityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CityFindFirstArgs>(args?: SelectSubset<T, CityFindFirstArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first City that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CityFindFirstOrThrowArgs>(args?: SelectSubset<T, CityFindFirstOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CityFindManyArgs>(args?: SelectSubset<T, CityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
     */
    create<T extends CityCreateArgs>(args: SelectSubset<T, CityCreateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cities.
     * @param {CityCreateManyArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CityCreateManyArgs>(args?: SelectSubset<T, CityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cities and returns the data saved in the database.
     * @param {CityCreateManyAndReturnArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cities and only return the `id`
     * const cityWithIdOnly = await prisma.city.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CityCreateManyAndReturnArgs>(args?: SelectSubset<T, CityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
     */
    delete<T extends CityDeleteArgs>(args: SelectSubset<T, CityDeleteArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CityUpdateArgs>(args: SelectSubset<T, CityUpdateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CityDeleteManyArgs>(args?: SelectSubset<T, CityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CityUpdateManyArgs>(args: SelectSubset<T, CityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
     */
    upsert<T extends CityUpsertArgs>(args: SelectSubset<T, CityUpsertArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): Prisma.PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the City model
   */
  readonly fields: CityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    districts<T extends City$districtsArgs<ExtArgs> = {}>(args?: Subset<T, City$districtsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findMany"> | Null>
    calendarDistricts<T extends City$calendarDistrictsArgs<ExtArgs> = {}>(args?: Subset<T, City$calendarDistrictsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarDistrictPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the City model
   */ 
  interface CityFieldRefs {
    readonly id: FieldRef<"City", 'String'>
    readonly name: FieldRef<"City", 'String'>
  }
    

  // Custom InputTypes
  /**
   * City findUnique
   */
  export type CityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findUniqueOrThrow
   */
  export type CityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findFirst
   */
  export type CityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findFirstOrThrow
   */
  export type CityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findMany
   */
  export type CityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which Cities to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City create
   */
  export type CityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to create a City.
     */
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }

  /**
   * City createMany
   */
  export type CityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * City createManyAndReturn
   */
  export type CityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * City update
   */
  export type CityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to update a City.
     */
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City updateMany
   */
  export type CityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
  }

  /**
   * City upsert
   */
  export type CityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The filter to search for the City to update in case it exists.
     */
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     */
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }

  /**
   * City delete
   */
  export type CityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter which City to delete.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cities to delete
     */
    where?: CityWhereInput
  }

  /**
   * City.districts
   */
  export type City$districtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    where?: DistrictWhereInput
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    cursor?: DistrictWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DistrictScalarFieldEnum | DistrictScalarFieldEnum[]
  }

  /**
   * City.calendarDistricts
   */
  export type City$calendarDistrictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarDistrict
     */
    select?: CalendarDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarDistrictInclude<ExtArgs> | null
    where?: CalendarDistrictWhereInput
    orderBy?: CalendarDistrictOrderByWithRelationInput | CalendarDistrictOrderByWithRelationInput[]
    cursor?: CalendarDistrictWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarDistrictScalarFieldEnum | CalendarDistrictScalarFieldEnum[]
  }

  /**
   * City without action
   */
  export type CityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
  }


  /**
   * Model District
   */

  export type AggregateDistrict = {
    _count: DistrictCountAggregateOutputType | null
    _min: DistrictMinAggregateOutputType | null
    _max: DistrictMaxAggregateOutputType | null
  }

  export type DistrictMinAggregateOutputType = {
    id: string | null
    cityId: string | null
    name: string | null
  }

  export type DistrictMaxAggregateOutputType = {
    id: string | null
    cityId: string | null
    name: string | null
  }

  export type DistrictCountAggregateOutputType = {
    id: number
    cityId: number
    name: number
    _all: number
  }


  export type DistrictMinAggregateInputType = {
    id?: true
    cityId?: true
    name?: true
  }

  export type DistrictMaxAggregateInputType = {
    id?: true
    cityId?: true
    name?: true
  }

  export type DistrictCountAggregateInputType = {
    id?: true
    cityId?: true
    name?: true
    _all?: true
  }

  export type DistrictAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which District to aggregate.
     */
    where?: DistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Districts to fetch.
     */
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Districts
    **/
    _count?: true | DistrictCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DistrictMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DistrictMaxAggregateInputType
  }

  export type GetDistrictAggregateType<T extends DistrictAggregateArgs> = {
        [P in keyof T & keyof AggregateDistrict]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDistrict[P]>
      : GetScalarType<T[P], AggregateDistrict[P]>
  }




  export type DistrictGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DistrictWhereInput
    orderBy?: DistrictOrderByWithAggregationInput | DistrictOrderByWithAggregationInput[]
    by: DistrictScalarFieldEnum[] | DistrictScalarFieldEnum
    having?: DistrictScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DistrictCountAggregateInputType | true
    _min?: DistrictMinAggregateInputType
    _max?: DistrictMaxAggregateInputType
  }

  export type DistrictGroupByOutputType = {
    id: string
    cityId: string
    name: string
    _count: DistrictCountAggregateOutputType | null
    _min: DistrictMinAggregateOutputType | null
    _max: DistrictMaxAggregateOutputType | null
  }

  type GetDistrictGroupByPayload<T extends DistrictGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DistrictGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DistrictGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DistrictGroupByOutputType[P]>
            : GetScalarType<T[P], DistrictGroupByOutputType[P]>
        }
      >
    >


  export type DistrictSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cityId?: boolean
    name?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
    calendarDistricts?: boolean | District$calendarDistrictsArgs<ExtArgs>
    _count?: boolean | DistrictCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["district"]>

  export type DistrictSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cityId?: boolean
    name?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["district"]>

  export type DistrictSelectScalar = {
    id?: boolean
    cityId?: boolean
    name?: boolean
  }

  export type DistrictInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
    calendarDistricts?: boolean | District$calendarDistrictsArgs<ExtArgs>
    _count?: boolean | DistrictCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DistrictIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
  }

  export type $DistrictPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "District"
    objects: {
      city: Prisma.$CityPayload<ExtArgs>
      calendarDistricts: Prisma.$CalendarDistrictPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cityId: string
      name: string
    }, ExtArgs["result"]["district"]>
    composites: {}
  }

  type DistrictGetPayload<S extends boolean | null | undefined | DistrictDefaultArgs> = $Result.GetResult<Prisma.$DistrictPayload, S>

  type DistrictCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DistrictFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DistrictCountAggregateInputType | true
    }

  export interface DistrictDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['District'], meta: { name: 'District' } }
    /**
     * Find zero or one District that matches the filter.
     * @param {DistrictFindUniqueArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DistrictFindUniqueArgs>(args: SelectSubset<T, DistrictFindUniqueArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one District that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DistrictFindUniqueOrThrowArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DistrictFindUniqueOrThrowArgs>(args: SelectSubset<T, DistrictFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first District that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictFindFirstArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DistrictFindFirstArgs>(args?: SelectSubset<T, DistrictFindFirstArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first District that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictFindFirstOrThrowArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DistrictFindFirstOrThrowArgs>(args?: SelectSubset<T, DistrictFindFirstOrThrowArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Districts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Districts
     * const districts = await prisma.district.findMany()
     * 
     * // Get first 10 Districts
     * const districts = await prisma.district.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const districtWithIdOnly = await prisma.district.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DistrictFindManyArgs>(args?: SelectSubset<T, DistrictFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a District.
     * @param {DistrictCreateArgs} args - Arguments to create a District.
     * @example
     * // Create one District
     * const District = await prisma.district.create({
     *   data: {
     *     // ... data to create a District
     *   }
     * })
     * 
     */
    create<T extends DistrictCreateArgs>(args: SelectSubset<T, DistrictCreateArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Districts.
     * @param {DistrictCreateManyArgs} args - Arguments to create many Districts.
     * @example
     * // Create many Districts
     * const district = await prisma.district.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DistrictCreateManyArgs>(args?: SelectSubset<T, DistrictCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Districts and returns the data saved in the database.
     * @param {DistrictCreateManyAndReturnArgs} args - Arguments to create many Districts.
     * @example
     * // Create many Districts
     * const district = await prisma.district.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Districts and only return the `id`
     * const districtWithIdOnly = await prisma.district.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DistrictCreateManyAndReturnArgs>(args?: SelectSubset<T, DistrictCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a District.
     * @param {DistrictDeleteArgs} args - Arguments to delete one District.
     * @example
     * // Delete one District
     * const District = await prisma.district.delete({
     *   where: {
     *     // ... filter to delete one District
     *   }
     * })
     * 
     */
    delete<T extends DistrictDeleteArgs>(args: SelectSubset<T, DistrictDeleteArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one District.
     * @param {DistrictUpdateArgs} args - Arguments to update one District.
     * @example
     * // Update one District
     * const district = await prisma.district.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DistrictUpdateArgs>(args: SelectSubset<T, DistrictUpdateArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Districts.
     * @param {DistrictDeleteManyArgs} args - Arguments to filter Districts to delete.
     * @example
     * // Delete a few Districts
     * const { count } = await prisma.district.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DistrictDeleteManyArgs>(args?: SelectSubset<T, DistrictDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Districts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Districts
     * const district = await prisma.district.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DistrictUpdateManyArgs>(args: SelectSubset<T, DistrictUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one District.
     * @param {DistrictUpsertArgs} args - Arguments to update or create a District.
     * @example
     * // Update or create a District
     * const district = await prisma.district.upsert({
     *   create: {
     *     // ... data to create a District
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the District we want to update
     *   }
     * })
     */
    upsert<T extends DistrictUpsertArgs>(args: SelectSubset<T, DistrictUpsertArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Districts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictCountArgs} args - Arguments to filter Districts to count.
     * @example
     * // Count the number of Districts
     * const count = await prisma.district.count({
     *   where: {
     *     // ... the filter for the Districts we want to count
     *   }
     * })
    **/
    count<T extends DistrictCountArgs>(
      args?: Subset<T, DistrictCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DistrictCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a District.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DistrictAggregateArgs>(args: Subset<T, DistrictAggregateArgs>): Prisma.PrismaPromise<GetDistrictAggregateType<T>>

    /**
     * Group by District.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DistrictGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DistrictGroupByArgs['orderBy'] }
        : { orderBy?: DistrictGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DistrictGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDistrictGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the District model
   */
  readonly fields: DistrictFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for District.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DistrictClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    calendarDistricts<T extends District$calendarDistrictsArgs<ExtArgs> = {}>(args?: Subset<T, District$calendarDistrictsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarDistrictPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the District model
   */ 
  interface DistrictFieldRefs {
    readonly id: FieldRef<"District", 'String'>
    readonly cityId: FieldRef<"District", 'String'>
    readonly name: FieldRef<"District", 'String'>
  }
    

  // Custom InputTypes
  /**
   * District findUnique
   */
  export type DistrictFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which District to fetch.
     */
    where: DistrictWhereUniqueInput
  }

  /**
   * District findUniqueOrThrow
   */
  export type DistrictFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which District to fetch.
     */
    where: DistrictWhereUniqueInput
  }

  /**
   * District findFirst
   */
  export type DistrictFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which District to fetch.
     */
    where?: DistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Districts to fetch.
     */
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Districts.
     */
    cursor?: DistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Districts.
     */
    distinct?: DistrictScalarFieldEnum | DistrictScalarFieldEnum[]
  }

  /**
   * District findFirstOrThrow
   */
  export type DistrictFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which District to fetch.
     */
    where?: DistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Districts to fetch.
     */
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Districts.
     */
    cursor?: DistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Districts.
     */
    distinct?: DistrictScalarFieldEnum | DistrictScalarFieldEnum[]
  }

  /**
   * District findMany
   */
  export type DistrictFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which Districts to fetch.
     */
    where?: DistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Districts to fetch.
     */
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Districts.
     */
    cursor?: DistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Districts.
     */
    skip?: number
    distinct?: DistrictScalarFieldEnum | DistrictScalarFieldEnum[]
  }

  /**
   * District create
   */
  export type DistrictCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * The data needed to create a District.
     */
    data: XOR<DistrictCreateInput, DistrictUncheckedCreateInput>
  }

  /**
   * District createMany
   */
  export type DistrictCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Districts.
     */
    data: DistrictCreateManyInput | DistrictCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * District createManyAndReturn
   */
  export type DistrictCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Districts.
     */
    data: DistrictCreateManyInput | DistrictCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * District update
   */
  export type DistrictUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * The data needed to update a District.
     */
    data: XOR<DistrictUpdateInput, DistrictUncheckedUpdateInput>
    /**
     * Choose, which District to update.
     */
    where: DistrictWhereUniqueInput
  }

  /**
   * District updateMany
   */
  export type DistrictUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Districts.
     */
    data: XOR<DistrictUpdateManyMutationInput, DistrictUncheckedUpdateManyInput>
    /**
     * Filter which Districts to update
     */
    where?: DistrictWhereInput
  }

  /**
   * District upsert
   */
  export type DistrictUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * The filter to search for the District to update in case it exists.
     */
    where: DistrictWhereUniqueInput
    /**
     * In case the District found by the `where` argument doesn't exist, create a new District with this data.
     */
    create: XOR<DistrictCreateInput, DistrictUncheckedCreateInput>
    /**
     * In case the District was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DistrictUpdateInput, DistrictUncheckedUpdateInput>
  }

  /**
   * District delete
   */
  export type DistrictDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter which District to delete.
     */
    where: DistrictWhereUniqueInput
  }

  /**
   * District deleteMany
   */
  export type DistrictDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Districts to delete
     */
    where?: DistrictWhereInput
  }

  /**
   * District.calendarDistricts
   */
  export type District$calendarDistrictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarDistrict
     */
    select?: CalendarDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarDistrictInclude<ExtArgs> | null
    where?: CalendarDistrictWhereInput
    orderBy?: CalendarDistrictOrderByWithRelationInput | CalendarDistrictOrderByWithRelationInput[]
    cursor?: CalendarDistrictWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarDistrictScalarFieldEnum | CalendarDistrictScalarFieldEnum[]
  }

  /**
   * District without action
   */
  export type DistrictDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
  }


  /**
   * Model CalendarDistrict
   */

  export type AggregateCalendarDistrict = {
    _count: CalendarDistrictCountAggregateOutputType | null
    _min: CalendarDistrictMinAggregateOutputType | null
    _max: CalendarDistrictMaxAggregateOutputType | null
  }

  export type CalendarDistrictMinAggregateOutputType = {
    calendarId: string | null
    cityId: string | null
    districtId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalendarDistrictMaxAggregateOutputType = {
    calendarId: string | null
    cityId: string | null
    districtId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalendarDistrictCountAggregateOutputType = {
    calendarId: number
    cityId: number
    districtId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CalendarDistrictMinAggregateInputType = {
    calendarId?: true
    cityId?: true
    districtId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalendarDistrictMaxAggregateInputType = {
    calendarId?: true
    cityId?: true
    districtId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalendarDistrictCountAggregateInputType = {
    calendarId?: true
    cityId?: true
    districtId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CalendarDistrictAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarDistrict to aggregate.
     */
    where?: CalendarDistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarDistricts to fetch.
     */
    orderBy?: CalendarDistrictOrderByWithRelationInput | CalendarDistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarDistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarDistricts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarDistricts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CalendarDistricts
    **/
    _count?: true | CalendarDistrictCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarDistrictMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarDistrictMaxAggregateInputType
  }

  export type GetCalendarDistrictAggregateType<T extends CalendarDistrictAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendarDistrict]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendarDistrict[P]>
      : GetScalarType<T[P], AggregateCalendarDistrict[P]>
  }




  export type CalendarDistrictGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarDistrictWhereInput
    orderBy?: CalendarDistrictOrderByWithAggregationInput | CalendarDistrictOrderByWithAggregationInput[]
    by: CalendarDistrictScalarFieldEnum[] | CalendarDistrictScalarFieldEnum
    having?: CalendarDistrictScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarDistrictCountAggregateInputType | true
    _min?: CalendarDistrictMinAggregateInputType
    _max?: CalendarDistrictMaxAggregateInputType
  }

  export type CalendarDistrictGroupByOutputType = {
    calendarId: string
    cityId: string
    districtId: string
    createdAt: Date
    updatedAt: Date
    _count: CalendarDistrictCountAggregateOutputType | null
    _min: CalendarDistrictMinAggregateOutputType | null
    _max: CalendarDistrictMaxAggregateOutputType | null
  }

  type GetCalendarDistrictGroupByPayload<T extends CalendarDistrictGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarDistrictGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarDistrictGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarDistrictGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarDistrictGroupByOutputType[P]>
        }
      >
    >


  export type CalendarDistrictSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    calendarId?: boolean
    cityId?: boolean
    districtId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    calendar?: boolean | CalendarDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    district?: boolean | DistrictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarDistrict"]>

  export type CalendarDistrictSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    calendarId?: boolean
    cityId?: boolean
    districtId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    calendar?: boolean | CalendarDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    district?: boolean | DistrictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarDistrict"]>

  export type CalendarDistrictSelectScalar = {
    calendarId?: boolean
    cityId?: boolean
    districtId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CalendarDistrictInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calendar?: boolean | CalendarDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    district?: boolean | DistrictDefaultArgs<ExtArgs>
  }
  export type CalendarDistrictIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calendar?: boolean | CalendarDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    district?: boolean | DistrictDefaultArgs<ExtArgs>
  }

  export type $CalendarDistrictPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CalendarDistrict"
    objects: {
      calendar: Prisma.$CalendarPayload<ExtArgs>
      city: Prisma.$CityPayload<ExtArgs>
      district: Prisma.$DistrictPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      calendarId: string
      cityId: string
      districtId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["calendarDistrict"]>
    composites: {}
  }

  type CalendarDistrictGetPayload<S extends boolean | null | undefined | CalendarDistrictDefaultArgs> = $Result.GetResult<Prisma.$CalendarDistrictPayload, S>

  type CalendarDistrictCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CalendarDistrictFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CalendarDistrictCountAggregateInputType | true
    }

  export interface CalendarDistrictDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CalendarDistrict'], meta: { name: 'CalendarDistrict' } }
    /**
     * Find zero or one CalendarDistrict that matches the filter.
     * @param {CalendarDistrictFindUniqueArgs} args - Arguments to find a CalendarDistrict
     * @example
     * // Get one CalendarDistrict
     * const calendarDistrict = await prisma.calendarDistrict.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalendarDistrictFindUniqueArgs>(args: SelectSubset<T, CalendarDistrictFindUniqueArgs<ExtArgs>>): Prisma__CalendarDistrictClient<$Result.GetResult<Prisma.$CalendarDistrictPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CalendarDistrict that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CalendarDistrictFindUniqueOrThrowArgs} args - Arguments to find a CalendarDistrict
     * @example
     * // Get one CalendarDistrict
     * const calendarDistrict = await prisma.calendarDistrict.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalendarDistrictFindUniqueOrThrowArgs>(args: SelectSubset<T, CalendarDistrictFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalendarDistrictClient<$Result.GetResult<Prisma.$CalendarDistrictPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CalendarDistrict that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarDistrictFindFirstArgs} args - Arguments to find a CalendarDistrict
     * @example
     * // Get one CalendarDistrict
     * const calendarDistrict = await prisma.calendarDistrict.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalendarDistrictFindFirstArgs>(args?: SelectSubset<T, CalendarDistrictFindFirstArgs<ExtArgs>>): Prisma__CalendarDistrictClient<$Result.GetResult<Prisma.$CalendarDistrictPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CalendarDistrict that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarDistrictFindFirstOrThrowArgs} args - Arguments to find a CalendarDistrict
     * @example
     * // Get one CalendarDistrict
     * const calendarDistrict = await prisma.calendarDistrict.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalendarDistrictFindFirstOrThrowArgs>(args?: SelectSubset<T, CalendarDistrictFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalendarDistrictClient<$Result.GetResult<Prisma.$CalendarDistrictPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CalendarDistricts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarDistrictFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalendarDistricts
     * const calendarDistricts = await prisma.calendarDistrict.findMany()
     * 
     * // Get first 10 CalendarDistricts
     * const calendarDistricts = await prisma.calendarDistrict.findMany({ take: 10 })
     * 
     * // Only select the `calendarId`
     * const calendarDistrictWithCalendarIdOnly = await prisma.calendarDistrict.findMany({ select: { calendarId: true } })
     * 
     */
    findMany<T extends CalendarDistrictFindManyArgs>(args?: SelectSubset<T, CalendarDistrictFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarDistrictPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CalendarDistrict.
     * @param {CalendarDistrictCreateArgs} args - Arguments to create a CalendarDistrict.
     * @example
     * // Create one CalendarDistrict
     * const CalendarDistrict = await prisma.calendarDistrict.create({
     *   data: {
     *     // ... data to create a CalendarDistrict
     *   }
     * })
     * 
     */
    create<T extends CalendarDistrictCreateArgs>(args: SelectSubset<T, CalendarDistrictCreateArgs<ExtArgs>>): Prisma__CalendarDistrictClient<$Result.GetResult<Prisma.$CalendarDistrictPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CalendarDistricts.
     * @param {CalendarDistrictCreateManyArgs} args - Arguments to create many CalendarDistricts.
     * @example
     * // Create many CalendarDistricts
     * const calendarDistrict = await prisma.calendarDistrict.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalendarDistrictCreateManyArgs>(args?: SelectSubset<T, CalendarDistrictCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CalendarDistricts and returns the data saved in the database.
     * @param {CalendarDistrictCreateManyAndReturnArgs} args - Arguments to create many CalendarDistricts.
     * @example
     * // Create many CalendarDistricts
     * const calendarDistrict = await prisma.calendarDistrict.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CalendarDistricts and only return the `calendarId`
     * const calendarDistrictWithCalendarIdOnly = await prisma.calendarDistrict.createManyAndReturn({ 
     *   select: { calendarId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CalendarDistrictCreateManyAndReturnArgs>(args?: SelectSubset<T, CalendarDistrictCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarDistrictPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CalendarDistrict.
     * @param {CalendarDistrictDeleteArgs} args - Arguments to delete one CalendarDistrict.
     * @example
     * // Delete one CalendarDistrict
     * const CalendarDistrict = await prisma.calendarDistrict.delete({
     *   where: {
     *     // ... filter to delete one CalendarDistrict
     *   }
     * })
     * 
     */
    delete<T extends CalendarDistrictDeleteArgs>(args: SelectSubset<T, CalendarDistrictDeleteArgs<ExtArgs>>): Prisma__CalendarDistrictClient<$Result.GetResult<Prisma.$CalendarDistrictPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CalendarDistrict.
     * @param {CalendarDistrictUpdateArgs} args - Arguments to update one CalendarDistrict.
     * @example
     * // Update one CalendarDistrict
     * const calendarDistrict = await prisma.calendarDistrict.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalendarDistrictUpdateArgs>(args: SelectSubset<T, CalendarDistrictUpdateArgs<ExtArgs>>): Prisma__CalendarDistrictClient<$Result.GetResult<Prisma.$CalendarDistrictPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CalendarDistricts.
     * @param {CalendarDistrictDeleteManyArgs} args - Arguments to filter CalendarDistricts to delete.
     * @example
     * // Delete a few CalendarDistricts
     * const { count } = await prisma.calendarDistrict.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalendarDistrictDeleteManyArgs>(args?: SelectSubset<T, CalendarDistrictDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarDistricts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarDistrictUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalendarDistricts
     * const calendarDistrict = await prisma.calendarDistrict.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalendarDistrictUpdateManyArgs>(args: SelectSubset<T, CalendarDistrictUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CalendarDistrict.
     * @param {CalendarDistrictUpsertArgs} args - Arguments to update or create a CalendarDistrict.
     * @example
     * // Update or create a CalendarDistrict
     * const calendarDistrict = await prisma.calendarDistrict.upsert({
     *   create: {
     *     // ... data to create a CalendarDistrict
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalendarDistrict we want to update
     *   }
     * })
     */
    upsert<T extends CalendarDistrictUpsertArgs>(args: SelectSubset<T, CalendarDistrictUpsertArgs<ExtArgs>>): Prisma__CalendarDistrictClient<$Result.GetResult<Prisma.$CalendarDistrictPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CalendarDistricts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarDistrictCountArgs} args - Arguments to filter CalendarDistricts to count.
     * @example
     * // Count the number of CalendarDistricts
     * const count = await prisma.calendarDistrict.count({
     *   where: {
     *     // ... the filter for the CalendarDistricts we want to count
     *   }
     * })
    **/
    count<T extends CalendarDistrictCountArgs>(
      args?: Subset<T, CalendarDistrictCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarDistrictCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CalendarDistrict.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarDistrictAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarDistrictAggregateArgs>(args: Subset<T, CalendarDistrictAggregateArgs>): Prisma.PrismaPromise<GetCalendarDistrictAggregateType<T>>

    /**
     * Group by CalendarDistrict.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarDistrictGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarDistrictGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarDistrictGroupByArgs['orderBy'] }
        : { orderBy?: CalendarDistrictGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarDistrictGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarDistrictGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CalendarDistrict model
   */
  readonly fields: CalendarDistrictFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CalendarDistrict.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalendarDistrictClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    calendar<T extends CalendarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CalendarDefaultArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    district<T extends DistrictDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DistrictDefaultArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CalendarDistrict model
   */ 
  interface CalendarDistrictFieldRefs {
    readonly calendarId: FieldRef<"CalendarDistrict", 'String'>
    readonly cityId: FieldRef<"CalendarDistrict", 'String'>
    readonly districtId: FieldRef<"CalendarDistrict", 'String'>
    readonly createdAt: FieldRef<"CalendarDistrict", 'DateTime'>
    readonly updatedAt: FieldRef<"CalendarDistrict", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CalendarDistrict findUnique
   */
  export type CalendarDistrictFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarDistrict
     */
    select?: CalendarDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarDistrictInclude<ExtArgs> | null
    /**
     * Filter, which CalendarDistrict to fetch.
     */
    where: CalendarDistrictWhereUniqueInput
  }

  /**
   * CalendarDistrict findUniqueOrThrow
   */
  export type CalendarDistrictFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarDistrict
     */
    select?: CalendarDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarDistrictInclude<ExtArgs> | null
    /**
     * Filter, which CalendarDistrict to fetch.
     */
    where: CalendarDistrictWhereUniqueInput
  }

  /**
   * CalendarDistrict findFirst
   */
  export type CalendarDistrictFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarDistrict
     */
    select?: CalendarDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarDistrictInclude<ExtArgs> | null
    /**
     * Filter, which CalendarDistrict to fetch.
     */
    where?: CalendarDistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarDistricts to fetch.
     */
    orderBy?: CalendarDistrictOrderByWithRelationInput | CalendarDistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarDistricts.
     */
    cursor?: CalendarDistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarDistricts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarDistricts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarDistricts.
     */
    distinct?: CalendarDistrictScalarFieldEnum | CalendarDistrictScalarFieldEnum[]
  }

  /**
   * CalendarDistrict findFirstOrThrow
   */
  export type CalendarDistrictFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarDistrict
     */
    select?: CalendarDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarDistrictInclude<ExtArgs> | null
    /**
     * Filter, which CalendarDistrict to fetch.
     */
    where?: CalendarDistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarDistricts to fetch.
     */
    orderBy?: CalendarDistrictOrderByWithRelationInput | CalendarDistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarDistricts.
     */
    cursor?: CalendarDistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarDistricts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarDistricts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarDistricts.
     */
    distinct?: CalendarDistrictScalarFieldEnum | CalendarDistrictScalarFieldEnum[]
  }

  /**
   * CalendarDistrict findMany
   */
  export type CalendarDistrictFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarDistrict
     */
    select?: CalendarDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarDistrictInclude<ExtArgs> | null
    /**
     * Filter, which CalendarDistricts to fetch.
     */
    where?: CalendarDistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarDistricts to fetch.
     */
    orderBy?: CalendarDistrictOrderByWithRelationInput | CalendarDistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CalendarDistricts.
     */
    cursor?: CalendarDistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarDistricts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarDistricts.
     */
    skip?: number
    distinct?: CalendarDistrictScalarFieldEnum | CalendarDistrictScalarFieldEnum[]
  }

  /**
   * CalendarDistrict create
   */
  export type CalendarDistrictCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarDistrict
     */
    select?: CalendarDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarDistrictInclude<ExtArgs> | null
    /**
     * The data needed to create a CalendarDistrict.
     */
    data: XOR<CalendarDistrictCreateInput, CalendarDistrictUncheckedCreateInput>
  }

  /**
   * CalendarDistrict createMany
   */
  export type CalendarDistrictCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CalendarDistricts.
     */
    data: CalendarDistrictCreateManyInput | CalendarDistrictCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalendarDistrict createManyAndReturn
   */
  export type CalendarDistrictCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarDistrict
     */
    select?: CalendarDistrictSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CalendarDistricts.
     */
    data: CalendarDistrictCreateManyInput | CalendarDistrictCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarDistrictIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CalendarDistrict update
   */
  export type CalendarDistrictUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarDistrict
     */
    select?: CalendarDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarDistrictInclude<ExtArgs> | null
    /**
     * The data needed to update a CalendarDistrict.
     */
    data: XOR<CalendarDistrictUpdateInput, CalendarDistrictUncheckedUpdateInput>
    /**
     * Choose, which CalendarDistrict to update.
     */
    where: CalendarDistrictWhereUniqueInput
  }

  /**
   * CalendarDistrict updateMany
   */
  export type CalendarDistrictUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CalendarDistricts.
     */
    data: XOR<CalendarDistrictUpdateManyMutationInput, CalendarDistrictUncheckedUpdateManyInput>
    /**
     * Filter which CalendarDistricts to update
     */
    where?: CalendarDistrictWhereInput
  }

  /**
   * CalendarDistrict upsert
   */
  export type CalendarDistrictUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarDistrict
     */
    select?: CalendarDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarDistrictInclude<ExtArgs> | null
    /**
     * The filter to search for the CalendarDistrict to update in case it exists.
     */
    where: CalendarDistrictWhereUniqueInput
    /**
     * In case the CalendarDistrict found by the `where` argument doesn't exist, create a new CalendarDistrict with this data.
     */
    create: XOR<CalendarDistrictCreateInput, CalendarDistrictUncheckedCreateInput>
    /**
     * In case the CalendarDistrict was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarDistrictUpdateInput, CalendarDistrictUncheckedUpdateInput>
  }

  /**
   * CalendarDistrict delete
   */
  export type CalendarDistrictDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarDistrict
     */
    select?: CalendarDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarDistrictInclude<ExtArgs> | null
    /**
     * Filter which CalendarDistrict to delete.
     */
    where: CalendarDistrictWhereUniqueInput
  }

  /**
   * CalendarDistrict deleteMany
   */
  export type CalendarDistrictDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarDistricts to delete
     */
    where?: CalendarDistrictWhereInput
  }

  /**
   * CalendarDistrict without action
   */
  export type CalendarDistrictDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarDistrict
     */
    select?: CalendarDistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarDistrictInclude<ExtArgs> | null
  }


  /**
   * Model Stage
   */

  export type AggregateStage = {
    _count: StageCountAggregateOutputType | null
    _min: StageMinAggregateOutputType | null
    _max: StageMaxAggregateOutputType | null
  }

  export type StageMinAggregateOutputType = {
    id: string | null
    calendarId: string | null
    name: string | null
    description: string | null
    startMonth: string | null
    startDecade: $Enums.Decade | null
    endMonth: string | null
    endDecade: $Enums.Decade | null
    color: string | null
    status: $Enums.StageStatus | null
    coverUrl: string | null
    coverName: string | null
    coverThumbnail: string | null
    coverSource: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StageMaxAggregateOutputType = {
    id: string | null
    calendarId: string | null
    name: string | null
    description: string | null
    startMonth: string | null
    startDecade: $Enums.Decade | null
    endMonth: string | null
    endDecade: $Enums.Decade | null
    color: string | null
    status: $Enums.StageStatus | null
    coverUrl: string | null
    coverName: string | null
    coverThumbnail: string | null
    coverSource: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StageCountAggregateOutputType = {
    id: number
    calendarId: number
    name: number
    description: number
    startMonth: number
    startDecade: number
    endMonth: number
    endDecade: number
    color: number
    status: number
    coverUrl: number
    coverName: number
    coverThumbnail: number
    coverSource: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StageMinAggregateInputType = {
    id?: true
    calendarId?: true
    name?: true
    description?: true
    startMonth?: true
    startDecade?: true
    endMonth?: true
    endDecade?: true
    color?: true
    status?: true
    coverUrl?: true
    coverName?: true
    coverThumbnail?: true
    coverSource?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StageMaxAggregateInputType = {
    id?: true
    calendarId?: true
    name?: true
    description?: true
    startMonth?: true
    startDecade?: true
    endMonth?: true
    endDecade?: true
    color?: true
    status?: true
    coverUrl?: true
    coverName?: true
    coverThumbnail?: true
    coverSource?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StageCountAggregateInputType = {
    id?: true
    calendarId?: true
    name?: true
    description?: true
    startMonth?: true
    startDecade?: true
    endMonth?: true
    endDecade?: true
    color?: true
    status?: true
    coverUrl?: true
    coverName?: true
    coverThumbnail?: true
    coverSource?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stage to aggregate.
     */
    where?: StageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stages to fetch.
     */
    orderBy?: StageOrderByWithRelationInput | StageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stages
    **/
    _count?: true | StageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StageMaxAggregateInputType
  }

  export type GetStageAggregateType<T extends StageAggregateArgs> = {
        [P in keyof T & keyof AggregateStage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStage[P]>
      : GetScalarType<T[P], AggregateStage[P]>
  }




  export type StageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StageWhereInput
    orderBy?: StageOrderByWithAggregationInput | StageOrderByWithAggregationInput[]
    by: StageScalarFieldEnum[] | StageScalarFieldEnum
    having?: StageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StageCountAggregateInputType | true
    _min?: StageMinAggregateInputType
    _max?: StageMaxAggregateInputType
  }

  export type StageGroupByOutputType = {
    id: string
    calendarId: string
    name: string
    description: string | null
    startMonth: string | null
    startDecade: $Enums.Decade | null
    endMonth: string | null
    endDecade: $Enums.Decade | null
    color: string
    status: $Enums.StageStatus
    coverUrl: string | null
    coverName: string | null
    coverThumbnail: string | null
    coverSource: string | null
    createdAt: Date
    updatedAt: Date
    _count: StageCountAggregateOutputType | null
    _min: StageMinAggregateOutputType | null
    _max: StageMaxAggregateOutputType | null
  }

  type GetStageGroupByPayload<T extends StageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StageGroupByOutputType[P]>
            : GetScalarType<T[P], StageGroupByOutputType[P]>
        }
      >
    >


  export type StageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    calendarId?: boolean
    name?: boolean
    description?: boolean
    startMonth?: boolean
    startDecade?: boolean
    endMonth?: boolean
    endDecade?: boolean
    color?: boolean
    status?: boolean
    coverUrl?: boolean
    coverName?: boolean
    coverThumbnail?: boolean
    coverSource?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    calendar?: boolean | CalendarDefaultArgs<ExtArgs>
    thresholds?: boolean | Stage$thresholdsArgs<ExtArgs>
    albums?: boolean | Stage$albumsArgs<ExtArgs>
    _count?: boolean | StageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stage"]>

  export type StageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    calendarId?: boolean
    name?: boolean
    description?: boolean
    startMonth?: boolean
    startDecade?: boolean
    endMonth?: boolean
    endDecade?: boolean
    color?: boolean
    status?: boolean
    coverUrl?: boolean
    coverName?: boolean
    coverThumbnail?: boolean
    coverSource?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    calendar?: boolean | CalendarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stage"]>

  export type StageSelectScalar = {
    id?: boolean
    calendarId?: boolean
    name?: boolean
    description?: boolean
    startMonth?: boolean
    startDecade?: boolean
    endMonth?: boolean
    endDecade?: boolean
    color?: boolean
    status?: boolean
    coverUrl?: boolean
    coverName?: boolean
    coverThumbnail?: boolean
    coverSource?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calendar?: boolean | CalendarDefaultArgs<ExtArgs>
    thresholds?: boolean | Stage$thresholdsArgs<ExtArgs>
    albums?: boolean | Stage$albumsArgs<ExtArgs>
    _count?: boolean | StageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calendar?: boolean | CalendarDefaultArgs<ExtArgs>
  }

  export type $StagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stage"
    objects: {
      calendar: Prisma.$CalendarPayload<ExtArgs>
      thresholds: Prisma.$StageThresholdPayload<ExtArgs>[]
      albums: Prisma.$StageAlbumPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      calendarId: string
      name: string
      description: string | null
      startMonth: string | null
      startDecade: $Enums.Decade | null
      endMonth: string | null
      endDecade: $Enums.Decade | null
      color: string
      status: $Enums.StageStatus
      coverUrl: string | null
      coverName: string | null
      coverThumbnail: string | null
      coverSource: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stage"]>
    composites: {}
  }

  type StageGetPayload<S extends boolean | null | undefined | StageDefaultArgs> = $Result.GetResult<Prisma.$StagePayload, S>

  type StageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StageCountAggregateInputType | true
    }

  export interface StageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stage'], meta: { name: 'Stage' } }
    /**
     * Find zero or one Stage that matches the filter.
     * @param {StageFindUniqueArgs} args - Arguments to find a Stage
     * @example
     * // Get one Stage
     * const stage = await prisma.stage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StageFindUniqueArgs>(args: SelectSubset<T, StageFindUniqueArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Stage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StageFindUniqueOrThrowArgs} args - Arguments to find a Stage
     * @example
     * // Get one Stage
     * const stage = await prisma.stage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StageFindUniqueOrThrowArgs>(args: SelectSubset<T, StageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Stage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageFindFirstArgs} args - Arguments to find a Stage
     * @example
     * // Get one Stage
     * const stage = await prisma.stage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StageFindFirstArgs>(args?: SelectSubset<T, StageFindFirstArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Stage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageFindFirstOrThrowArgs} args - Arguments to find a Stage
     * @example
     * // Get one Stage
     * const stage = await prisma.stage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StageFindFirstOrThrowArgs>(args?: SelectSubset<T, StageFindFirstOrThrowArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Stages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stages
     * const stages = await prisma.stage.findMany()
     * 
     * // Get first 10 Stages
     * const stages = await prisma.stage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stageWithIdOnly = await prisma.stage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StageFindManyArgs>(args?: SelectSubset<T, StageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Stage.
     * @param {StageCreateArgs} args - Arguments to create a Stage.
     * @example
     * // Create one Stage
     * const Stage = await prisma.stage.create({
     *   data: {
     *     // ... data to create a Stage
     *   }
     * })
     * 
     */
    create<T extends StageCreateArgs>(args: SelectSubset<T, StageCreateArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Stages.
     * @param {StageCreateManyArgs} args - Arguments to create many Stages.
     * @example
     * // Create many Stages
     * const stage = await prisma.stage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StageCreateManyArgs>(args?: SelectSubset<T, StageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stages and returns the data saved in the database.
     * @param {StageCreateManyAndReturnArgs} args - Arguments to create many Stages.
     * @example
     * // Create many Stages
     * const stage = await prisma.stage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stages and only return the `id`
     * const stageWithIdOnly = await prisma.stage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StageCreateManyAndReturnArgs>(args?: SelectSubset<T, StageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Stage.
     * @param {StageDeleteArgs} args - Arguments to delete one Stage.
     * @example
     * // Delete one Stage
     * const Stage = await prisma.stage.delete({
     *   where: {
     *     // ... filter to delete one Stage
     *   }
     * })
     * 
     */
    delete<T extends StageDeleteArgs>(args: SelectSubset<T, StageDeleteArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Stage.
     * @param {StageUpdateArgs} args - Arguments to update one Stage.
     * @example
     * // Update one Stage
     * const stage = await prisma.stage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StageUpdateArgs>(args: SelectSubset<T, StageUpdateArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Stages.
     * @param {StageDeleteManyArgs} args - Arguments to filter Stages to delete.
     * @example
     * // Delete a few Stages
     * const { count } = await prisma.stage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StageDeleteManyArgs>(args?: SelectSubset<T, StageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stages
     * const stage = await prisma.stage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StageUpdateManyArgs>(args: SelectSubset<T, StageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Stage.
     * @param {StageUpsertArgs} args - Arguments to update or create a Stage.
     * @example
     * // Update or create a Stage
     * const stage = await prisma.stage.upsert({
     *   create: {
     *     // ... data to create a Stage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stage we want to update
     *   }
     * })
     */
    upsert<T extends StageUpsertArgs>(args: SelectSubset<T, StageUpsertArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Stages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageCountArgs} args - Arguments to filter Stages to count.
     * @example
     * // Count the number of Stages
     * const count = await prisma.stage.count({
     *   where: {
     *     // ... the filter for the Stages we want to count
     *   }
     * })
    **/
    count<T extends StageCountArgs>(
      args?: Subset<T, StageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StageAggregateArgs>(args: Subset<T, StageAggregateArgs>): Prisma.PrismaPromise<GetStageAggregateType<T>>

    /**
     * Group by Stage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StageGroupByArgs['orderBy'] }
        : { orderBy?: StageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stage model
   */
  readonly fields: StageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    calendar<T extends CalendarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CalendarDefaultArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    thresholds<T extends Stage$thresholdsArgs<ExtArgs> = {}>(args?: Subset<T, Stage$thresholdsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StageThresholdPayload<ExtArgs>, T, "findMany"> | Null>
    albums<T extends Stage$albumsArgs<ExtArgs> = {}>(args?: Subset<T, Stage$albumsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StageAlbumPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stage model
   */ 
  interface StageFieldRefs {
    readonly id: FieldRef<"Stage", 'String'>
    readonly calendarId: FieldRef<"Stage", 'String'>
    readonly name: FieldRef<"Stage", 'String'>
    readonly description: FieldRef<"Stage", 'String'>
    readonly startMonth: FieldRef<"Stage", 'String'>
    readonly startDecade: FieldRef<"Stage", 'Decade'>
    readonly endMonth: FieldRef<"Stage", 'String'>
    readonly endDecade: FieldRef<"Stage", 'Decade'>
    readonly color: FieldRef<"Stage", 'String'>
    readonly status: FieldRef<"Stage", 'StageStatus'>
    readonly coverUrl: FieldRef<"Stage", 'String'>
    readonly coverName: FieldRef<"Stage", 'String'>
    readonly coverThumbnail: FieldRef<"Stage", 'String'>
    readonly coverSource: FieldRef<"Stage", 'String'>
    readonly createdAt: FieldRef<"Stage", 'DateTime'>
    readonly updatedAt: FieldRef<"Stage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Stage findUnique
   */
  export type StageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * Filter, which Stage to fetch.
     */
    where: StageWhereUniqueInput
  }

  /**
   * Stage findUniqueOrThrow
   */
  export type StageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * Filter, which Stage to fetch.
     */
    where: StageWhereUniqueInput
  }

  /**
   * Stage findFirst
   */
  export type StageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * Filter, which Stage to fetch.
     */
    where?: StageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stages to fetch.
     */
    orderBy?: StageOrderByWithRelationInput | StageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stages.
     */
    cursor?: StageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stages.
     */
    distinct?: StageScalarFieldEnum | StageScalarFieldEnum[]
  }

  /**
   * Stage findFirstOrThrow
   */
  export type StageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * Filter, which Stage to fetch.
     */
    where?: StageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stages to fetch.
     */
    orderBy?: StageOrderByWithRelationInput | StageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stages.
     */
    cursor?: StageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stages.
     */
    distinct?: StageScalarFieldEnum | StageScalarFieldEnum[]
  }

  /**
   * Stage findMany
   */
  export type StageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * Filter, which Stages to fetch.
     */
    where?: StageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stages to fetch.
     */
    orderBy?: StageOrderByWithRelationInput | StageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stages.
     */
    cursor?: StageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stages.
     */
    skip?: number
    distinct?: StageScalarFieldEnum | StageScalarFieldEnum[]
  }

  /**
   * Stage create
   */
  export type StageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * The data needed to create a Stage.
     */
    data: XOR<StageCreateInput, StageUncheckedCreateInput>
  }

  /**
   * Stage createMany
   */
  export type StageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stages.
     */
    data: StageCreateManyInput | StageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stage createManyAndReturn
   */
  export type StageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Stages.
     */
    data: StageCreateManyInput | StageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stage update
   */
  export type StageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * The data needed to update a Stage.
     */
    data: XOR<StageUpdateInput, StageUncheckedUpdateInput>
    /**
     * Choose, which Stage to update.
     */
    where: StageWhereUniqueInput
  }

  /**
   * Stage updateMany
   */
  export type StageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stages.
     */
    data: XOR<StageUpdateManyMutationInput, StageUncheckedUpdateManyInput>
    /**
     * Filter which Stages to update
     */
    where?: StageWhereInput
  }

  /**
   * Stage upsert
   */
  export type StageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * The filter to search for the Stage to update in case it exists.
     */
    where: StageWhereUniqueInput
    /**
     * In case the Stage found by the `where` argument doesn't exist, create a new Stage with this data.
     */
    create: XOR<StageCreateInput, StageUncheckedCreateInput>
    /**
     * In case the Stage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StageUpdateInput, StageUncheckedUpdateInput>
  }

  /**
   * Stage delete
   */
  export type StageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * Filter which Stage to delete.
     */
    where: StageWhereUniqueInput
  }

  /**
   * Stage deleteMany
   */
  export type StageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stages to delete
     */
    where?: StageWhereInput
  }

  /**
   * Stage.thresholds
   */
  export type Stage$thresholdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageThreshold
     */
    select?: StageThresholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageThresholdInclude<ExtArgs> | null
    where?: StageThresholdWhereInput
    orderBy?: StageThresholdOrderByWithRelationInput | StageThresholdOrderByWithRelationInput[]
    cursor?: StageThresholdWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StageThresholdScalarFieldEnum | StageThresholdScalarFieldEnum[]
  }

  /**
   * Stage.albums
   */
  export type Stage$albumsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageAlbum
     */
    select?: StageAlbumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageAlbumInclude<ExtArgs> | null
    where?: StageAlbumWhereInput
    orderBy?: StageAlbumOrderByWithRelationInput | StageAlbumOrderByWithRelationInput[]
    cursor?: StageAlbumWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StageAlbumScalarFieldEnum | StageAlbumScalarFieldEnum[]
  }

  /**
   * Stage without action
   */
  export type StageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
  }


  /**
   * Model StageAlbum
   */

  export type AggregateStageAlbum = {
    _count: StageAlbumCountAggregateOutputType | null
    _min: StageAlbumMinAggregateOutputType | null
    _max: StageAlbumMaxAggregateOutputType | null
  }

  export type StageAlbumMinAggregateOutputType = {
    id: string | null
    stageId: string | null
    url: string | null
    name: string | null
    thumbnail: string | null
    source: string | null
    sortOrder: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StageAlbumMaxAggregateOutputType = {
    id: string | null
    stageId: string | null
    url: string | null
    name: string | null
    thumbnail: string | null
    source: string | null
    sortOrder: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StageAlbumCountAggregateOutputType = {
    id: number
    stageId: number
    url: number
    name: number
    thumbnail: number
    source: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StageAlbumMinAggregateInputType = {
    id?: true
    stageId?: true
    url?: true
    name?: true
    thumbnail?: true
    source?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StageAlbumMaxAggregateInputType = {
    id?: true
    stageId?: true
    url?: true
    name?: true
    thumbnail?: true
    source?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StageAlbumCountAggregateInputType = {
    id?: true
    stageId?: true
    url?: true
    name?: true
    thumbnail?: true
    source?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StageAlbumAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StageAlbum to aggregate.
     */
    where?: StageAlbumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StageAlbums to fetch.
     */
    orderBy?: StageAlbumOrderByWithRelationInput | StageAlbumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StageAlbumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StageAlbums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StageAlbums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StageAlbums
    **/
    _count?: true | StageAlbumCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StageAlbumMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StageAlbumMaxAggregateInputType
  }

  export type GetStageAlbumAggregateType<T extends StageAlbumAggregateArgs> = {
        [P in keyof T & keyof AggregateStageAlbum]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStageAlbum[P]>
      : GetScalarType<T[P], AggregateStageAlbum[P]>
  }




  export type StageAlbumGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StageAlbumWhereInput
    orderBy?: StageAlbumOrderByWithAggregationInput | StageAlbumOrderByWithAggregationInput[]
    by: StageAlbumScalarFieldEnum[] | StageAlbumScalarFieldEnum
    having?: StageAlbumScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StageAlbumCountAggregateInputType | true
    _min?: StageAlbumMinAggregateInputType
    _max?: StageAlbumMaxAggregateInputType
  }

  export type StageAlbumGroupByOutputType = {
    id: string
    stageId: string
    url: string
    name: string | null
    thumbnail: string | null
    source: string | null
    sortOrder: string
    createdAt: Date
    updatedAt: Date
    _count: StageAlbumCountAggregateOutputType | null
    _min: StageAlbumMinAggregateOutputType | null
    _max: StageAlbumMaxAggregateOutputType | null
  }

  type GetStageAlbumGroupByPayload<T extends StageAlbumGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StageAlbumGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StageAlbumGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StageAlbumGroupByOutputType[P]>
            : GetScalarType<T[P], StageAlbumGroupByOutputType[P]>
        }
      >
    >


  export type StageAlbumSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stageId?: boolean
    url?: boolean
    name?: boolean
    thumbnail?: boolean
    source?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stage?: boolean | StageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stageAlbum"]>

  export type StageAlbumSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stageId?: boolean
    url?: boolean
    name?: boolean
    thumbnail?: boolean
    source?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stage?: boolean | StageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stageAlbum"]>

  export type StageAlbumSelectScalar = {
    id?: boolean
    stageId?: boolean
    url?: boolean
    name?: boolean
    thumbnail?: boolean
    source?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StageAlbumInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stage?: boolean | StageDefaultArgs<ExtArgs>
  }
  export type StageAlbumIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stage?: boolean | StageDefaultArgs<ExtArgs>
  }

  export type $StageAlbumPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StageAlbum"
    objects: {
      stage: Prisma.$StagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stageId: string
      url: string
      name: string | null
      thumbnail: string | null
      source: string | null
      sortOrder: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stageAlbum"]>
    composites: {}
  }

  type StageAlbumGetPayload<S extends boolean | null | undefined | StageAlbumDefaultArgs> = $Result.GetResult<Prisma.$StageAlbumPayload, S>

  type StageAlbumCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StageAlbumFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StageAlbumCountAggregateInputType | true
    }

  export interface StageAlbumDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StageAlbum'], meta: { name: 'StageAlbum' } }
    /**
     * Find zero or one StageAlbum that matches the filter.
     * @param {StageAlbumFindUniqueArgs} args - Arguments to find a StageAlbum
     * @example
     * // Get one StageAlbum
     * const stageAlbum = await prisma.stageAlbum.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StageAlbumFindUniqueArgs>(args: SelectSubset<T, StageAlbumFindUniqueArgs<ExtArgs>>): Prisma__StageAlbumClient<$Result.GetResult<Prisma.$StageAlbumPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StageAlbum that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StageAlbumFindUniqueOrThrowArgs} args - Arguments to find a StageAlbum
     * @example
     * // Get one StageAlbum
     * const stageAlbum = await prisma.stageAlbum.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StageAlbumFindUniqueOrThrowArgs>(args: SelectSubset<T, StageAlbumFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StageAlbumClient<$Result.GetResult<Prisma.$StageAlbumPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StageAlbum that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageAlbumFindFirstArgs} args - Arguments to find a StageAlbum
     * @example
     * // Get one StageAlbum
     * const stageAlbum = await prisma.stageAlbum.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StageAlbumFindFirstArgs>(args?: SelectSubset<T, StageAlbumFindFirstArgs<ExtArgs>>): Prisma__StageAlbumClient<$Result.GetResult<Prisma.$StageAlbumPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StageAlbum that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageAlbumFindFirstOrThrowArgs} args - Arguments to find a StageAlbum
     * @example
     * // Get one StageAlbum
     * const stageAlbum = await prisma.stageAlbum.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StageAlbumFindFirstOrThrowArgs>(args?: SelectSubset<T, StageAlbumFindFirstOrThrowArgs<ExtArgs>>): Prisma__StageAlbumClient<$Result.GetResult<Prisma.$StageAlbumPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StageAlbums that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageAlbumFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StageAlbums
     * const stageAlbums = await prisma.stageAlbum.findMany()
     * 
     * // Get first 10 StageAlbums
     * const stageAlbums = await prisma.stageAlbum.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stageAlbumWithIdOnly = await prisma.stageAlbum.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StageAlbumFindManyArgs>(args?: SelectSubset<T, StageAlbumFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StageAlbumPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StageAlbum.
     * @param {StageAlbumCreateArgs} args - Arguments to create a StageAlbum.
     * @example
     * // Create one StageAlbum
     * const StageAlbum = await prisma.stageAlbum.create({
     *   data: {
     *     // ... data to create a StageAlbum
     *   }
     * })
     * 
     */
    create<T extends StageAlbumCreateArgs>(args: SelectSubset<T, StageAlbumCreateArgs<ExtArgs>>): Prisma__StageAlbumClient<$Result.GetResult<Prisma.$StageAlbumPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StageAlbums.
     * @param {StageAlbumCreateManyArgs} args - Arguments to create many StageAlbums.
     * @example
     * // Create many StageAlbums
     * const stageAlbum = await prisma.stageAlbum.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StageAlbumCreateManyArgs>(args?: SelectSubset<T, StageAlbumCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StageAlbums and returns the data saved in the database.
     * @param {StageAlbumCreateManyAndReturnArgs} args - Arguments to create many StageAlbums.
     * @example
     * // Create many StageAlbums
     * const stageAlbum = await prisma.stageAlbum.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StageAlbums and only return the `id`
     * const stageAlbumWithIdOnly = await prisma.stageAlbum.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StageAlbumCreateManyAndReturnArgs>(args?: SelectSubset<T, StageAlbumCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StageAlbumPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StageAlbum.
     * @param {StageAlbumDeleteArgs} args - Arguments to delete one StageAlbum.
     * @example
     * // Delete one StageAlbum
     * const StageAlbum = await prisma.stageAlbum.delete({
     *   where: {
     *     // ... filter to delete one StageAlbum
     *   }
     * })
     * 
     */
    delete<T extends StageAlbumDeleteArgs>(args: SelectSubset<T, StageAlbumDeleteArgs<ExtArgs>>): Prisma__StageAlbumClient<$Result.GetResult<Prisma.$StageAlbumPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StageAlbum.
     * @param {StageAlbumUpdateArgs} args - Arguments to update one StageAlbum.
     * @example
     * // Update one StageAlbum
     * const stageAlbum = await prisma.stageAlbum.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StageAlbumUpdateArgs>(args: SelectSubset<T, StageAlbumUpdateArgs<ExtArgs>>): Prisma__StageAlbumClient<$Result.GetResult<Prisma.$StageAlbumPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StageAlbums.
     * @param {StageAlbumDeleteManyArgs} args - Arguments to filter StageAlbums to delete.
     * @example
     * // Delete a few StageAlbums
     * const { count } = await prisma.stageAlbum.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StageAlbumDeleteManyArgs>(args?: SelectSubset<T, StageAlbumDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StageAlbums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageAlbumUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StageAlbums
     * const stageAlbum = await prisma.stageAlbum.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StageAlbumUpdateManyArgs>(args: SelectSubset<T, StageAlbumUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StageAlbum.
     * @param {StageAlbumUpsertArgs} args - Arguments to update or create a StageAlbum.
     * @example
     * // Update or create a StageAlbum
     * const stageAlbum = await prisma.stageAlbum.upsert({
     *   create: {
     *     // ... data to create a StageAlbum
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StageAlbum we want to update
     *   }
     * })
     */
    upsert<T extends StageAlbumUpsertArgs>(args: SelectSubset<T, StageAlbumUpsertArgs<ExtArgs>>): Prisma__StageAlbumClient<$Result.GetResult<Prisma.$StageAlbumPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StageAlbums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageAlbumCountArgs} args - Arguments to filter StageAlbums to count.
     * @example
     * // Count the number of StageAlbums
     * const count = await prisma.stageAlbum.count({
     *   where: {
     *     // ... the filter for the StageAlbums we want to count
     *   }
     * })
    **/
    count<T extends StageAlbumCountArgs>(
      args?: Subset<T, StageAlbumCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StageAlbumCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StageAlbum.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageAlbumAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StageAlbumAggregateArgs>(args: Subset<T, StageAlbumAggregateArgs>): Prisma.PrismaPromise<GetStageAlbumAggregateType<T>>

    /**
     * Group by StageAlbum.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageAlbumGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StageAlbumGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StageAlbumGroupByArgs['orderBy'] }
        : { orderBy?: StageAlbumGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StageAlbumGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStageAlbumGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StageAlbum model
   */
  readonly fields: StageAlbumFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StageAlbum.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StageAlbumClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stage<T extends StageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StageDefaultArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StageAlbum model
   */ 
  interface StageAlbumFieldRefs {
    readonly id: FieldRef<"StageAlbum", 'String'>
    readonly stageId: FieldRef<"StageAlbum", 'String'>
    readonly url: FieldRef<"StageAlbum", 'String'>
    readonly name: FieldRef<"StageAlbum", 'String'>
    readonly thumbnail: FieldRef<"StageAlbum", 'String'>
    readonly source: FieldRef<"StageAlbum", 'String'>
    readonly sortOrder: FieldRef<"StageAlbum", 'String'>
    readonly createdAt: FieldRef<"StageAlbum", 'DateTime'>
    readonly updatedAt: FieldRef<"StageAlbum", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StageAlbum findUnique
   */
  export type StageAlbumFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageAlbum
     */
    select?: StageAlbumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageAlbumInclude<ExtArgs> | null
    /**
     * Filter, which StageAlbum to fetch.
     */
    where: StageAlbumWhereUniqueInput
  }

  /**
   * StageAlbum findUniqueOrThrow
   */
  export type StageAlbumFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageAlbum
     */
    select?: StageAlbumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageAlbumInclude<ExtArgs> | null
    /**
     * Filter, which StageAlbum to fetch.
     */
    where: StageAlbumWhereUniqueInput
  }

  /**
   * StageAlbum findFirst
   */
  export type StageAlbumFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageAlbum
     */
    select?: StageAlbumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageAlbumInclude<ExtArgs> | null
    /**
     * Filter, which StageAlbum to fetch.
     */
    where?: StageAlbumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StageAlbums to fetch.
     */
    orderBy?: StageAlbumOrderByWithRelationInput | StageAlbumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StageAlbums.
     */
    cursor?: StageAlbumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StageAlbums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StageAlbums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StageAlbums.
     */
    distinct?: StageAlbumScalarFieldEnum | StageAlbumScalarFieldEnum[]
  }

  /**
   * StageAlbum findFirstOrThrow
   */
  export type StageAlbumFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageAlbum
     */
    select?: StageAlbumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageAlbumInclude<ExtArgs> | null
    /**
     * Filter, which StageAlbum to fetch.
     */
    where?: StageAlbumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StageAlbums to fetch.
     */
    orderBy?: StageAlbumOrderByWithRelationInput | StageAlbumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StageAlbums.
     */
    cursor?: StageAlbumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StageAlbums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StageAlbums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StageAlbums.
     */
    distinct?: StageAlbumScalarFieldEnum | StageAlbumScalarFieldEnum[]
  }

  /**
   * StageAlbum findMany
   */
  export type StageAlbumFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageAlbum
     */
    select?: StageAlbumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageAlbumInclude<ExtArgs> | null
    /**
     * Filter, which StageAlbums to fetch.
     */
    where?: StageAlbumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StageAlbums to fetch.
     */
    orderBy?: StageAlbumOrderByWithRelationInput | StageAlbumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StageAlbums.
     */
    cursor?: StageAlbumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StageAlbums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StageAlbums.
     */
    skip?: number
    distinct?: StageAlbumScalarFieldEnum | StageAlbumScalarFieldEnum[]
  }

  /**
   * StageAlbum create
   */
  export type StageAlbumCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageAlbum
     */
    select?: StageAlbumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageAlbumInclude<ExtArgs> | null
    /**
     * The data needed to create a StageAlbum.
     */
    data: XOR<StageAlbumCreateInput, StageAlbumUncheckedCreateInput>
  }

  /**
   * StageAlbum createMany
   */
  export type StageAlbumCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StageAlbums.
     */
    data: StageAlbumCreateManyInput | StageAlbumCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StageAlbum createManyAndReturn
   */
  export type StageAlbumCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageAlbum
     */
    select?: StageAlbumSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StageAlbums.
     */
    data: StageAlbumCreateManyInput | StageAlbumCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageAlbumIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StageAlbum update
   */
  export type StageAlbumUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageAlbum
     */
    select?: StageAlbumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageAlbumInclude<ExtArgs> | null
    /**
     * The data needed to update a StageAlbum.
     */
    data: XOR<StageAlbumUpdateInput, StageAlbumUncheckedUpdateInput>
    /**
     * Choose, which StageAlbum to update.
     */
    where: StageAlbumWhereUniqueInput
  }

  /**
   * StageAlbum updateMany
   */
  export type StageAlbumUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StageAlbums.
     */
    data: XOR<StageAlbumUpdateManyMutationInput, StageAlbumUncheckedUpdateManyInput>
    /**
     * Filter which StageAlbums to update
     */
    where?: StageAlbumWhereInput
  }

  /**
   * StageAlbum upsert
   */
  export type StageAlbumUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageAlbum
     */
    select?: StageAlbumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageAlbumInclude<ExtArgs> | null
    /**
     * The filter to search for the StageAlbum to update in case it exists.
     */
    where: StageAlbumWhereUniqueInput
    /**
     * In case the StageAlbum found by the `where` argument doesn't exist, create a new StageAlbum with this data.
     */
    create: XOR<StageAlbumCreateInput, StageAlbumUncheckedCreateInput>
    /**
     * In case the StageAlbum was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StageAlbumUpdateInput, StageAlbumUncheckedUpdateInput>
  }

  /**
   * StageAlbum delete
   */
  export type StageAlbumDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageAlbum
     */
    select?: StageAlbumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageAlbumInclude<ExtArgs> | null
    /**
     * Filter which StageAlbum to delete.
     */
    where: StageAlbumWhereUniqueInput
  }

  /**
   * StageAlbum deleteMany
   */
  export type StageAlbumDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StageAlbums to delete
     */
    where?: StageAlbumWhereInput
  }

  /**
   * StageAlbum without action
   */
  export type StageAlbumDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageAlbum
     */
    select?: StageAlbumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageAlbumInclude<ExtArgs> | null
  }


  /**
   * Model StageThreshold
   */

  export type AggregateStageThreshold = {
    _count: StageThresholdCountAggregateOutputType | null
    _avg: StageThresholdAvgAggregateOutputType | null
    _sum: StageThresholdSumAggregateOutputType | null
    _min: StageThresholdMinAggregateOutputType | null
    _max: StageThresholdMaxAggregateOutputType | null
  }

  export type StageThresholdAvgAggregateOutputType = {
    value: number | null
  }

  export type StageThresholdSumAggregateOutputType = {
    value: number | null
  }

  export type StageThresholdMinAggregateOutputType = {
    id: string | null
    stageId: string | null
    indicatorId: string | null
    operator: $Enums.ThresholdOperator | null
    value: number | null
    durationDays: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StageThresholdMaxAggregateOutputType = {
    id: string | null
    stageId: string | null
    indicatorId: string | null
    operator: $Enums.ThresholdOperator | null
    value: number | null
    durationDays: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StageThresholdCountAggregateOutputType = {
    id: number
    stageId: number
    indicatorId: number
    operator: number
    value: number
    durationDays: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StageThresholdAvgAggregateInputType = {
    value?: true
  }

  export type StageThresholdSumAggregateInputType = {
    value?: true
  }

  export type StageThresholdMinAggregateInputType = {
    id?: true
    stageId?: true
    indicatorId?: true
    operator?: true
    value?: true
    durationDays?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StageThresholdMaxAggregateInputType = {
    id?: true
    stageId?: true
    indicatorId?: true
    operator?: true
    value?: true
    durationDays?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StageThresholdCountAggregateInputType = {
    id?: true
    stageId?: true
    indicatorId?: true
    operator?: true
    value?: true
    durationDays?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StageThresholdAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StageThreshold to aggregate.
     */
    where?: StageThresholdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StageThresholds to fetch.
     */
    orderBy?: StageThresholdOrderByWithRelationInput | StageThresholdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StageThresholdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StageThresholds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StageThresholds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StageThresholds
    **/
    _count?: true | StageThresholdCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StageThresholdAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StageThresholdSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StageThresholdMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StageThresholdMaxAggregateInputType
  }

  export type GetStageThresholdAggregateType<T extends StageThresholdAggregateArgs> = {
        [P in keyof T & keyof AggregateStageThreshold]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStageThreshold[P]>
      : GetScalarType<T[P], AggregateStageThreshold[P]>
  }




  export type StageThresholdGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StageThresholdWhereInput
    orderBy?: StageThresholdOrderByWithAggregationInput | StageThresholdOrderByWithAggregationInput[]
    by: StageThresholdScalarFieldEnum[] | StageThresholdScalarFieldEnum
    having?: StageThresholdScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StageThresholdCountAggregateInputType | true
    _avg?: StageThresholdAvgAggregateInputType
    _sum?: StageThresholdSumAggregateInputType
    _min?: StageThresholdMinAggregateInputType
    _max?: StageThresholdMaxAggregateInputType
  }

  export type StageThresholdGroupByOutputType = {
    id: string
    stageId: string
    indicatorId: string
    operator: $Enums.ThresholdOperator
    value: number
    durationDays: string
    createdAt: Date
    updatedAt: Date
    _count: StageThresholdCountAggregateOutputType | null
    _avg: StageThresholdAvgAggregateOutputType | null
    _sum: StageThresholdSumAggregateOutputType | null
    _min: StageThresholdMinAggregateOutputType | null
    _max: StageThresholdMaxAggregateOutputType | null
  }

  type GetStageThresholdGroupByPayload<T extends StageThresholdGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StageThresholdGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StageThresholdGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StageThresholdGroupByOutputType[P]>
            : GetScalarType<T[P], StageThresholdGroupByOutputType[P]>
        }
      >
    >


  export type StageThresholdSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stageId?: boolean
    indicatorId?: boolean
    operator?: boolean
    value?: boolean
    durationDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stage?: boolean | StageDefaultArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stageThreshold"]>

  export type StageThresholdSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stageId?: boolean
    indicatorId?: boolean
    operator?: boolean
    value?: boolean
    durationDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stage?: boolean | StageDefaultArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stageThreshold"]>

  export type StageThresholdSelectScalar = {
    id?: boolean
    stageId?: boolean
    indicatorId?: boolean
    operator?: boolean
    value?: boolean
    durationDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StageThresholdInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stage?: boolean | StageDefaultArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
  }
  export type StageThresholdIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stage?: boolean | StageDefaultArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
  }

  export type $StageThresholdPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StageThreshold"
    objects: {
      stage: Prisma.$StagePayload<ExtArgs>
      indicator: Prisma.$IndicatorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stageId: string
      indicatorId: string
      operator: $Enums.ThresholdOperator
      value: number
      durationDays: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stageThreshold"]>
    composites: {}
  }

  type StageThresholdGetPayload<S extends boolean | null | undefined | StageThresholdDefaultArgs> = $Result.GetResult<Prisma.$StageThresholdPayload, S>

  type StageThresholdCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StageThresholdFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StageThresholdCountAggregateInputType | true
    }

  export interface StageThresholdDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StageThreshold'], meta: { name: 'StageThreshold' } }
    /**
     * Find zero or one StageThreshold that matches the filter.
     * @param {StageThresholdFindUniqueArgs} args - Arguments to find a StageThreshold
     * @example
     * // Get one StageThreshold
     * const stageThreshold = await prisma.stageThreshold.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StageThresholdFindUniqueArgs>(args: SelectSubset<T, StageThresholdFindUniqueArgs<ExtArgs>>): Prisma__StageThresholdClient<$Result.GetResult<Prisma.$StageThresholdPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StageThreshold that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StageThresholdFindUniqueOrThrowArgs} args - Arguments to find a StageThreshold
     * @example
     * // Get one StageThreshold
     * const stageThreshold = await prisma.stageThreshold.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StageThresholdFindUniqueOrThrowArgs>(args: SelectSubset<T, StageThresholdFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StageThresholdClient<$Result.GetResult<Prisma.$StageThresholdPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StageThreshold that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageThresholdFindFirstArgs} args - Arguments to find a StageThreshold
     * @example
     * // Get one StageThreshold
     * const stageThreshold = await prisma.stageThreshold.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StageThresholdFindFirstArgs>(args?: SelectSubset<T, StageThresholdFindFirstArgs<ExtArgs>>): Prisma__StageThresholdClient<$Result.GetResult<Prisma.$StageThresholdPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StageThreshold that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageThresholdFindFirstOrThrowArgs} args - Arguments to find a StageThreshold
     * @example
     * // Get one StageThreshold
     * const stageThreshold = await prisma.stageThreshold.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StageThresholdFindFirstOrThrowArgs>(args?: SelectSubset<T, StageThresholdFindFirstOrThrowArgs<ExtArgs>>): Prisma__StageThresholdClient<$Result.GetResult<Prisma.$StageThresholdPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StageThresholds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageThresholdFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StageThresholds
     * const stageThresholds = await prisma.stageThreshold.findMany()
     * 
     * // Get first 10 StageThresholds
     * const stageThresholds = await prisma.stageThreshold.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stageThresholdWithIdOnly = await prisma.stageThreshold.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StageThresholdFindManyArgs>(args?: SelectSubset<T, StageThresholdFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StageThresholdPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StageThreshold.
     * @param {StageThresholdCreateArgs} args - Arguments to create a StageThreshold.
     * @example
     * // Create one StageThreshold
     * const StageThreshold = await prisma.stageThreshold.create({
     *   data: {
     *     // ... data to create a StageThreshold
     *   }
     * })
     * 
     */
    create<T extends StageThresholdCreateArgs>(args: SelectSubset<T, StageThresholdCreateArgs<ExtArgs>>): Prisma__StageThresholdClient<$Result.GetResult<Prisma.$StageThresholdPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StageThresholds.
     * @param {StageThresholdCreateManyArgs} args - Arguments to create many StageThresholds.
     * @example
     * // Create many StageThresholds
     * const stageThreshold = await prisma.stageThreshold.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StageThresholdCreateManyArgs>(args?: SelectSubset<T, StageThresholdCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StageThresholds and returns the data saved in the database.
     * @param {StageThresholdCreateManyAndReturnArgs} args - Arguments to create many StageThresholds.
     * @example
     * // Create many StageThresholds
     * const stageThreshold = await prisma.stageThreshold.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StageThresholds and only return the `id`
     * const stageThresholdWithIdOnly = await prisma.stageThreshold.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StageThresholdCreateManyAndReturnArgs>(args?: SelectSubset<T, StageThresholdCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StageThresholdPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StageThreshold.
     * @param {StageThresholdDeleteArgs} args - Arguments to delete one StageThreshold.
     * @example
     * // Delete one StageThreshold
     * const StageThreshold = await prisma.stageThreshold.delete({
     *   where: {
     *     // ... filter to delete one StageThreshold
     *   }
     * })
     * 
     */
    delete<T extends StageThresholdDeleteArgs>(args: SelectSubset<T, StageThresholdDeleteArgs<ExtArgs>>): Prisma__StageThresholdClient<$Result.GetResult<Prisma.$StageThresholdPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StageThreshold.
     * @param {StageThresholdUpdateArgs} args - Arguments to update one StageThreshold.
     * @example
     * // Update one StageThreshold
     * const stageThreshold = await prisma.stageThreshold.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StageThresholdUpdateArgs>(args: SelectSubset<T, StageThresholdUpdateArgs<ExtArgs>>): Prisma__StageThresholdClient<$Result.GetResult<Prisma.$StageThresholdPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StageThresholds.
     * @param {StageThresholdDeleteManyArgs} args - Arguments to filter StageThresholds to delete.
     * @example
     * // Delete a few StageThresholds
     * const { count } = await prisma.stageThreshold.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StageThresholdDeleteManyArgs>(args?: SelectSubset<T, StageThresholdDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StageThresholds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageThresholdUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StageThresholds
     * const stageThreshold = await prisma.stageThreshold.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StageThresholdUpdateManyArgs>(args: SelectSubset<T, StageThresholdUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StageThreshold.
     * @param {StageThresholdUpsertArgs} args - Arguments to update or create a StageThreshold.
     * @example
     * // Update or create a StageThreshold
     * const stageThreshold = await prisma.stageThreshold.upsert({
     *   create: {
     *     // ... data to create a StageThreshold
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StageThreshold we want to update
     *   }
     * })
     */
    upsert<T extends StageThresholdUpsertArgs>(args: SelectSubset<T, StageThresholdUpsertArgs<ExtArgs>>): Prisma__StageThresholdClient<$Result.GetResult<Prisma.$StageThresholdPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StageThresholds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageThresholdCountArgs} args - Arguments to filter StageThresholds to count.
     * @example
     * // Count the number of StageThresholds
     * const count = await prisma.stageThreshold.count({
     *   where: {
     *     // ... the filter for the StageThresholds we want to count
     *   }
     * })
    **/
    count<T extends StageThresholdCountArgs>(
      args?: Subset<T, StageThresholdCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StageThresholdCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StageThreshold.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageThresholdAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StageThresholdAggregateArgs>(args: Subset<T, StageThresholdAggregateArgs>): Prisma.PrismaPromise<GetStageThresholdAggregateType<T>>

    /**
     * Group by StageThreshold.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageThresholdGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StageThresholdGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StageThresholdGroupByArgs['orderBy'] }
        : { orderBy?: StageThresholdGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StageThresholdGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStageThresholdGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StageThreshold model
   */
  readonly fields: StageThresholdFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StageThreshold.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StageThresholdClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stage<T extends StageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StageDefaultArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    indicator<T extends IndicatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IndicatorDefaultArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StageThreshold model
   */ 
  interface StageThresholdFieldRefs {
    readonly id: FieldRef<"StageThreshold", 'String'>
    readonly stageId: FieldRef<"StageThreshold", 'String'>
    readonly indicatorId: FieldRef<"StageThreshold", 'String'>
    readonly operator: FieldRef<"StageThreshold", 'ThresholdOperator'>
    readonly value: FieldRef<"StageThreshold", 'Float'>
    readonly durationDays: FieldRef<"StageThreshold", 'String'>
    readonly createdAt: FieldRef<"StageThreshold", 'DateTime'>
    readonly updatedAt: FieldRef<"StageThreshold", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StageThreshold findUnique
   */
  export type StageThresholdFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageThreshold
     */
    select?: StageThresholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageThresholdInclude<ExtArgs> | null
    /**
     * Filter, which StageThreshold to fetch.
     */
    where: StageThresholdWhereUniqueInput
  }

  /**
   * StageThreshold findUniqueOrThrow
   */
  export type StageThresholdFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageThreshold
     */
    select?: StageThresholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageThresholdInclude<ExtArgs> | null
    /**
     * Filter, which StageThreshold to fetch.
     */
    where: StageThresholdWhereUniqueInput
  }

  /**
   * StageThreshold findFirst
   */
  export type StageThresholdFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageThreshold
     */
    select?: StageThresholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageThresholdInclude<ExtArgs> | null
    /**
     * Filter, which StageThreshold to fetch.
     */
    where?: StageThresholdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StageThresholds to fetch.
     */
    orderBy?: StageThresholdOrderByWithRelationInput | StageThresholdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StageThresholds.
     */
    cursor?: StageThresholdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StageThresholds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StageThresholds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StageThresholds.
     */
    distinct?: StageThresholdScalarFieldEnum | StageThresholdScalarFieldEnum[]
  }

  /**
   * StageThreshold findFirstOrThrow
   */
  export type StageThresholdFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageThreshold
     */
    select?: StageThresholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageThresholdInclude<ExtArgs> | null
    /**
     * Filter, which StageThreshold to fetch.
     */
    where?: StageThresholdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StageThresholds to fetch.
     */
    orderBy?: StageThresholdOrderByWithRelationInput | StageThresholdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StageThresholds.
     */
    cursor?: StageThresholdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StageThresholds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StageThresholds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StageThresholds.
     */
    distinct?: StageThresholdScalarFieldEnum | StageThresholdScalarFieldEnum[]
  }

  /**
   * StageThreshold findMany
   */
  export type StageThresholdFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageThreshold
     */
    select?: StageThresholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageThresholdInclude<ExtArgs> | null
    /**
     * Filter, which StageThresholds to fetch.
     */
    where?: StageThresholdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StageThresholds to fetch.
     */
    orderBy?: StageThresholdOrderByWithRelationInput | StageThresholdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StageThresholds.
     */
    cursor?: StageThresholdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StageThresholds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StageThresholds.
     */
    skip?: number
    distinct?: StageThresholdScalarFieldEnum | StageThresholdScalarFieldEnum[]
  }

  /**
   * StageThreshold create
   */
  export type StageThresholdCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageThreshold
     */
    select?: StageThresholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageThresholdInclude<ExtArgs> | null
    /**
     * The data needed to create a StageThreshold.
     */
    data: XOR<StageThresholdCreateInput, StageThresholdUncheckedCreateInput>
  }

  /**
   * StageThreshold createMany
   */
  export type StageThresholdCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StageThresholds.
     */
    data: StageThresholdCreateManyInput | StageThresholdCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StageThreshold createManyAndReturn
   */
  export type StageThresholdCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageThreshold
     */
    select?: StageThresholdSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StageThresholds.
     */
    data: StageThresholdCreateManyInput | StageThresholdCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageThresholdIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StageThreshold update
   */
  export type StageThresholdUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageThreshold
     */
    select?: StageThresholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageThresholdInclude<ExtArgs> | null
    /**
     * The data needed to update a StageThreshold.
     */
    data: XOR<StageThresholdUpdateInput, StageThresholdUncheckedUpdateInput>
    /**
     * Choose, which StageThreshold to update.
     */
    where: StageThresholdWhereUniqueInput
  }

  /**
   * StageThreshold updateMany
   */
  export type StageThresholdUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StageThresholds.
     */
    data: XOR<StageThresholdUpdateManyMutationInput, StageThresholdUncheckedUpdateManyInput>
    /**
     * Filter which StageThresholds to update
     */
    where?: StageThresholdWhereInput
  }

  /**
   * StageThreshold upsert
   */
  export type StageThresholdUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageThreshold
     */
    select?: StageThresholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageThresholdInclude<ExtArgs> | null
    /**
     * The filter to search for the StageThreshold to update in case it exists.
     */
    where: StageThresholdWhereUniqueInput
    /**
     * In case the StageThreshold found by the `where` argument doesn't exist, create a new StageThreshold with this data.
     */
    create: XOR<StageThresholdCreateInput, StageThresholdUncheckedCreateInput>
    /**
     * In case the StageThreshold was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StageThresholdUpdateInput, StageThresholdUncheckedUpdateInput>
  }

  /**
   * StageThreshold delete
   */
  export type StageThresholdDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageThreshold
     */
    select?: StageThresholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageThresholdInclude<ExtArgs> | null
    /**
     * Filter which StageThreshold to delete.
     */
    where: StageThresholdWhereUniqueInput
  }

  /**
   * StageThreshold deleteMany
   */
  export type StageThresholdDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StageThresholds to delete
     */
    where?: StageThresholdWhereInput
  }

  /**
   * StageThreshold without action
   */
  export type StageThresholdDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageThreshold
     */
    select?: StageThresholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageThresholdInclude<ExtArgs> | null
  }


  /**
   * Model IndicatorCategory
   */

  export type AggregateIndicatorCategory = {
    _count: IndicatorCategoryCountAggregateOutputType | null
    _min: IndicatorCategoryMinAggregateOutputType | null
    _max: IndicatorCategoryMaxAggregateOutputType | null
  }

  export type IndicatorCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IndicatorCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IndicatorCategoryCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IndicatorCategoryMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IndicatorCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IndicatorCategoryCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IndicatorCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IndicatorCategory to aggregate.
     */
    where?: IndicatorCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicatorCategories to fetch.
     */
    orderBy?: IndicatorCategoryOrderByWithRelationInput | IndicatorCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IndicatorCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicatorCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicatorCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IndicatorCategories
    **/
    _count?: true | IndicatorCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndicatorCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndicatorCategoryMaxAggregateInputType
  }

  export type GetIndicatorCategoryAggregateType<T extends IndicatorCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateIndicatorCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndicatorCategory[P]>
      : GetScalarType<T[P], AggregateIndicatorCategory[P]>
  }




  export type IndicatorCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicatorCategoryWhereInput
    orderBy?: IndicatorCategoryOrderByWithAggregationInput | IndicatorCategoryOrderByWithAggregationInput[]
    by: IndicatorCategoryScalarFieldEnum[] | IndicatorCategoryScalarFieldEnum
    having?: IndicatorCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndicatorCategoryCountAggregateInputType | true
    _min?: IndicatorCategoryMinAggregateInputType
    _max?: IndicatorCategoryMaxAggregateInputType
  }

  export type IndicatorCategoryGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: IndicatorCategoryCountAggregateOutputType | null
    _min: IndicatorCategoryMinAggregateOutputType | null
    _max: IndicatorCategoryMaxAggregateOutputType | null
  }

  type GetIndicatorCategoryGroupByPayload<T extends IndicatorCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndicatorCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndicatorCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndicatorCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], IndicatorCategoryGroupByOutputType[P]>
        }
      >
    >


  export type IndicatorCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    indicators?: boolean | IndicatorCategory$indicatorsArgs<ExtArgs>
    _count?: boolean | IndicatorCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["indicatorCategory"]>

  export type IndicatorCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["indicatorCategory"]>

  export type IndicatorCategorySelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IndicatorCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicators?: boolean | IndicatorCategory$indicatorsArgs<ExtArgs>
    _count?: boolean | IndicatorCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IndicatorCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $IndicatorCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IndicatorCategory"
    objects: {
      indicators: Prisma.$IndicatorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["indicatorCategory"]>
    composites: {}
  }

  type IndicatorCategoryGetPayload<S extends boolean | null | undefined | IndicatorCategoryDefaultArgs> = $Result.GetResult<Prisma.$IndicatorCategoryPayload, S>

  type IndicatorCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IndicatorCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IndicatorCategoryCountAggregateInputType | true
    }

  export interface IndicatorCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IndicatorCategory'], meta: { name: 'IndicatorCategory' } }
    /**
     * Find zero or one IndicatorCategory that matches the filter.
     * @param {IndicatorCategoryFindUniqueArgs} args - Arguments to find a IndicatorCategory
     * @example
     * // Get one IndicatorCategory
     * const indicatorCategory = await prisma.indicatorCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IndicatorCategoryFindUniqueArgs>(args: SelectSubset<T, IndicatorCategoryFindUniqueArgs<ExtArgs>>): Prisma__IndicatorCategoryClient<$Result.GetResult<Prisma.$IndicatorCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IndicatorCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IndicatorCategoryFindUniqueOrThrowArgs} args - Arguments to find a IndicatorCategory
     * @example
     * // Get one IndicatorCategory
     * const indicatorCategory = await prisma.indicatorCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IndicatorCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, IndicatorCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IndicatorCategoryClient<$Result.GetResult<Prisma.$IndicatorCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IndicatorCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorCategoryFindFirstArgs} args - Arguments to find a IndicatorCategory
     * @example
     * // Get one IndicatorCategory
     * const indicatorCategory = await prisma.indicatorCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IndicatorCategoryFindFirstArgs>(args?: SelectSubset<T, IndicatorCategoryFindFirstArgs<ExtArgs>>): Prisma__IndicatorCategoryClient<$Result.GetResult<Prisma.$IndicatorCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IndicatorCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorCategoryFindFirstOrThrowArgs} args - Arguments to find a IndicatorCategory
     * @example
     * // Get one IndicatorCategory
     * const indicatorCategory = await prisma.indicatorCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IndicatorCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, IndicatorCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__IndicatorCategoryClient<$Result.GetResult<Prisma.$IndicatorCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IndicatorCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IndicatorCategories
     * const indicatorCategories = await prisma.indicatorCategory.findMany()
     * 
     * // Get first 10 IndicatorCategories
     * const indicatorCategories = await prisma.indicatorCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const indicatorCategoryWithIdOnly = await prisma.indicatorCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IndicatorCategoryFindManyArgs>(args?: SelectSubset<T, IndicatorCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IndicatorCategory.
     * @param {IndicatorCategoryCreateArgs} args - Arguments to create a IndicatorCategory.
     * @example
     * // Create one IndicatorCategory
     * const IndicatorCategory = await prisma.indicatorCategory.create({
     *   data: {
     *     // ... data to create a IndicatorCategory
     *   }
     * })
     * 
     */
    create<T extends IndicatorCategoryCreateArgs>(args: SelectSubset<T, IndicatorCategoryCreateArgs<ExtArgs>>): Prisma__IndicatorCategoryClient<$Result.GetResult<Prisma.$IndicatorCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IndicatorCategories.
     * @param {IndicatorCategoryCreateManyArgs} args - Arguments to create many IndicatorCategories.
     * @example
     * // Create many IndicatorCategories
     * const indicatorCategory = await prisma.indicatorCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IndicatorCategoryCreateManyArgs>(args?: SelectSubset<T, IndicatorCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IndicatorCategories and returns the data saved in the database.
     * @param {IndicatorCategoryCreateManyAndReturnArgs} args - Arguments to create many IndicatorCategories.
     * @example
     * // Create many IndicatorCategories
     * const indicatorCategory = await prisma.indicatorCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IndicatorCategories and only return the `id`
     * const indicatorCategoryWithIdOnly = await prisma.indicatorCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IndicatorCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, IndicatorCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IndicatorCategory.
     * @param {IndicatorCategoryDeleteArgs} args - Arguments to delete one IndicatorCategory.
     * @example
     * // Delete one IndicatorCategory
     * const IndicatorCategory = await prisma.indicatorCategory.delete({
     *   where: {
     *     // ... filter to delete one IndicatorCategory
     *   }
     * })
     * 
     */
    delete<T extends IndicatorCategoryDeleteArgs>(args: SelectSubset<T, IndicatorCategoryDeleteArgs<ExtArgs>>): Prisma__IndicatorCategoryClient<$Result.GetResult<Prisma.$IndicatorCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IndicatorCategory.
     * @param {IndicatorCategoryUpdateArgs} args - Arguments to update one IndicatorCategory.
     * @example
     * // Update one IndicatorCategory
     * const indicatorCategory = await prisma.indicatorCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IndicatorCategoryUpdateArgs>(args: SelectSubset<T, IndicatorCategoryUpdateArgs<ExtArgs>>): Prisma__IndicatorCategoryClient<$Result.GetResult<Prisma.$IndicatorCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IndicatorCategories.
     * @param {IndicatorCategoryDeleteManyArgs} args - Arguments to filter IndicatorCategories to delete.
     * @example
     * // Delete a few IndicatorCategories
     * const { count } = await prisma.indicatorCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IndicatorCategoryDeleteManyArgs>(args?: SelectSubset<T, IndicatorCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IndicatorCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IndicatorCategories
     * const indicatorCategory = await prisma.indicatorCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IndicatorCategoryUpdateManyArgs>(args: SelectSubset<T, IndicatorCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IndicatorCategory.
     * @param {IndicatorCategoryUpsertArgs} args - Arguments to update or create a IndicatorCategory.
     * @example
     * // Update or create a IndicatorCategory
     * const indicatorCategory = await prisma.indicatorCategory.upsert({
     *   create: {
     *     // ... data to create a IndicatorCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IndicatorCategory we want to update
     *   }
     * })
     */
    upsert<T extends IndicatorCategoryUpsertArgs>(args: SelectSubset<T, IndicatorCategoryUpsertArgs<ExtArgs>>): Prisma__IndicatorCategoryClient<$Result.GetResult<Prisma.$IndicatorCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IndicatorCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorCategoryCountArgs} args - Arguments to filter IndicatorCategories to count.
     * @example
     * // Count the number of IndicatorCategories
     * const count = await prisma.indicatorCategory.count({
     *   where: {
     *     // ... the filter for the IndicatorCategories we want to count
     *   }
     * })
    **/
    count<T extends IndicatorCategoryCountArgs>(
      args?: Subset<T, IndicatorCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndicatorCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IndicatorCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndicatorCategoryAggregateArgs>(args: Subset<T, IndicatorCategoryAggregateArgs>): Prisma.PrismaPromise<GetIndicatorCategoryAggregateType<T>>

    /**
     * Group by IndicatorCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IndicatorCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndicatorCategoryGroupByArgs['orderBy'] }
        : { orderBy?: IndicatorCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IndicatorCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndicatorCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IndicatorCategory model
   */
  readonly fields: IndicatorCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IndicatorCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IndicatorCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    indicators<T extends IndicatorCategory$indicatorsArgs<ExtArgs> = {}>(args?: Subset<T, IndicatorCategory$indicatorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IndicatorCategory model
   */ 
  interface IndicatorCategoryFieldRefs {
    readonly id: FieldRef<"IndicatorCategory", 'String'>
    readonly name: FieldRef<"IndicatorCategory", 'String'>
    readonly createdAt: FieldRef<"IndicatorCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"IndicatorCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IndicatorCategory findUnique
   */
  export type IndicatorCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCategory
     */
    select?: IndicatorCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorCategory to fetch.
     */
    where: IndicatorCategoryWhereUniqueInput
  }

  /**
   * IndicatorCategory findUniqueOrThrow
   */
  export type IndicatorCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCategory
     */
    select?: IndicatorCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorCategory to fetch.
     */
    where: IndicatorCategoryWhereUniqueInput
  }

  /**
   * IndicatorCategory findFirst
   */
  export type IndicatorCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCategory
     */
    select?: IndicatorCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorCategory to fetch.
     */
    where?: IndicatorCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicatorCategories to fetch.
     */
    orderBy?: IndicatorCategoryOrderByWithRelationInput | IndicatorCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IndicatorCategories.
     */
    cursor?: IndicatorCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicatorCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicatorCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IndicatorCategories.
     */
    distinct?: IndicatorCategoryScalarFieldEnum | IndicatorCategoryScalarFieldEnum[]
  }

  /**
   * IndicatorCategory findFirstOrThrow
   */
  export type IndicatorCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCategory
     */
    select?: IndicatorCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorCategory to fetch.
     */
    where?: IndicatorCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicatorCategories to fetch.
     */
    orderBy?: IndicatorCategoryOrderByWithRelationInput | IndicatorCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IndicatorCategories.
     */
    cursor?: IndicatorCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicatorCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicatorCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IndicatorCategories.
     */
    distinct?: IndicatorCategoryScalarFieldEnum | IndicatorCategoryScalarFieldEnum[]
  }

  /**
   * IndicatorCategory findMany
   */
  export type IndicatorCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCategory
     */
    select?: IndicatorCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorCategories to fetch.
     */
    where?: IndicatorCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicatorCategories to fetch.
     */
    orderBy?: IndicatorCategoryOrderByWithRelationInput | IndicatorCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IndicatorCategories.
     */
    cursor?: IndicatorCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicatorCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicatorCategories.
     */
    skip?: number
    distinct?: IndicatorCategoryScalarFieldEnum | IndicatorCategoryScalarFieldEnum[]
  }

  /**
   * IndicatorCategory create
   */
  export type IndicatorCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCategory
     */
    select?: IndicatorCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a IndicatorCategory.
     */
    data: XOR<IndicatorCategoryCreateInput, IndicatorCategoryUncheckedCreateInput>
  }

  /**
   * IndicatorCategory createMany
   */
  export type IndicatorCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IndicatorCategories.
     */
    data: IndicatorCategoryCreateManyInput | IndicatorCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IndicatorCategory createManyAndReturn
   */
  export type IndicatorCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCategory
     */
    select?: IndicatorCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IndicatorCategories.
     */
    data: IndicatorCategoryCreateManyInput | IndicatorCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IndicatorCategory update
   */
  export type IndicatorCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCategory
     */
    select?: IndicatorCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a IndicatorCategory.
     */
    data: XOR<IndicatorCategoryUpdateInput, IndicatorCategoryUncheckedUpdateInput>
    /**
     * Choose, which IndicatorCategory to update.
     */
    where: IndicatorCategoryWhereUniqueInput
  }

  /**
   * IndicatorCategory updateMany
   */
  export type IndicatorCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IndicatorCategories.
     */
    data: XOR<IndicatorCategoryUpdateManyMutationInput, IndicatorCategoryUncheckedUpdateManyInput>
    /**
     * Filter which IndicatorCategories to update
     */
    where?: IndicatorCategoryWhereInput
  }

  /**
   * IndicatorCategory upsert
   */
  export type IndicatorCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCategory
     */
    select?: IndicatorCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the IndicatorCategory to update in case it exists.
     */
    where: IndicatorCategoryWhereUniqueInput
    /**
     * In case the IndicatorCategory found by the `where` argument doesn't exist, create a new IndicatorCategory with this data.
     */
    create: XOR<IndicatorCategoryCreateInput, IndicatorCategoryUncheckedCreateInput>
    /**
     * In case the IndicatorCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IndicatorCategoryUpdateInput, IndicatorCategoryUncheckedUpdateInput>
  }

  /**
   * IndicatorCategory delete
   */
  export type IndicatorCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCategory
     */
    select?: IndicatorCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCategoryInclude<ExtArgs> | null
    /**
     * Filter which IndicatorCategory to delete.
     */
    where: IndicatorCategoryWhereUniqueInput
  }

  /**
   * IndicatorCategory deleteMany
   */
  export type IndicatorCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IndicatorCategories to delete
     */
    where?: IndicatorCategoryWhereInput
  }

  /**
   * IndicatorCategory.indicators
   */
  export type IndicatorCategory$indicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    where?: IndicatorWhereInput
    orderBy?: IndicatorOrderByWithRelationInput | IndicatorOrderByWithRelationInput[]
    cursor?: IndicatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IndicatorScalarFieldEnum | IndicatorScalarFieldEnum[]
  }

  /**
   * IndicatorCategory without action
   */
  export type IndicatorCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCategory
     */
    select?: IndicatorCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Indicator
   */

  export type AggregateIndicator = {
    _count: IndicatorCountAggregateOutputType | null
    _min: IndicatorMinAggregateOutputType | null
    _max: IndicatorMaxAggregateOutputType | null
  }

  export type IndicatorMinAggregateOutputType = {
    id: string | null
    categoryId: string | null
    name: string | null
    source: string | null
    unit: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IndicatorMaxAggregateOutputType = {
    id: string | null
    categoryId: string | null
    name: string | null
    source: string | null
    unit: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IndicatorCountAggregateOutputType = {
    id: number
    categoryId: number
    name: number
    source: number
    unit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IndicatorMinAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    source?: true
    unit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IndicatorMaxAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    source?: true
    unit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IndicatorCountAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    source?: true
    unit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IndicatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Indicator to aggregate.
     */
    where?: IndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Indicators to fetch.
     */
    orderBy?: IndicatorOrderByWithRelationInput | IndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Indicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Indicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Indicators
    **/
    _count?: true | IndicatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndicatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndicatorMaxAggregateInputType
  }

  export type GetIndicatorAggregateType<T extends IndicatorAggregateArgs> = {
        [P in keyof T & keyof AggregateIndicator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndicator[P]>
      : GetScalarType<T[P], AggregateIndicator[P]>
  }




  export type IndicatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicatorWhereInput
    orderBy?: IndicatorOrderByWithAggregationInput | IndicatorOrderByWithAggregationInput[]
    by: IndicatorScalarFieldEnum[] | IndicatorScalarFieldEnum
    having?: IndicatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndicatorCountAggregateInputType | true
    _min?: IndicatorMinAggregateInputType
    _max?: IndicatorMaxAggregateInputType
  }

  export type IndicatorGroupByOutputType = {
    id: string
    categoryId: string
    name: string
    source: string
    unit: string
    createdAt: Date
    updatedAt: Date
    _count: IndicatorCountAggregateOutputType | null
    _min: IndicatorMinAggregateOutputType | null
    _max: IndicatorMaxAggregateOutputType | null
  }

  type GetIndicatorGroupByPayload<T extends IndicatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndicatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndicatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndicatorGroupByOutputType[P]>
            : GetScalarType<T[P], IndicatorGroupByOutputType[P]>
        }
      >
    >


  export type IndicatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    name?: boolean
    source?: boolean
    unit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | IndicatorCategoryDefaultArgs<ExtArgs>
    thresholds?: boolean | Indicator$thresholdsArgs<ExtArgs>
    _count?: boolean | IndicatorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["indicator"]>

  export type IndicatorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    name?: boolean
    source?: boolean
    unit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | IndicatorCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["indicator"]>

  export type IndicatorSelectScalar = {
    id?: boolean
    categoryId?: boolean
    name?: boolean
    source?: boolean
    unit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IndicatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | IndicatorCategoryDefaultArgs<ExtArgs>
    thresholds?: boolean | Indicator$thresholdsArgs<ExtArgs>
    _count?: boolean | IndicatorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IndicatorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | IndicatorCategoryDefaultArgs<ExtArgs>
  }

  export type $IndicatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Indicator"
    objects: {
      category: Prisma.$IndicatorCategoryPayload<ExtArgs>
      thresholds: Prisma.$StageThresholdPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      categoryId: string
      name: string
      source: string
      unit: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["indicator"]>
    composites: {}
  }

  type IndicatorGetPayload<S extends boolean | null | undefined | IndicatorDefaultArgs> = $Result.GetResult<Prisma.$IndicatorPayload, S>

  type IndicatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IndicatorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IndicatorCountAggregateInputType | true
    }

  export interface IndicatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Indicator'], meta: { name: 'Indicator' } }
    /**
     * Find zero or one Indicator that matches the filter.
     * @param {IndicatorFindUniqueArgs} args - Arguments to find a Indicator
     * @example
     * // Get one Indicator
     * const indicator = await prisma.indicator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IndicatorFindUniqueArgs>(args: SelectSubset<T, IndicatorFindUniqueArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Indicator that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IndicatorFindUniqueOrThrowArgs} args - Arguments to find a Indicator
     * @example
     * // Get one Indicator
     * const indicator = await prisma.indicator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IndicatorFindUniqueOrThrowArgs>(args: SelectSubset<T, IndicatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Indicator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorFindFirstArgs} args - Arguments to find a Indicator
     * @example
     * // Get one Indicator
     * const indicator = await prisma.indicator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IndicatorFindFirstArgs>(args?: SelectSubset<T, IndicatorFindFirstArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Indicator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorFindFirstOrThrowArgs} args - Arguments to find a Indicator
     * @example
     * // Get one Indicator
     * const indicator = await prisma.indicator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IndicatorFindFirstOrThrowArgs>(args?: SelectSubset<T, IndicatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Indicators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Indicators
     * const indicators = await prisma.indicator.findMany()
     * 
     * // Get first 10 Indicators
     * const indicators = await prisma.indicator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const indicatorWithIdOnly = await prisma.indicator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IndicatorFindManyArgs>(args?: SelectSubset<T, IndicatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Indicator.
     * @param {IndicatorCreateArgs} args - Arguments to create a Indicator.
     * @example
     * // Create one Indicator
     * const Indicator = await prisma.indicator.create({
     *   data: {
     *     // ... data to create a Indicator
     *   }
     * })
     * 
     */
    create<T extends IndicatorCreateArgs>(args: SelectSubset<T, IndicatorCreateArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Indicators.
     * @param {IndicatorCreateManyArgs} args - Arguments to create many Indicators.
     * @example
     * // Create many Indicators
     * const indicator = await prisma.indicator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IndicatorCreateManyArgs>(args?: SelectSubset<T, IndicatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Indicators and returns the data saved in the database.
     * @param {IndicatorCreateManyAndReturnArgs} args - Arguments to create many Indicators.
     * @example
     * // Create many Indicators
     * const indicator = await prisma.indicator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Indicators and only return the `id`
     * const indicatorWithIdOnly = await prisma.indicator.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IndicatorCreateManyAndReturnArgs>(args?: SelectSubset<T, IndicatorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Indicator.
     * @param {IndicatorDeleteArgs} args - Arguments to delete one Indicator.
     * @example
     * // Delete one Indicator
     * const Indicator = await prisma.indicator.delete({
     *   where: {
     *     // ... filter to delete one Indicator
     *   }
     * })
     * 
     */
    delete<T extends IndicatorDeleteArgs>(args: SelectSubset<T, IndicatorDeleteArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Indicator.
     * @param {IndicatorUpdateArgs} args - Arguments to update one Indicator.
     * @example
     * // Update one Indicator
     * const indicator = await prisma.indicator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IndicatorUpdateArgs>(args: SelectSubset<T, IndicatorUpdateArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Indicators.
     * @param {IndicatorDeleteManyArgs} args - Arguments to filter Indicators to delete.
     * @example
     * // Delete a few Indicators
     * const { count } = await prisma.indicator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IndicatorDeleteManyArgs>(args?: SelectSubset<T, IndicatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Indicators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Indicators
     * const indicator = await prisma.indicator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IndicatorUpdateManyArgs>(args: SelectSubset<T, IndicatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Indicator.
     * @param {IndicatorUpsertArgs} args - Arguments to update or create a Indicator.
     * @example
     * // Update or create a Indicator
     * const indicator = await prisma.indicator.upsert({
     *   create: {
     *     // ... data to create a Indicator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Indicator we want to update
     *   }
     * })
     */
    upsert<T extends IndicatorUpsertArgs>(args: SelectSubset<T, IndicatorUpsertArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Indicators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorCountArgs} args - Arguments to filter Indicators to count.
     * @example
     * // Count the number of Indicators
     * const count = await prisma.indicator.count({
     *   where: {
     *     // ... the filter for the Indicators we want to count
     *   }
     * })
    **/
    count<T extends IndicatorCountArgs>(
      args?: Subset<T, IndicatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndicatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Indicator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndicatorAggregateArgs>(args: Subset<T, IndicatorAggregateArgs>): Prisma.PrismaPromise<GetIndicatorAggregateType<T>>

    /**
     * Group by Indicator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IndicatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndicatorGroupByArgs['orderBy'] }
        : { orderBy?: IndicatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IndicatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndicatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Indicator model
   */
  readonly fields: IndicatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Indicator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IndicatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends IndicatorCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IndicatorCategoryDefaultArgs<ExtArgs>>): Prisma__IndicatorCategoryClient<$Result.GetResult<Prisma.$IndicatorCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    thresholds<T extends Indicator$thresholdsArgs<ExtArgs> = {}>(args?: Subset<T, Indicator$thresholdsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StageThresholdPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Indicator model
   */ 
  interface IndicatorFieldRefs {
    readonly id: FieldRef<"Indicator", 'String'>
    readonly categoryId: FieldRef<"Indicator", 'String'>
    readonly name: FieldRef<"Indicator", 'String'>
    readonly source: FieldRef<"Indicator", 'String'>
    readonly unit: FieldRef<"Indicator", 'String'>
    readonly createdAt: FieldRef<"Indicator", 'DateTime'>
    readonly updatedAt: FieldRef<"Indicator", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Indicator findUnique
   */
  export type IndicatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * Filter, which Indicator to fetch.
     */
    where: IndicatorWhereUniqueInput
  }

  /**
   * Indicator findUniqueOrThrow
   */
  export type IndicatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * Filter, which Indicator to fetch.
     */
    where: IndicatorWhereUniqueInput
  }

  /**
   * Indicator findFirst
   */
  export type IndicatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * Filter, which Indicator to fetch.
     */
    where?: IndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Indicators to fetch.
     */
    orderBy?: IndicatorOrderByWithRelationInput | IndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Indicators.
     */
    cursor?: IndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Indicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Indicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Indicators.
     */
    distinct?: IndicatorScalarFieldEnum | IndicatorScalarFieldEnum[]
  }

  /**
   * Indicator findFirstOrThrow
   */
  export type IndicatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * Filter, which Indicator to fetch.
     */
    where?: IndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Indicators to fetch.
     */
    orderBy?: IndicatorOrderByWithRelationInput | IndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Indicators.
     */
    cursor?: IndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Indicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Indicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Indicators.
     */
    distinct?: IndicatorScalarFieldEnum | IndicatorScalarFieldEnum[]
  }

  /**
   * Indicator findMany
   */
  export type IndicatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * Filter, which Indicators to fetch.
     */
    where?: IndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Indicators to fetch.
     */
    orderBy?: IndicatorOrderByWithRelationInput | IndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Indicators.
     */
    cursor?: IndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Indicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Indicators.
     */
    skip?: number
    distinct?: IndicatorScalarFieldEnum | IndicatorScalarFieldEnum[]
  }

  /**
   * Indicator create
   */
  export type IndicatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * The data needed to create a Indicator.
     */
    data: XOR<IndicatorCreateInput, IndicatorUncheckedCreateInput>
  }

  /**
   * Indicator createMany
   */
  export type IndicatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Indicators.
     */
    data: IndicatorCreateManyInput | IndicatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Indicator createManyAndReturn
   */
  export type IndicatorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Indicators.
     */
    data: IndicatorCreateManyInput | IndicatorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Indicator update
   */
  export type IndicatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * The data needed to update a Indicator.
     */
    data: XOR<IndicatorUpdateInput, IndicatorUncheckedUpdateInput>
    /**
     * Choose, which Indicator to update.
     */
    where: IndicatorWhereUniqueInput
  }

  /**
   * Indicator updateMany
   */
  export type IndicatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Indicators.
     */
    data: XOR<IndicatorUpdateManyMutationInput, IndicatorUncheckedUpdateManyInput>
    /**
     * Filter which Indicators to update
     */
    where?: IndicatorWhereInput
  }

  /**
   * Indicator upsert
   */
  export type IndicatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * The filter to search for the Indicator to update in case it exists.
     */
    where: IndicatorWhereUniqueInput
    /**
     * In case the Indicator found by the `where` argument doesn't exist, create a new Indicator with this data.
     */
    create: XOR<IndicatorCreateInput, IndicatorUncheckedCreateInput>
    /**
     * In case the Indicator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IndicatorUpdateInput, IndicatorUncheckedUpdateInput>
  }

  /**
   * Indicator delete
   */
  export type IndicatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * Filter which Indicator to delete.
     */
    where: IndicatorWhereUniqueInput
  }

  /**
   * Indicator deleteMany
   */
  export type IndicatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Indicators to delete
     */
    where?: IndicatorWhereInput
  }

  /**
   * Indicator.thresholds
   */
  export type Indicator$thresholdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageThreshold
     */
    select?: StageThresholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageThresholdInclude<ExtArgs> | null
    where?: StageThresholdWhereInput
    orderBy?: StageThresholdOrderByWithRelationInput | StageThresholdOrderByWithRelationInput[]
    cursor?: StageThresholdWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StageThresholdScalarFieldEnum | StageThresholdScalarFieldEnum[]
  }

  /**
   * Indicator without action
   */
  export type IndicatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
  }


  /**
   * Model Gwl
   */

  export type AggregateGwl = {
    _count: GwlCountAggregateOutputType | null
    _min: GwlMinAggregateOutputType | null
    _max: GwlMaxAggregateOutputType | null
  }

  export type GwlMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type GwlMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type GwlCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type GwlMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type GwlMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type GwlCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type GwlAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gwl to aggregate.
     */
    where?: GwlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gwls to fetch.
     */
    orderBy?: GwlOrderByWithRelationInput | GwlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GwlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gwls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gwls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gwls
    **/
    _count?: true | GwlCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GwlMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GwlMaxAggregateInputType
  }

  export type GetGwlAggregateType<T extends GwlAggregateArgs> = {
        [P in keyof T & keyof AggregateGwl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGwl[P]>
      : GetScalarType<T[P], AggregateGwl[P]>
  }




  export type GwlGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GwlWhereInput
    orderBy?: GwlOrderByWithAggregationInput | GwlOrderByWithAggregationInput[]
    by: GwlScalarFieldEnum[] | GwlScalarFieldEnum
    having?: GwlScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GwlCountAggregateInputType | true
    _min?: GwlMinAggregateInputType
    _max?: GwlMaxAggregateInputType
  }

  export type GwlGroupByOutputType = {
    id: string
    name: string
    _count: GwlCountAggregateOutputType | null
    _min: GwlMinAggregateOutputType | null
    _max: GwlMaxAggregateOutputType | null
  }

  type GetGwlGroupByPayload<T extends GwlGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GwlGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GwlGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GwlGroupByOutputType[P]>
            : GetScalarType<T[P], GwlGroupByOutputType[P]>
        }
      >
    >


  export type GwlSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["gwl"]>

  export type GwlSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["gwl"]>

  export type GwlSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type $GwlPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Gwl"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["gwl"]>
    composites: {}
  }

  type GwlGetPayload<S extends boolean | null | undefined | GwlDefaultArgs> = $Result.GetResult<Prisma.$GwlPayload, S>

  type GwlCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GwlFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GwlCountAggregateInputType | true
    }

  export interface GwlDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Gwl'], meta: { name: 'Gwl' } }
    /**
     * Find zero or one Gwl that matches the filter.
     * @param {GwlFindUniqueArgs} args - Arguments to find a Gwl
     * @example
     * // Get one Gwl
     * const gwl = await prisma.gwl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GwlFindUniqueArgs>(args: SelectSubset<T, GwlFindUniqueArgs<ExtArgs>>): Prisma__GwlClient<$Result.GetResult<Prisma.$GwlPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Gwl that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GwlFindUniqueOrThrowArgs} args - Arguments to find a Gwl
     * @example
     * // Get one Gwl
     * const gwl = await prisma.gwl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GwlFindUniqueOrThrowArgs>(args: SelectSubset<T, GwlFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GwlClient<$Result.GetResult<Prisma.$GwlPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Gwl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GwlFindFirstArgs} args - Arguments to find a Gwl
     * @example
     * // Get one Gwl
     * const gwl = await prisma.gwl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GwlFindFirstArgs>(args?: SelectSubset<T, GwlFindFirstArgs<ExtArgs>>): Prisma__GwlClient<$Result.GetResult<Prisma.$GwlPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Gwl that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GwlFindFirstOrThrowArgs} args - Arguments to find a Gwl
     * @example
     * // Get one Gwl
     * const gwl = await prisma.gwl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GwlFindFirstOrThrowArgs>(args?: SelectSubset<T, GwlFindFirstOrThrowArgs<ExtArgs>>): Prisma__GwlClient<$Result.GetResult<Prisma.$GwlPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Gwls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GwlFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gwls
     * const gwls = await prisma.gwl.findMany()
     * 
     * // Get first 10 Gwls
     * const gwls = await prisma.gwl.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gwlWithIdOnly = await prisma.gwl.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GwlFindManyArgs>(args?: SelectSubset<T, GwlFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GwlPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Gwl.
     * @param {GwlCreateArgs} args - Arguments to create a Gwl.
     * @example
     * // Create one Gwl
     * const Gwl = await prisma.gwl.create({
     *   data: {
     *     // ... data to create a Gwl
     *   }
     * })
     * 
     */
    create<T extends GwlCreateArgs>(args: SelectSubset<T, GwlCreateArgs<ExtArgs>>): Prisma__GwlClient<$Result.GetResult<Prisma.$GwlPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Gwls.
     * @param {GwlCreateManyArgs} args - Arguments to create many Gwls.
     * @example
     * // Create many Gwls
     * const gwl = await prisma.gwl.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GwlCreateManyArgs>(args?: SelectSubset<T, GwlCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Gwls and returns the data saved in the database.
     * @param {GwlCreateManyAndReturnArgs} args - Arguments to create many Gwls.
     * @example
     * // Create many Gwls
     * const gwl = await prisma.gwl.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Gwls and only return the `id`
     * const gwlWithIdOnly = await prisma.gwl.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GwlCreateManyAndReturnArgs>(args?: SelectSubset<T, GwlCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GwlPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Gwl.
     * @param {GwlDeleteArgs} args - Arguments to delete one Gwl.
     * @example
     * // Delete one Gwl
     * const Gwl = await prisma.gwl.delete({
     *   where: {
     *     // ... filter to delete one Gwl
     *   }
     * })
     * 
     */
    delete<T extends GwlDeleteArgs>(args: SelectSubset<T, GwlDeleteArgs<ExtArgs>>): Prisma__GwlClient<$Result.GetResult<Prisma.$GwlPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Gwl.
     * @param {GwlUpdateArgs} args - Arguments to update one Gwl.
     * @example
     * // Update one Gwl
     * const gwl = await prisma.gwl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GwlUpdateArgs>(args: SelectSubset<T, GwlUpdateArgs<ExtArgs>>): Prisma__GwlClient<$Result.GetResult<Prisma.$GwlPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Gwls.
     * @param {GwlDeleteManyArgs} args - Arguments to filter Gwls to delete.
     * @example
     * // Delete a few Gwls
     * const { count } = await prisma.gwl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GwlDeleteManyArgs>(args?: SelectSubset<T, GwlDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gwls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GwlUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gwls
     * const gwl = await prisma.gwl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GwlUpdateManyArgs>(args: SelectSubset<T, GwlUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gwl.
     * @param {GwlUpsertArgs} args - Arguments to update or create a Gwl.
     * @example
     * // Update or create a Gwl
     * const gwl = await prisma.gwl.upsert({
     *   create: {
     *     // ... data to create a Gwl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gwl we want to update
     *   }
     * })
     */
    upsert<T extends GwlUpsertArgs>(args: SelectSubset<T, GwlUpsertArgs<ExtArgs>>): Prisma__GwlClient<$Result.GetResult<Prisma.$GwlPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Gwls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GwlCountArgs} args - Arguments to filter Gwls to count.
     * @example
     * // Count the number of Gwls
     * const count = await prisma.gwl.count({
     *   where: {
     *     // ... the filter for the Gwls we want to count
     *   }
     * })
    **/
    count<T extends GwlCountArgs>(
      args?: Subset<T, GwlCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GwlCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gwl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GwlAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GwlAggregateArgs>(args: Subset<T, GwlAggregateArgs>): Prisma.PrismaPromise<GetGwlAggregateType<T>>

    /**
     * Group by Gwl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GwlGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GwlGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GwlGroupByArgs['orderBy'] }
        : { orderBy?: GwlGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GwlGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGwlGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Gwl model
   */
  readonly fields: GwlFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Gwl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GwlClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Gwl model
   */ 
  interface GwlFieldRefs {
    readonly id: FieldRef<"Gwl", 'String'>
    readonly name: FieldRef<"Gwl", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Gwl findUnique
   */
  export type GwlFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gwl
     */
    select?: GwlSelect<ExtArgs> | null
    /**
     * Filter, which Gwl to fetch.
     */
    where: GwlWhereUniqueInput
  }

  /**
   * Gwl findUniqueOrThrow
   */
  export type GwlFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gwl
     */
    select?: GwlSelect<ExtArgs> | null
    /**
     * Filter, which Gwl to fetch.
     */
    where: GwlWhereUniqueInput
  }

  /**
   * Gwl findFirst
   */
  export type GwlFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gwl
     */
    select?: GwlSelect<ExtArgs> | null
    /**
     * Filter, which Gwl to fetch.
     */
    where?: GwlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gwls to fetch.
     */
    orderBy?: GwlOrderByWithRelationInput | GwlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gwls.
     */
    cursor?: GwlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gwls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gwls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gwls.
     */
    distinct?: GwlScalarFieldEnum | GwlScalarFieldEnum[]
  }

  /**
   * Gwl findFirstOrThrow
   */
  export type GwlFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gwl
     */
    select?: GwlSelect<ExtArgs> | null
    /**
     * Filter, which Gwl to fetch.
     */
    where?: GwlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gwls to fetch.
     */
    orderBy?: GwlOrderByWithRelationInput | GwlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gwls.
     */
    cursor?: GwlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gwls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gwls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gwls.
     */
    distinct?: GwlScalarFieldEnum | GwlScalarFieldEnum[]
  }

  /**
   * Gwl findMany
   */
  export type GwlFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gwl
     */
    select?: GwlSelect<ExtArgs> | null
    /**
     * Filter, which Gwls to fetch.
     */
    where?: GwlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gwls to fetch.
     */
    orderBy?: GwlOrderByWithRelationInput | GwlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gwls.
     */
    cursor?: GwlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gwls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gwls.
     */
    skip?: number
    distinct?: GwlScalarFieldEnum | GwlScalarFieldEnum[]
  }

  /**
   * Gwl create
   */
  export type GwlCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gwl
     */
    select?: GwlSelect<ExtArgs> | null
    /**
     * The data needed to create a Gwl.
     */
    data: XOR<GwlCreateInput, GwlUncheckedCreateInput>
  }

  /**
   * Gwl createMany
   */
  export type GwlCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Gwls.
     */
    data: GwlCreateManyInput | GwlCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gwl createManyAndReturn
   */
  export type GwlCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gwl
     */
    select?: GwlSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Gwls.
     */
    data: GwlCreateManyInput | GwlCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gwl update
   */
  export type GwlUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gwl
     */
    select?: GwlSelect<ExtArgs> | null
    /**
     * The data needed to update a Gwl.
     */
    data: XOR<GwlUpdateInput, GwlUncheckedUpdateInput>
    /**
     * Choose, which Gwl to update.
     */
    where: GwlWhereUniqueInput
  }

  /**
   * Gwl updateMany
   */
  export type GwlUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Gwls.
     */
    data: XOR<GwlUpdateManyMutationInput, GwlUncheckedUpdateManyInput>
    /**
     * Filter which Gwls to update
     */
    where?: GwlWhereInput
  }

  /**
   * Gwl upsert
   */
  export type GwlUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gwl
     */
    select?: GwlSelect<ExtArgs> | null
    /**
     * The filter to search for the Gwl to update in case it exists.
     */
    where: GwlWhereUniqueInput
    /**
     * In case the Gwl found by the `where` argument doesn't exist, create a new Gwl with this data.
     */
    create: XOR<GwlCreateInput, GwlUncheckedCreateInput>
    /**
     * In case the Gwl was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GwlUpdateInput, GwlUncheckedUpdateInput>
  }

  /**
   * Gwl delete
   */
  export type GwlDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gwl
     */
    select?: GwlSelect<ExtArgs> | null
    /**
     * Filter which Gwl to delete.
     */
    where: GwlWhereUniqueInput
  }

  /**
   * Gwl deleteMany
   */
  export type GwlDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gwls to delete
     */
    where?: GwlWhereInput
  }

  /**
   * Gwl without action
   */
  export type GwlDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gwl
     */
    select?: GwlSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CropScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CropScalarFieldEnum = (typeof CropScalarFieldEnum)[keyof typeof CropScalarFieldEnum]


  export const CreatorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CreatorScalarFieldEnum = (typeof CreatorScalarFieldEnum)[keyof typeof CreatorScalarFieldEnum]


  export const CalendarScalarFieldEnum: {
    id: 'id',
    cropId: 'cropId',
    creatorId: 'creatorId',
    sourceCalendarId: 'sourceCalendarId',
    title: 'title',
    zoneName: 'zoneName',
    isShared: 'isShared',
    isPublished: 'isPublished',
    fileType: 'fileType',
    allowCenterUse: 'allowCenterUse',
    sharedAt: 'sharedAt',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CalendarScalarFieldEnum = (typeof CalendarScalarFieldEnum)[keyof typeof CalendarScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const DistrictScalarFieldEnum: {
    id: 'id',
    cityId: 'cityId',
    name: 'name'
  };

  export type DistrictScalarFieldEnum = (typeof DistrictScalarFieldEnum)[keyof typeof DistrictScalarFieldEnum]


  export const CalendarDistrictScalarFieldEnum: {
    calendarId: 'calendarId',
    cityId: 'cityId',
    districtId: 'districtId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CalendarDistrictScalarFieldEnum = (typeof CalendarDistrictScalarFieldEnum)[keyof typeof CalendarDistrictScalarFieldEnum]


  export const StageScalarFieldEnum: {
    id: 'id',
    calendarId: 'calendarId',
    name: 'name',
    description: 'description',
    startMonth: 'startMonth',
    startDecade: 'startDecade',
    endMonth: 'endMonth',
    endDecade: 'endDecade',
    color: 'color',
    status: 'status',
    coverUrl: 'coverUrl',
    coverName: 'coverName',
    coverThumbnail: 'coverThumbnail',
    coverSource: 'coverSource',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StageScalarFieldEnum = (typeof StageScalarFieldEnum)[keyof typeof StageScalarFieldEnum]


  export const StageAlbumScalarFieldEnum: {
    id: 'id',
    stageId: 'stageId',
    url: 'url',
    name: 'name',
    thumbnail: 'thumbnail',
    source: 'source',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StageAlbumScalarFieldEnum = (typeof StageAlbumScalarFieldEnum)[keyof typeof StageAlbumScalarFieldEnum]


  export const StageThresholdScalarFieldEnum: {
    id: 'id',
    stageId: 'stageId',
    indicatorId: 'indicatorId',
    operator: 'operator',
    value: 'value',
    durationDays: 'durationDays',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StageThresholdScalarFieldEnum = (typeof StageThresholdScalarFieldEnum)[keyof typeof StageThresholdScalarFieldEnum]


  export const IndicatorCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IndicatorCategoryScalarFieldEnum = (typeof IndicatorCategoryScalarFieldEnum)[keyof typeof IndicatorCategoryScalarFieldEnum]


  export const IndicatorScalarFieldEnum: {
    id: 'id',
    categoryId: 'categoryId',
    name: 'name',
    source: 'source',
    unit: 'unit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IndicatorScalarFieldEnum = (typeof IndicatorScalarFieldEnum)[keyof typeof IndicatorScalarFieldEnum]


  export const GwlScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type GwlScalarFieldEnum = (typeof GwlScalarFieldEnum)[keyof typeof GwlScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'CalendarFileType'
   */
  export type EnumCalendarFileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CalendarFileType'>
    


  /**
   * Reference to a field of type 'CalendarFileType[]'
   */
  export type ListEnumCalendarFileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CalendarFileType[]'>
    


  /**
   * Reference to a field of type 'Decade'
   */
  export type EnumDecadeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decade'>
    


  /**
   * Reference to a field of type 'Decade[]'
   */
  export type ListEnumDecadeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decade[]'>
    


  /**
   * Reference to a field of type 'StageStatus'
   */
  export type EnumStageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StageStatus'>
    


  /**
   * Reference to a field of type 'StageStatus[]'
   */
  export type ListEnumStageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StageStatus[]'>
    


  /**
   * Reference to a field of type 'ThresholdOperator'
   */
  export type EnumThresholdOperatorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ThresholdOperator'>
    


  /**
   * Reference to a field of type 'ThresholdOperator[]'
   */
  export type ListEnumThresholdOperatorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ThresholdOperator[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    
  /**
   * Deep Input Types
   */


  export type CropWhereInput = {
    AND?: CropWhereInput | CropWhereInput[]
    OR?: CropWhereInput[]
    NOT?: CropWhereInput | CropWhereInput[]
    id?: StringFilter<"Crop"> | string
    name?: StringFilter<"Crop"> | string
    createdAt?: DateTimeFilter<"Crop"> | Date | string
    updatedAt?: DateTimeFilter<"Crop"> | Date | string
    calendars?: CalendarListRelationFilter
  }

  export type CropOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    calendars?: CalendarOrderByRelationAggregateInput
  }

  export type CropWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CropWhereInput | CropWhereInput[]
    OR?: CropWhereInput[]
    NOT?: CropWhereInput | CropWhereInput[]
    name?: StringFilter<"Crop"> | string
    createdAt?: DateTimeFilter<"Crop"> | Date | string
    updatedAt?: DateTimeFilter<"Crop"> | Date | string
    calendars?: CalendarListRelationFilter
  }, "id">

  export type CropOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CropCountOrderByAggregateInput
    _max?: CropMaxOrderByAggregateInput
    _min?: CropMinOrderByAggregateInput
  }

  export type CropScalarWhereWithAggregatesInput = {
    AND?: CropScalarWhereWithAggregatesInput | CropScalarWhereWithAggregatesInput[]
    OR?: CropScalarWhereWithAggregatesInput[]
    NOT?: CropScalarWhereWithAggregatesInput | CropScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Crop"> | string
    name?: StringWithAggregatesFilter<"Crop"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Crop"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Crop"> | Date | string
  }

  export type CreatorWhereInput = {
    AND?: CreatorWhereInput | CreatorWhereInput[]
    OR?: CreatorWhereInput[]
    NOT?: CreatorWhereInput | CreatorWhereInput[]
    id?: StringFilter<"Creator"> | string
    name?: StringFilter<"Creator"> | string
    role?: StringFilter<"Creator"> | string
    createdAt?: DateTimeFilter<"Creator"> | Date | string
    updatedAt?: DateTimeFilter<"Creator"> | Date | string
    calendars?: CalendarListRelationFilter
  }

  export type CreatorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    calendars?: CalendarOrderByRelationAggregateInput
  }

  export type CreatorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CreatorWhereInput | CreatorWhereInput[]
    OR?: CreatorWhereInput[]
    NOT?: CreatorWhereInput | CreatorWhereInput[]
    name?: StringFilter<"Creator"> | string
    role?: StringFilter<"Creator"> | string
    createdAt?: DateTimeFilter<"Creator"> | Date | string
    updatedAt?: DateTimeFilter<"Creator"> | Date | string
    calendars?: CalendarListRelationFilter
  }, "id">

  export type CreatorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CreatorCountOrderByAggregateInput
    _max?: CreatorMaxOrderByAggregateInput
    _min?: CreatorMinOrderByAggregateInput
  }

  export type CreatorScalarWhereWithAggregatesInput = {
    AND?: CreatorScalarWhereWithAggregatesInput | CreatorScalarWhereWithAggregatesInput[]
    OR?: CreatorScalarWhereWithAggregatesInput[]
    NOT?: CreatorScalarWhereWithAggregatesInput | CreatorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Creator"> | string
    name?: StringWithAggregatesFilter<"Creator"> | string
    role?: StringWithAggregatesFilter<"Creator"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Creator"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Creator"> | Date | string
  }

  export type CalendarWhereInput = {
    AND?: CalendarWhereInput | CalendarWhereInput[]
    OR?: CalendarWhereInput[]
    NOT?: CalendarWhereInput | CalendarWhereInput[]
    id?: StringFilter<"Calendar"> | string
    cropId?: StringFilter<"Calendar"> | string
    creatorId?: StringFilter<"Calendar"> | string
    sourceCalendarId?: StringNullableFilter<"Calendar"> | string | null
    title?: StringFilter<"Calendar"> | string
    zoneName?: StringFilter<"Calendar"> | string
    isShared?: BoolFilter<"Calendar"> | boolean
    isPublished?: BoolFilter<"Calendar"> | boolean
    fileType?: EnumCalendarFileTypeFilter<"Calendar"> | $Enums.CalendarFileType
    allowCenterUse?: BoolFilter<"Calendar"> | boolean
    sharedAt?: DateTimeNullableFilter<"Calendar"> | Date | string | null
    publishedAt?: DateTimeNullableFilter<"Calendar"> | Date | string | null
    createdAt?: DateTimeFilter<"Calendar"> | Date | string
    updatedAt?: DateTimeFilter<"Calendar"> | Date | string
    crop?: XOR<CropRelationFilter, CropWhereInput>
    creator?: XOR<CreatorRelationFilter, CreatorWhereInput>
    sourceCalendar?: XOR<CalendarNullableRelationFilter, CalendarWhereInput> | null
    copy?: XOR<CalendarNullableRelationFilter, CalendarWhereInput> | null
    stages?: StageListRelationFilter
    districts?: CalendarDistrictListRelationFilter
  }

  export type CalendarOrderByWithRelationInput = {
    id?: SortOrder
    cropId?: SortOrder
    creatorId?: SortOrder
    sourceCalendarId?: SortOrderInput | SortOrder
    title?: SortOrder
    zoneName?: SortOrder
    isShared?: SortOrder
    isPublished?: SortOrder
    fileType?: SortOrder
    allowCenterUse?: SortOrder
    sharedAt?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    crop?: CropOrderByWithRelationInput
    creator?: CreatorOrderByWithRelationInput
    sourceCalendar?: CalendarOrderByWithRelationInput
    copy?: CalendarOrderByWithRelationInput
    stages?: StageOrderByRelationAggregateInput
    districts?: CalendarDistrictOrderByRelationAggregateInput
  }

  export type CalendarWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sourceCalendarId?: string
    AND?: CalendarWhereInput | CalendarWhereInput[]
    OR?: CalendarWhereInput[]
    NOT?: CalendarWhereInput | CalendarWhereInput[]
    cropId?: StringFilter<"Calendar"> | string
    creatorId?: StringFilter<"Calendar"> | string
    title?: StringFilter<"Calendar"> | string
    zoneName?: StringFilter<"Calendar"> | string
    isShared?: BoolFilter<"Calendar"> | boolean
    isPublished?: BoolFilter<"Calendar"> | boolean
    fileType?: EnumCalendarFileTypeFilter<"Calendar"> | $Enums.CalendarFileType
    allowCenterUse?: BoolFilter<"Calendar"> | boolean
    sharedAt?: DateTimeNullableFilter<"Calendar"> | Date | string | null
    publishedAt?: DateTimeNullableFilter<"Calendar"> | Date | string | null
    createdAt?: DateTimeFilter<"Calendar"> | Date | string
    updatedAt?: DateTimeFilter<"Calendar"> | Date | string
    crop?: XOR<CropRelationFilter, CropWhereInput>
    creator?: XOR<CreatorRelationFilter, CreatorWhereInput>
    sourceCalendar?: XOR<CalendarNullableRelationFilter, CalendarWhereInput> | null
    copy?: XOR<CalendarNullableRelationFilter, CalendarWhereInput> | null
    stages?: StageListRelationFilter
    districts?: CalendarDistrictListRelationFilter
  }, "id" | "sourceCalendarId">

  export type CalendarOrderByWithAggregationInput = {
    id?: SortOrder
    cropId?: SortOrder
    creatorId?: SortOrder
    sourceCalendarId?: SortOrderInput | SortOrder
    title?: SortOrder
    zoneName?: SortOrder
    isShared?: SortOrder
    isPublished?: SortOrder
    fileType?: SortOrder
    allowCenterUse?: SortOrder
    sharedAt?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CalendarCountOrderByAggregateInput
    _max?: CalendarMaxOrderByAggregateInput
    _min?: CalendarMinOrderByAggregateInput
  }

  export type CalendarScalarWhereWithAggregatesInput = {
    AND?: CalendarScalarWhereWithAggregatesInput | CalendarScalarWhereWithAggregatesInput[]
    OR?: CalendarScalarWhereWithAggregatesInput[]
    NOT?: CalendarScalarWhereWithAggregatesInput | CalendarScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Calendar"> | string
    cropId?: StringWithAggregatesFilter<"Calendar"> | string
    creatorId?: StringWithAggregatesFilter<"Calendar"> | string
    sourceCalendarId?: StringNullableWithAggregatesFilter<"Calendar"> | string | null
    title?: StringWithAggregatesFilter<"Calendar"> | string
    zoneName?: StringWithAggregatesFilter<"Calendar"> | string
    isShared?: BoolWithAggregatesFilter<"Calendar"> | boolean
    isPublished?: BoolWithAggregatesFilter<"Calendar"> | boolean
    fileType?: EnumCalendarFileTypeWithAggregatesFilter<"Calendar"> | $Enums.CalendarFileType
    allowCenterUse?: BoolWithAggregatesFilter<"Calendar"> | boolean
    sharedAt?: DateTimeNullableWithAggregatesFilter<"Calendar"> | Date | string | null
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Calendar"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Calendar"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Calendar"> | Date | string
  }

  export type CityWhereInput = {
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    id?: StringFilter<"City"> | string
    name?: StringFilter<"City"> | string
    districts?: DistrictListRelationFilter
    calendarDistricts?: CalendarDistrictListRelationFilter
  }

  export type CityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    districts?: DistrictOrderByRelationAggregateInput
    calendarDistricts?: CalendarDistrictOrderByRelationAggregateInput
  }

  export type CityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    name?: StringFilter<"City"> | string
    districts?: DistrictListRelationFilter
    calendarDistricts?: CalendarDistrictListRelationFilter
  }, "id">

  export type CityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: CityCountOrderByAggregateInput
    _max?: CityMaxOrderByAggregateInput
    _min?: CityMinOrderByAggregateInput
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    OR?: CityScalarWhereWithAggregatesInput[]
    NOT?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"City"> | string
    name?: StringWithAggregatesFilter<"City"> | string
  }

  export type DistrictWhereInput = {
    AND?: DistrictWhereInput | DistrictWhereInput[]
    OR?: DistrictWhereInput[]
    NOT?: DistrictWhereInput | DistrictWhereInput[]
    id?: StringFilter<"District"> | string
    cityId?: StringFilter<"District"> | string
    name?: StringFilter<"District"> | string
    city?: XOR<CityRelationFilter, CityWhereInput>
    calendarDistricts?: CalendarDistrictListRelationFilter
  }

  export type DistrictOrderByWithRelationInput = {
    id?: SortOrder
    cityId?: SortOrder
    name?: SortOrder
    city?: CityOrderByWithRelationInput
    calendarDistricts?: CalendarDistrictOrderByRelationAggregateInput
  }

  export type DistrictWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DistrictWhereInput | DistrictWhereInput[]
    OR?: DistrictWhereInput[]
    NOT?: DistrictWhereInput | DistrictWhereInput[]
    cityId?: StringFilter<"District"> | string
    name?: StringFilter<"District"> | string
    city?: XOR<CityRelationFilter, CityWhereInput>
    calendarDistricts?: CalendarDistrictListRelationFilter
  }, "id">

  export type DistrictOrderByWithAggregationInput = {
    id?: SortOrder
    cityId?: SortOrder
    name?: SortOrder
    _count?: DistrictCountOrderByAggregateInput
    _max?: DistrictMaxOrderByAggregateInput
    _min?: DistrictMinOrderByAggregateInput
  }

  export type DistrictScalarWhereWithAggregatesInput = {
    AND?: DistrictScalarWhereWithAggregatesInput | DistrictScalarWhereWithAggregatesInput[]
    OR?: DistrictScalarWhereWithAggregatesInput[]
    NOT?: DistrictScalarWhereWithAggregatesInput | DistrictScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"District"> | string
    cityId?: StringWithAggregatesFilter<"District"> | string
    name?: StringWithAggregatesFilter<"District"> | string
  }

  export type CalendarDistrictWhereInput = {
    AND?: CalendarDistrictWhereInput | CalendarDistrictWhereInput[]
    OR?: CalendarDistrictWhereInput[]
    NOT?: CalendarDistrictWhereInput | CalendarDistrictWhereInput[]
    calendarId?: StringFilter<"CalendarDistrict"> | string
    cityId?: StringFilter<"CalendarDistrict"> | string
    districtId?: StringFilter<"CalendarDistrict"> | string
    createdAt?: DateTimeFilter<"CalendarDistrict"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarDistrict"> | Date | string
    calendar?: XOR<CalendarRelationFilter, CalendarWhereInput>
    city?: XOR<CityRelationFilter, CityWhereInput>
    district?: XOR<DistrictRelationFilter, DistrictWhereInput>
  }

  export type CalendarDistrictOrderByWithRelationInput = {
    calendarId?: SortOrder
    cityId?: SortOrder
    districtId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    calendar?: CalendarOrderByWithRelationInput
    city?: CityOrderByWithRelationInput
    district?: DistrictOrderByWithRelationInput
  }

  export type CalendarDistrictWhereUniqueInput = Prisma.AtLeast<{
    calendarId_cityId_districtId?: CalendarDistrictCalendarIdCityIdDistrictIdCompoundUniqueInput
    AND?: CalendarDistrictWhereInput | CalendarDistrictWhereInput[]
    OR?: CalendarDistrictWhereInput[]
    NOT?: CalendarDistrictWhereInput | CalendarDistrictWhereInput[]
    calendarId?: StringFilter<"CalendarDistrict"> | string
    cityId?: StringFilter<"CalendarDistrict"> | string
    districtId?: StringFilter<"CalendarDistrict"> | string
    createdAt?: DateTimeFilter<"CalendarDistrict"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarDistrict"> | Date | string
    calendar?: XOR<CalendarRelationFilter, CalendarWhereInput>
    city?: XOR<CityRelationFilter, CityWhereInput>
    district?: XOR<DistrictRelationFilter, DistrictWhereInput>
  }, "calendarId_cityId_districtId">

  export type CalendarDistrictOrderByWithAggregationInput = {
    calendarId?: SortOrder
    cityId?: SortOrder
    districtId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CalendarDistrictCountOrderByAggregateInput
    _max?: CalendarDistrictMaxOrderByAggregateInput
    _min?: CalendarDistrictMinOrderByAggregateInput
  }

  export type CalendarDistrictScalarWhereWithAggregatesInput = {
    AND?: CalendarDistrictScalarWhereWithAggregatesInput | CalendarDistrictScalarWhereWithAggregatesInput[]
    OR?: CalendarDistrictScalarWhereWithAggregatesInput[]
    NOT?: CalendarDistrictScalarWhereWithAggregatesInput | CalendarDistrictScalarWhereWithAggregatesInput[]
    calendarId?: StringWithAggregatesFilter<"CalendarDistrict"> | string
    cityId?: StringWithAggregatesFilter<"CalendarDistrict"> | string
    districtId?: StringWithAggregatesFilter<"CalendarDistrict"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CalendarDistrict"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CalendarDistrict"> | Date | string
  }

  export type StageWhereInput = {
    AND?: StageWhereInput | StageWhereInput[]
    OR?: StageWhereInput[]
    NOT?: StageWhereInput | StageWhereInput[]
    id?: StringFilter<"Stage"> | string
    calendarId?: StringFilter<"Stage"> | string
    name?: StringFilter<"Stage"> | string
    description?: StringNullableFilter<"Stage"> | string | null
    startMonth?: StringNullableFilter<"Stage"> | string | null
    startDecade?: EnumDecadeNullableFilter<"Stage"> | $Enums.Decade | null
    endMonth?: StringNullableFilter<"Stage"> | string | null
    endDecade?: EnumDecadeNullableFilter<"Stage"> | $Enums.Decade | null
    color?: StringFilter<"Stage"> | string
    status?: EnumStageStatusFilter<"Stage"> | $Enums.StageStatus
    coverUrl?: StringNullableFilter<"Stage"> | string | null
    coverName?: StringNullableFilter<"Stage"> | string | null
    coverThumbnail?: StringNullableFilter<"Stage"> | string | null
    coverSource?: StringNullableFilter<"Stage"> | string | null
    createdAt?: DateTimeFilter<"Stage"> | Date | string
    updatedAt?: DateTimeFilter<"Stage"> | Date | string
    calendar?: XOR<CalendarRelationFilter, CalendarWhereInput>
    thresholds?: StageThresholdListRelationFilter
    albums?: StageAlbumListRelationFilter
  }

  export type StageOrderByWithRelationInput = {
    id?: SortOrder
    calendarId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startMonth?: SortOrderInput | SortOrder
    startDecade?: SortOrderInput | SortOrder
    endMonth?: SortOrderInput | SortOrder
    endDecade?: SortOrderInput | SortOrder
    color?: SortOrder
    status?: SortOrder
    coverUrl?: SortOrderInput | SortOrder
    coverName?: SortOrderInput | SortOrder
    coverThumbnail?: SortOrderInput | SortOrder
    coverSource?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    calendar?: CalendarOrderByWithRelationInput
    thresholds?: StageThresholdOrderByRelationAggregateInput
    albums?: StageAlbumOrderByRelationAggregateInput
  }

  export type StageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StageWhereInput | StageWhereInput[]
    OR?: StageWhereInput[]
    NOT?: StageWhereInput | StageWhereInput[]
    calendarId?: StringFilter<"Stage"> | string
    name?: StringFilter<"Stage"> | string
    description?: StringNullableFilter<"Stage"> | string | null
    startMonth?: StringNullableFilter<"Stage"> | string | null
    startDecade?: EnumDecadeNullableFilter<"Stage"> | $Enums.Decade | null
    endMonth?: StringNullableFilter<"Stage"> | string | null
    endDecade?: EnumDecadeNullableFilter<"Stage"> | $Enums.Decade | null
    color?: StringFilter<"Stage"> | string
    status?: EnumStageStatusFilter<"Stage"> | $Enums.StageStatus
    coverUrl?: StringNullableFilter<"Stage"> | string | null
    coverName?: StringNullableFilter<"Stage"> | string | null
    coverThumbnail?: StringNullableFilter<"Stage"> | string | null
    coverSource?: StringNullableFilter<"Stage"> | string | null
    createdAt?: DateTimeFilter<"Stage"> | Date | string
    updatedAt?: DateTimeFilter<"Stage"> | Date | string
    calendar?: XOR<CalendarRelationFilter, CalendarWhereInput>
    thresholds?: StageThresholdListRelationFilter
    albums?: StageAlbumListRelationFilter
  }, "id">

  export type StageOrderByWithAggregationInput = {
    id?: SortOrder
    calendarId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startMonth?: SortOrderInput | SortOrder
    startDecade?: SortOrderInput | SortOrder
    endMonth?: SortOrderInput | SortOrder
    endDecade?: SortOrderInput | SortOrder
    color?: SortOrder
    status?: SortOrder
    coverUrl?: SortOrderInput | SortOrder
    coverName?: SortOrderInput | SortOrder
    coverThumbnail?: SortOrderInput | SortOrder
    coverSource?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StageCountOrderByAggregateInput
    _max?: StageMaxOrderByAggregateInput
    _min?: StageMinOrderByAggregateInput
  }

  export type StageScalarWhereWithAggregatesInput = {
    AND?: StageScalarWhereWithAggregatesInput | StageScalarWhereWithAggregatesInput[]
    OR?: StageScalarWhereWithAggregatesInput[]
    NOT?: StageScalarWhereWithAggregatesInput | StageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Stage"> | string
    calendarId?: StringWithAggregatesFilter<"Stage"> | string
    name?: StringWithAggregatesFilter<"Stage"> | string
    description?: StringNullableWithAggregatesFilter<"Stage"> | string | null
    startMonth?: StringNullableWithAggregatesFilter<"Stage"> | string | null
    startDecade?: EnumDecadeNullableWithAggregatesFilter<"Stage"> | $Enums.Decade | null
    endMonth?: StringNullableWithAggregatesFilter<"Stage"> | string | null
    endDecade?: EnumDecadeNullableWithAggregatesFilter<"Stage"> | $Enums.Decade | null
    color?: StringWithAggregatesFilter<"Stage"> | string
    status?: EnumStageStatusWithAggregatesFilter<"Stage"> | $Enums.StageStatus
    coverUrl?: StringNullableWithAggregatesFilter<"Stage"> | string | null
    coverName?: StringNullableWithAggregatesFilter<"Stage"> | string | null
    coverThumbnail?: StringNullableWithAggregatesFilter<"Stage"> | string | null
    coverSource?: StringNullableWithAggregatesFilter<"Stage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Stage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Stage"> | Date | string
  }

  export type StageAlbumWhereInput = {
    AND?: StageAlbumWhereInput | StageAlbumWhereInput[]
    OR?: StageAlbumWhereInput[]
    NOT?: StageAlbumWhereInput | StageAlbumWhereInput[]
    id?: StringFilter<"StageAlbum"> | string
    stageId?: StringFilter<"StageAlbum"> | string
    url?: StringFilter<"StageAlbum"> | string
    name?: StringNullableFilter<"StageAlbum"> | string | null
    thumbnail?: StringNullableFilter<"StageAlbum"> | string | null
    source?: StringNullableFilter<"StageAlbum"> | string | null
    sortOrder?: StringFilter<"StageAlbum"> | string
    createdAt?: DateTimeFilter<"StageAlbum"> | Date | string
    updatedAt?: DateTimeFilter<"StageAlbum"> | Date | string
    stage?: XOR<StageRelationFilter, StageWhereInput>
  }

  export type StageAlbumOrderByWithRelationInput = {
    id?: SortOrder
    stageId?: SortOrder
    url?: SortOrder
    name?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stage?: StageOrderByWithRelationInput
  }

  export type StageAlbumWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StageAlbumWhereInput | StageAlbumWhereInput[]
    OR?: StageAlbumWhereInput[]
    NOT?: StageAlbumWhereInput | StageAlbumWhereInput[]
    stageId?: StringFilter<"StageAlbum"> | string
    url?: StringFilter<"StageAlbum"> | string
    name?: StringNullableFilter<"StageAlbum"> | string | null
    thumbnail?: StringNullableFilter<"StageAlbum"> | string | null
    source?: StringNullableFilter<"StageAlbum"> | string | null
    sortOrder?: StringFilter<"StageAlbum"> | string
    createdAt?: DateTimeFilter<"StageAlbum"> | Date | string
    updatedAt?: DateTimeFilter<"StageAlbum"> | Date | string
    stage?: XOR<StageRelationFilter, StageWhereInput>
  }, "id">

  export type StageAlbumOrderByWithAggregationInput = {
    id?: SortOrder
    stageId?: SortOrder
    url?: SortOrder
    name?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StageAlbumCountOrderByAggregateInput
    _max?: StageAlbumMaxOrderByAggregateInput
    _min?: StageAlbumMinOrderByAggregateInput
  }

  export type StageAlbumScalarWhereWithAggregatesInput = {
    AND?: StageAlbumScalarWhereWithAggregatesInput | StageAlbumScalarWhereWithAggregatesInput[]
    OR?: StageAlbumScalarWhereWithAggregatesInput[]
    NOT?: StageAlbumScalarWhereWithAggregatesInput | StageAlbumScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StageAlbum"> | string
    stageId?: StringWithAggregatesFilter<"StageAlbum"> | string
    url?: StringWithAggregatesFilter<"StageAlbum"> | string
    name?: StringNullableWithAggregatesFilter<"StageAlbum"> | string | null
    thumbnail?: StringNullableWithAggregatesFilter<"StageAlbum"> | string | null
    source?: StringNullableWithAggregatesFilter<"StageAlbum"> | string | null
    sortOrder?: StringWithAggregatesFilter<"StageAlbum"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StageAlbum"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StageAlbum"> | Date | string
  }

  export type StageThresholdWhereInput = {
    AND?: StageThresholdWhereInput | StageThresholdWhereInput[]
    OR?: StageThresholdWhereInput[]
    NOT?: StageThresholdWhereInput | StageThresholdWhereInput[]
    id?: StringFilter<"StageThreshold"> | string
    stageId?: StringFilter<"StageThreshold"> | string
    indicatorId?: StringFilter<"StageThreshold"> | string
    operator?: EnumThresholdOperatorFilter<"StageThreshold"> | $Enums.ThresholdOperator
    value?: FloatFilter<"StageThreshold"> | number
    durationDays?: StringFilter<"StageThreshold"> | string
    createdAt?: DateTimeFilter<"StageThreshold"> | Date | string
    updatedAt?: DateTimeFilter<"StageThreshold"> | Date | string
    stage?: XOR<StageRelationFilter, StageWhereInput>
    indicator?: XOR<IndicatorRelationFilter, IndicatorWhereInput>
  }

  export type StageThresholdOrderByWithRelationInput = {
    id?: SortOrder
    stageId?: SortOrder
    indicatorId?: SortOrder
    operator?: SortOrder
    value?: SortOrder
    durationDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stage?: StageOrderByWithRelationInput
    indicator?: IndicatorOrderByWithRelationInput
  }

  export type StageThresholdWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StageThresholdWhereInput | StageThresholdWhereInput[]
    OR?: StageThresholdWhereInput[]
    NOT?: StageThresholdWhereInput | StageThresholdWhereInput[]
    stageId?: StringFilter<"StageThreshold"> | string
    indicatorId?: StringFilter<"StageThreshold"> | string
    operator?: EnumThresholdOperatorFilter<"StageThreshold"> | $Enums.ThresholdOperator
    value?: FloatFilter<"StageThreshold"> | number
    durationDays?: StringFilter<"StageThreshold"> | string
    createdAt?: DateTimeFilter<"StageThreshold"> | Date | string
    updatedAt?: DateTimeFilter<"StageThreshold"> | Date | string
    stage?: XOR<StageRelationFilter, StageWhereInput>
    indicator?: XOR<IndicatorRelationFilter, IndicatorWhereInput>
  }, "id">

  export type StageThresholdOrderByWithAggregationInput = {
    id?: SortOrder
    stageId?: SortOrder
    indicatorId?: SortOrder
    operator?: SortOrder
    value?: SortOrder
    durationDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StageThresholdCountOrderByAggregateInput
    _avg?: StageThresholdAvgOrderByAggregateInput
    _max?: StageThresholdMaxOrderByAggregateInput
    _min?: StageThresholdMinOrderByAggregateInput
    _sum?: StageThresholdSumOrderByAggregateInput
  }

  export type StageThresholdScalarWhereWithAggregatesInput = {
    AND?: StageThresholdScalarWhereWithAggregatesInput | StageThresholdScalarWhereWithAggregatesInput[]
    OR?: StageThresholdScalarWhereWithAggregatesInput[]
    NOT?: StageThresholdScalarWhereWithAggregatesInput | StageThresholdScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StageThreshold"> | string
    stageId?: StringWithAggregatesFilter<"StageThreshold"> | string
    indicatorId?: StringWithAggregatesFilter<"StageThreshold"> | string
    operator?: EnumThresholdOperatorWithAggregatesFilter<"StageThreshold"> | $Enums.ThresholdOperator
    value?: FloatWithAggregatesFilter<"StageThreshold"> | number
    durationDays?: StringWithAggregatesFilter<"StageThreshold"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StageThreshold"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StageThreshold"> | Date | string
  }

  export type IndicatorCategoryWhereInput = {
    AND?: IndicatorCategoryWhereInput | IndicatorCategoryWhereInput[]
    OR?: IndicatorCategoryWhereInput[]
    NOT?: IndicatorCategoryWhereInput | IndicatorCategoryWhereInput[]
    id?: StringFilter<"IndicatorCategory"> | string
    name?: StringFilter<"IndicatorCategory"> | string
    createdAt?: DateTimeFilter<"IndicatorCategory"> | Date | string
    updatedAt?: DateTimeFilter<"IndicatorCategory"> | Date | string
    indicators?: IndicatorListRelationFilter
  }

  export type IndicatorCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    indicators?: IndicatorOrderByRelationAggregateInput
  }

  export type IndicatorCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: IndicatorCategoryWhereInput | IndicatorCategoryWhereInput[]
    OR?: IndicatorCategoryWhereInput[]
    NOT?: IndicatorCategoryWhereInput | IndicatorCategoryWhereInput[]
    createdAt?: DateTimeFilter<"IndicatorCategory"> | Date | string
    updatedAt?: DateTimeFilter<"IndicatorCategory"> | Date | string
    indicators?: IndicatorListRelationFilter
  }, "id" | "name">

  export type IndicatorCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IndicatorCategoryCountOrderByAggregateInput
    _max?: IndicatorCategoryMaxOrderByAggregateInput
    _min?: IndicatorCategoryMinOrderByAggregateInput
  }

  export type IndicatorCategoryScalarWhereWithAggregatesInput = {
    AND?: IndicatorCategoryScalarWhereWithAggregatesInput | IndicatorCategoryScalarWhereWithAggregatesInput[]
    OR?: IndicatorCategoryScalarWhereWithAggregatesInput[]
    NOT?: IndicatorCategoryScalarWhereWithAggregatesInput | IndicatorCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IndicatorCategory"> | string
    name?: StringWithAggregatesFilter<"IndicatorCategory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"IndicatorCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IndicatorCategory"> | Date | string
  }

  export type IndicatorWhereInput = {
    AND?: IndicatorWhereInput | IndicatorWhereInput[]
    OR?: IndicatorWhereInput[]
    NOT?: IndicatorWhereInput | IndicatorWhereInput[]
    id?: StringFilter<"Indicator"> | string
    categoryId?: StringFilter<"Indicator"> | string
    name?: StringFilter<"Indicator"> | string
    source?: StringFilter<"Indicator"> | string
    unit?: StringFilter<"Indicator"> | string
    createdAt?: DateTimeFilter<"Indicator"> | Date | string
    updatedAt?: DateTimeFilter<"Indicator"> | Date | string
    category?: XOR<IndicatorCategoryRelationFilter, IndicatorCategoryWhereInput>
    thresholds?: StageThresholdListRelationFilter
  }

  export type IndicatorOrderByWithRelationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    source?: SortOrder
    unit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: IndicatorCategoryOrderByWithRelationInput
    thresholds?: StageThresholdOrderByRelationAggregateInput
  }

  export type IndicatorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IndicatorWhereInput | IndicatorWhereInput[]
    OR?: IndicatorWhereInput[]
    NOT?: IndicatorWhereInput | IndicatorWhereInput[]
    categoryId?: StringFilter<"Indicator"> | string
    name?: StringFilter<"Indicator"> | string
    source?: StringFilter<"Indicator"> | string
    unit?: StringFilter<"Indicator"> | string
    createdAt?: DateTimeFilter<"Indicator"> | Date | string
    updatedAt?: DateTimeFilter<"Indicator"> | Date | string
    category?: XOR<IndicatorCategoryRelationFilter, IndicatorCategoryWhereInput>
    thresholds?: StageThresholdListRelationFilter
  }, "id">

  export type IndicatorOrderByWithAggregationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    source?: SortOrder
    unit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IndicatorCountOrderByAggregateInput
    _max?: IndicatorMaxOrderByAggregateInput
    _min?: IndicatorMinOrderByAggregateInput
  }

  export type IndicatorScalarWhereWithAggregatesInput = {
    AND?: IndicatorScalarWhereWithAggregatesInput | IndicatorScalarWhereWithAggregatesInput[]
    OR?: IndicatorScalarWhereWithAggregatesInput[]
    NOT?: IndicatorScalarWhereWithAggregatesInput | IndicatorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Indicator"> | string
    categoryId?: StringWithAggregatesFilter<"Indicator"> | string
    name?: StringWithAggregatesFilter<"Indicator"> | string
    source?: StringWithAggregatesFilter<"Indicator"> | string
    unit?: StringWithAggregatesFilter<"Indicator"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Indicator"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Indicator"> | Date | string
  }

  export type GwlWhereInput = {
    AND?: GwlWhereInput | GwlWhereInput[]
    OR?: GwlWhereInput[]
    NOT?: GwlWhereInput | GwlWhereInput[]
    id?: StringFilter<"Gwl"> | string
    name?: StringFilter<"Gwl"> | string
  }

  export type GwlOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type GwlWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GwlWhereInput | GwlWhereInput[]
    OR?: GwlWhereInput[]
    NOT?: GwlWhereInput | GwlWhereInput[]
    name?: StringFilter<"Gwl"> | string
  }, "id">

  export type GwlOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: GwlCountOrderByAggregateInput
    _max?: GwlMaxOrderByAggregateInput
    _min?: GwlMinOrderByAggregateInput
  }

  export type GwlScalarWhereWithAggregatesInput = {
    AND?: GwlScalarWhereWithAggregatesInput | GwlScalarWhereWithAggregatesInput[]
    OR?: GwlScalarWhereWithAggregatesInput[]
    NOT?: GwlScalarWhereWithAggregatesInput | GwlScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Gwl"> | string
    name?: StringWithAggregatesFilter<"Gwl"> | string
  }

  export type CropCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    calendars?: CalendarCreateNestedManyWithoutCropInput
  }

  export type CropUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    calendars?: CalendarUncheckedCreateNestedManyWithoutCropInput
  }

  export type CropUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendars?: CalendarUpdateManyWithoutCropNestedInput
  }

  export type CropUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendars?: CalendarUncheckedUpdateManyWithoutCropNestedInput
  }

  export type CropCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CropUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorCreateInput = {
    id?: string
    name: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    calendars?: CalendarCreateNestedManyWithoutCreatorInput
  }

  export type CreatorUncheckedCreateInput = {
    id?: string
    name: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    calendars?: CalendarUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type CreatorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendars?: CalendarUpdateManyWithoutCreatorNestedInput
  }

  export type CreatorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendars?: CalendarUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CreatorCreateManyInput = {
    id?: string
    name: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreatorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarCreateInput = {
    id?: string
    title: string
    zoneName?: string
    isShared?: boolean
    isPublished?: boolean
    fileType?: $Enums.CalendarFileType
    allowCenterUse?: boolean
    sharedAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    crop: CropCreateNestedOneWithoutCalendarsInput
    creator: CreatorCreateNestedOneWithoutCalendarsInput
    sourceCalendar?: CalendarCreateNestedOneWithoutCopyInput
    copy?: CalendarCreateNestedOneWithoutSourceCalendarInput
    stages?: StageCreateNestedManyWithoutCalendarInput
    districts?: CalendarDistrictCreateNestedManyWithoutCalendarInput
  }

  export type CalendarUncheckedCreateInput = {
    id?: string
    cropId: string
    creatorId: string
    sourceCalendarId?: string | null
    title: string
    zoneName?: string
    isShared?: boolean
    isPublished?: boolean
    fileType?: $Enums.CalendarFileType
    allowCenterUse?: boolean
    sharedAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    copy?: CalendarUncheckedCreateNestedOneWithoutSourceCalendarInput
    stages?: StageUncheckedCreateNestedManyWithoutCalendarInput
    districts?: CalendarDistrictUncheckedCreateNestedManyWithoutCalendarInput
  }

  export type CalendarUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crop?: CropUpdateOneRequiredWithoutCalendarsNestedInput
    creator?: CreatorUpdateOneRequiredWithoutCalendarsNestedInput
    sourceCalendar?: CalendarUpdateOneWithoutCopyNestedInput
    copy?: CalendarUpdateOneWithoutSourceCalendarNestedInput
    stages?: StageUpdateManyWithoutCalendarNestedInput
    districts?: CalendarDistrictUpdateManyWithoutCalendarNestedInput
  }

  export type CalendarUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    sourceCalendarId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    copy?: CalendarUncheckedUpdateOneWithoutSourceCalendarNestedInput
    stages?: StageUncheckedUpdateManyWithoutCalendarNestedInput
    districts?: CalendarDistrictUncheckedUpdateManyWithoutCalendarNestedInput
  }

  export type CalendarCreateManyInput = {
    id?: string
    cropId: string
    creatorId: string
    sourceCalendarId?: string | null
    title: string
    zoneName?: string
    isShared?: boolean
    isPublished?: boolean
    fileType?: $Enums.CalendarFileType
    allowCenterUse?: boolean
    sharedAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    sourceCalendarId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityCreateInput = {
    id: string
    name: string
    districts?: DistrictCreateNestedManyWithoutCityInput
    calendarDistricts?: CalendarDistrictCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateInput = {
    id: string
    name: string
    districts?: DistrictUncheckedCreateNestedManyWithoutCityInput
    calendarDistricts?: CalendarDistrictUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    districts?: DistrictUpdateManyWithoutCityNestedInput
    calendarDistricts?: CalendarDistrictUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    districts?: DistrictUncheckedUpdateManyWithoutCityNestedInput
    calendarDistricts?: CalendarDistrictUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityCreateManyInput = {
    id: string
    name: string
  }

  export type CityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DistrictCreateInput = {
    id: string
    name: string
    city: CityCreateNestedOneWithoutDistrictsInput
    calendarDistricts?: CalendarDistrictCreateNestedManyWithoutDistrictInput
  }

  export type DistrictUncheckedCreateInput = {
    id: string
    cityId: string
    name: string
    calendarDistricts?: CalendarDistrictUncheckedCreateNestedManyWithoutDistrictInput
  }

  export type DistrictUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneRequiredWithoutDistrictsNestedInput
    calendarDistricts?: CalendarDistrictUpdateManyWithoutDistrictNestedInput
  }

  export type DistrictUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    calendarDistricts?: CalendarDistrictUncheckedUpdateManyWithoutDistrictNestedInput
  }

  export type DistrictCreateManyInput = {
    id: string
    cityId: string
    name: string
  }

  export type DistrictUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DistrictUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CalendarDistrictCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    calendar: CalendarCreateNestedOneWithoutDistrictsInput
    city: CityCreateNestedOneWithoutCalendarDistrictsInput
    district: DistrictCreateNestedOneWithoutCalendarDistrictsInput
  }

  export type CalendarDistrictUncheckedCreateInput = {
    calendarId: string
    cityId: string
    districtId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarDistrictUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendar?: CalendarUpdateOneRequiredWithoutDistrictsNestedInput
    city?: CityUpdateOneRequiredWithoutCalendarDistrictsNestedInput
    district?: DistrictUpdateOneRequiredWithoutCalendarDistrictsNestedInput
  }

  export type CalendarDistrictUncheckedUpdateInput = {
    calendarId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    districtId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarDistrictCreateManyInput = {
    calendarId: string
    cityId: string
    districtId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarDistrictUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarDistrictUncheckedUpdateManyInput = {
    calendarId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    districtId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageCreateInput = {
    id?: string
    name: string
    description?: string | null
    startMonth?: string | null
    startDecade?: $Enums.Decade | null
    endMonth?: string | null
    endDecade?: $Enums.Decade | null
    color?: string
    status?: $Enums.StageStatus
    coverUrl?: string | null
    coverName?: string | null
    coverThumbnail?: string | null
    coverSource?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    calendar: CalendarCreateNestedOneWithoutStagesInput
    thresholds?: StageThresholdCreateNestedManyWithoutStageInput
    albums?: StageAlbumCreateNestedManyWithoutStageInput
  }

  export type StageUncheckedCreateInput = {
    id?: string
    calendarId: string
    name: string
    description?: string | null
    startMonth?: string | null
    startDecade?: $Enums.Decade | null
    endMonth?: string | null
    endDecade?: $Enums.Decade | null
    color?: string
    status?: $Enums.StageStatus
    coverUrl?: string | null
    coverName?: string | null
    coverThumbnail?: string | null
    coverSource?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    thresholds?: StageThresholdUncheckedCreateNestedManyWithoutStageInput
    albums?: StageAlbumUncheckedCreateNestedManyWithoutStageInput
  }

  export type StageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: NullableStringFieldUpdateOperationsInput | string | null
    startDecade?: NullableEnumDecadeFieldUpdateOperationsInput | $Enums.Decade | null
    endMonth?: NullableStringFieldUpdateOperationsInput | string | null
    endDecade?: NullableEnumDecadeFieldUpdateOperationsInput | $Enums.Decade | null
    color?: StringFieldUpdateOperationsInput | string
    status?: EnumStageStatusFieldUpdateOperationsInput | $Enums.StageStatus
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverName?: NullableStringFieldUpdateOperationsInput | string | null
    coverThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendar?: CalendarUpdateOneRequiredWithoutStagesNestedInput
    thresholds?: StageThresholdUpdateManyWithoutStageNestedInput
    albums?: StageAlbumUpdateManyWithoutStageNestedInput
  }

  export type StageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: NullableStringFieldUpdateOperationsInput | string | null
    startDecade?: NullableEnumDecadeFieldUpdateOperationsInput | $Enums.Decade | null
    endMonth?: NullableStringFieldUpdateOperationsInput | string | null
    endDecade?: NullableEnumDecadeFieldUpdateOperationsInput | $Enums.Decade | null
    color?: StringFieldUpdateOperationsInput | string
    status?: EnumStageStatusFieldUpdateOperationsInput | $Enums.StageStatus
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverName?: NullableStringFieldUpdateOperationsInput | string | null
    coverThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thresholds?: StageThresholdUncheckedUpdateManyWithoutStageNestedInput
    albums?: StageAlbumUncheckedUpdateManyWithoutStageNestedInput
  }

  export type StageCreateManyInput = {
    id?: string
    calendarId: string
    name: string
    description?: string | null
    startMonth?: string | null
    startDecade?: $Enums.Decade | null
    endMonth?: string | null
    endDecade?: $Enums.Decade | null
    color?: string
    status?: $Enums.StageStatus
    coverUrl?: string | null
    coverName?: string | null
    coverThumbnail?: string | null
    coverSource?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: NullableStringFieldUpdateOperationsInput | string | null
    startDecade?: NullableEnumDecadeFieldUpdateOperationsInput | $Enums.Decade | null
    endMonth?: NullableStringFieldUpdateOperationsInput | string | null
    endDecade?: NullableEnumDecadeFieldUpdateOperationsInput | $Enums.Decade | null
    color?: StringFieldUpdateOperationsInput | string
    status?: EnumStageStatusFieldUpdateOperationsInput | $Enums.StageStatus
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverName?: NullableStringFieldUpdateOperationsInput | string | null
    coverThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: NullableStringFieldUpdateOperationsInput | string | null
    startDecade?: NullableEnumDecadeFieldUpdateOperationsInput | $Enums.Decade | null
    endMonth?: NullableStringFieldUpdateOperationsInput | string | null
    endDecade?: NullableEnumDecadeFieldUpdateOperationsInput | $Enums.Decade | null
    color?: StringFieldUpdateOperationsInput | string
    status?: EnumStageStatusFieldUpdateOperationsInput | $Enums.StageStatus
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverName?: NullableStringFieldUpdateOperationsInput | string | null
    coverThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageAlbumCreateInput = {
    id?: string
    url: string
    name?: string | null
    thumbnail?: string | null
    source?: string | null
    sortOrder?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stage: StageCreateNestedOneWithoutAlbumsInput
  }

  export type StageAlbumUncheckedCreateInput = {
    id?: string
    stageId: string
    url: string
    name?: string | null
    thumbnail?: string | null
    source?: string | null
    sortOrder?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageAlbumUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stage?: StageUpdateOneRequiredWithoutAlbumsNestedInput
  }

  export type StageAlbumUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageAlbumCreateManyInput = {
    id?: string
    stageId: string
    url: string
    name?: string | null
    thumbnail?: string | null
    source?: string | null
    sortOrder?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageAlbumUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageAlbumUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageThresholdCreateInput = {
    id?: string
    operator: $Enums.ThresholdOperator
    value: number
    durationDays?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stage: StageCreateNestedOneWithoutThresholdsInput
    indicator: IndicatorCreateNestedOneWithoutThresholdsInput
  }

  export type StageThresholdUncheckedCreateInput = {
    id?: string
    stageId: string
    indicatorId: string
    operator: $Enums.ThresholdOperator
    value: number
    durationDays?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageThresholdUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    operator?: EnumThresholdOperatorFieldUpdateOperationsInput | $Enums.ThresholdOperator
    value?: FloatFieldUpdateOperationsInput | number
    durationDays?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stage?: StageUpdateOneRequiredWithoutThresholdsNestedInput
    indicator?: IndicatorUpdateOneRequiredWithoutThresholdsNestedInput
  }

  export type StageThresholdUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    indicatorId?: StringFieldUpdateOperationsInput | string
    operator?: EnumThresholdOperatorFieldUpdateOperationsInput | $Enums.ThresholdOperator
    value?: FloatFieldUpdateOperationsInput | number
    durationDays?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageThresholdCreateManyInput = {
    id?: string
    stageId: string
    indicatorId: string
    operator: $Enums.ThresholdOperator
    value: number
    durationDays?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageThresholdUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    operator?: EnumThresholdOperatorFieldUpdateOperationsInput | $Enums.ThresholdOperator
    value?: FloatFieldUpdateOperationsInput | number
    durationDays?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageThresholdUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    indicatorId?: StringFieldUpdateOperationsInput | string
    operator?: EnumThresholdOperatorFieldUpdateOperationsInput | $Enums.ThresholdOperator
    value?: FloatFieldUpdateOperationsInput | number
    durationDays?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicatorCategoryCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    indicators?: IndicatorCreateNestedManyWithoutCategoryInput
  }

  export type IndicatorCategoryUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    indicators?: IndicatorUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type IndicatorCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicators?: IndicatorUpdateManyWithoutCategoryNestedInput
  }

  export type IndicatorCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicators?: IndicatorUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type IndicatorCategoryCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndicatorCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicatorCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicatorCreateInput = {
    id?: string
    name: string
    source?: string
    unit: string
    createdAt?: Date | string
    updatedAt?: Date | string
    category: IndicatorCategoryCreateNestedOneWithoutIndicatorsInput
    thresholds?: StageThresholdCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorUncheckedCreateInput = {
    id?: string
    categoryId: string
    name: string
    source?: string
    unit: string
    createdAt?: Date | string
    updatedAt?: Date | string
    thresholds?: StageThresholdUncheckedCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: IndicatorCategoryUpdateOneRequiredWithoutIndicatorsNestedInput
    thresholds?: StageThresholdUpdateManyWithoutIndicatorNestedInput
  }

  export type IndicatorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thresholds?: StageThresholdUncheckedUpdateManyWithoutIndicatorNestedInput
  }

  export type IndicatorCreateManyInput = {
    id?: string
    categoryId: string
    name: string
    source?: string
    unit: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndicatorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicatorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GwlCreateInput = {
    id?: string
    name: string
  }

  export type GwlUncheckedCreateInput = {
    id?: string
    name: string
  }

  export type GwlUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GwlUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GwlCreateManyInput = {
    id?: string
    name: string
  }

  export type GwlUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GwlUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CalendarListRelationFilter = {
    every?: CalendarWhereInput
    some?: CalendarWhereInput
    none?: CalendarWhereInput
  }

  export type CalendarOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CropCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CropMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CropMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type CreatorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreatorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreatorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumCalendarFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CalendarFileType | EnumCalendarFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CalendarFileType[] | ListEnumCalendarFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalendarFileType[] | ListEnumCalendarFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCalendarFileTypeFilter<$PrismaModel> | $Enums.CalendarFileType
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CropRelationFilter = {
    is?: CropWhereInput
    isNot?: CropWhereInput
  }

  export type CreatorRelationFilter = {
    is?: CreatorWhereInput
    isNot?: CreatorWhereInput
  }

  export type CalendarNullableRelationFilter = {
    is?: CalendarWhereInput | null
    isNot?: CalendarWhereInput | null
  }

  export type StageListRelationFilter = {
    every?: StageWhereInput
    some?: StageWhereInput
    none?: StageWhereInput
  }

  export type CalendarDistrictListRelationFilter = {
    every?: CalendarDistrictWhereInput
    some?: CalendarDistrictWhereInput
    none?: CalendarDistrictWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type StageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CalendarDistrictOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CalendarCountOrderByAggregateInput = {
    id?: SortOrder
    cropId?: SortOrder
    creatorId?: SortOrder
    sourceCalendarId?: SortOrder
    title?: SortOrder
    zoneName?: SortOrder
    isShared?: SortOrder
    isPublished?: SortOrder
    fileType?: SortOrder
    allowCenterUse?: SortOrder
    sharedAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarMaxOrderByAggregateInput = {
    id?: SortOrder
    cropId?: SortOrder
    creatorId?: SortOrder
    sourceCalendarId?: SortOrder
    title?: SortOrder
    zoneName?: SortOrder
    isShared?: SortOrder
    isPublished?: SortOrder
    fileType?: SortOrder
    allowCenterUse?: SortOrder
    sharedAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarMinOrderByAggregateInput = {
    id?: SortOrder
    cropId?: SortOrder
    creatorId?: SortOrder
    sourceCalendarId?: SortOrder
    title?: SortOrder
    zoneName?: SortOrder
    isShared?: SortOrder
    isPublished?: SortOrder
    fileType?: SortOrder
    allowCenterUse?: SortOrder
    sharedAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumCalendarFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CalendarFileType | EnumCalendarFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CalendarFileType[] | ListEnumCalendarFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalendarFileType[] | ListEnumCalendarFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCalendarFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.CalendarFileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCalendarFileTypeFilter<$PrismaModel>
    _max?: NestedEnumCalendarFileTypeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DistrictListRelationFilter = {
    every?: DistrictWhereInput
    some?: DistrictWhereInput
    none?: DistrictWhereInput
  }

  export type DistrictOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CityRelationFilter = {
    is?: CityWhereInput
    isNot?: CityWhereInput
  }

  export type DistrictCountOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
    name?: SortOrder
  }

  export type DistrictMaxOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
    name?: SortOrder
  }

  export type DistrictMinOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
    name?: SortOrder
  }

  export type CalendarRelationFilter = {
    is?: CalendarWhereInput
    isNot?: CalendarWhereInput
  }

  export type DistrictRelationFilter = {
    is?: DistrictWhereInput
    isNot?: DistrictWhereInput
  }

  export type CalendarDistrictCalendarIdCityIdDistrictIdCompoundUniqueInput = {
    calendarId: string
    cityId: string
    districtId: string
  }

  export type CalendarDistrictCountOrderByAggregateInput = {
    calendarId?: SortOrder
    cityId?: SortOrder
    districtId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarDistrictMaxOrderByAggregateInput = {
    calendarId?: SortOrder
    cityId?: SortOrder
    districtId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarDistrictMinOrderByAggregateInput = {
    calendarId?: SortOrder
    cityId?: SortOrder
    districtId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDecadeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Decade | EnumDecadeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Decade[] | ListEnumDecadeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Decade[] | ListEnumDecadeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDecadeNullableFilter<$PrismaModel> | $Enums.Decade | null
  }

  export type EnumStageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StageStatus | EnumStageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StageStatus[] | ListEnumStageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StageStatus[] | ListEnumStageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStageStatusFilter<$PrismaModel> | $Enums.StageStatus
  }

  export type StageThresholdListRelationFilter = {
    every?: StageThresholdWhereInput
    some?: StageThresholdWhereInput
    none?: StageThresholdWhereInput
  }

  export type StageAlbumListRelationFilter = {
    every?: StageAlbumWhereInput
    some?: StageAlbumWhereInput
    none?: StageAlbumWhereInput
  }

  export type StageThresholdOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StageAlbumOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StageCountOrderByAggregateInput = {
    id?: SortOrder
    calendarId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startMonth?: SortOrder
    startDecade?: SortOrder
    endMonth?: SortOrder
    endDecade?: SortOrder
    color?: SortOrder
    status?: SortOrder
    coverUrl?: SortOrder
    coverName?: SortOrder
    coverThumbnail?: SortOrder
    coverSource?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StageMaxOrderByAggregateInput = {
    id?: SortOrder
    calendarId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startMonth?: SortOrder
    startDecade?: SortOrder
    endMonth?: SortOrder
    endDecade?: SortOrder
    color?: SortOrder
    status?: SortOrder
    coverUrl?: SortOrder
    coverName?: SortOrder
    coverThumbnail?: SortOrder
    coverSource?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StageMinOrderByAggregateInput = {
    id?: SortOrder
    calendarId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startMonth?: SortOrder
    startDecade?: SortOrder
    endMonth?: SortOrder
    endDecade?: SortOrder
    color?: SortOrder
    status?: SortOrder
    coverUrl?: SortOrder
    coverName?: SortOrder
    coverThumbnail?: SortOrder
    coverSource?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDecadeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Decade | EnumDecadeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Decade[] | ListEnumDecadeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Decade[] | ListEnumDecadeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDecadeNullableWithAggregatesFilter<$PrismaModel> | $Enums.Decade | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDecadeNullableFilter<$PrismaModel>
    _max?: NestedEnumDecadeNullableFilter<$PrismaModel>
  }

  export type EnumStageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StageStatus | EnumStageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StageStatus[] | ListEnumStageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StageStatus[] | ListEnumStageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStageStatusWithAggregatesFilter<$PrismaModel> | $Enums.StageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStageStatusFilter<$PrismaModel>
    _max?: NestedEnumStageStatusFilter<$PrismaModel>
  }

  export type StageRelationFilter = {
    is?: StageWhereInput
    isNot?: StageWhereInput
  }

  export type StageAlbumCountOrderByAggregateInput = {
    id?: SortOrder
    stageId?: SortOrder
    url?: SortOrder
    name?: SortOrder
    thumbnail?: SortOrder
    source?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StageAlbumMaxOrderByAggregateInput = {
    id?: SortOrder
    stageId?: SortOrder
    url?: SortOrder
    name?: SortOrder
    thumbnail?: SortOrder
    source?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StageAlbumMinOrderByAggregateInput = {
    id?: SortOrder
    stageId?: SortOrder
    url?: SortOrder
    name?: SortOrder
    thumbnail?: SortOrder
    source?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumThresholdOperatorFilter<$PrismaModel = never> = {
    equals?: $Enums.ThresholdOperator | EnumThresholdOperatorFieldRefInput<$PrismaModel>
    in?: $Enums.ThresholdOperator[] | ListEnumThresholdOperatorFieldRefInput<$PrismaModel>
    notIn?: $Enums.ThresholdOperator[] | ListEnumThresholdOperatorFieldRefInput<$PrismaModel>
    not?: NestedEnumThresholdOperatorFilter<$PrismaModel> | $Enums.ThresholdOperator
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IndicatorRelationFilter = {
    is?: IndicatorWhereInput
    isNot?: IndicatorWhereInput
  }

  export type StageThresholdCountOrderByAggregateInput = {
    id?: SortOrder
    stageId?: SortOrder
    indicatorId?: SortOrder
    operator?: SortOrder
    value?: SortOrder
    durationDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StageThresholdAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type StageThresholdMaxOrderByAggregateInput = {
    id?: SortOrder
    stageId?: SortOrder
    indicatorId?: SortOrder
    operator?: SortOrder
    value?: SortOrder
    durationDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StageThresholdMinOrderByAggregateInput = {
    id?: SortOrder
    stageId?: SortOrder
    indicatorId?: SortOrder
    operator?: SortOrder
    value?: SortOrder
    durationDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StageThresholdSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type EnumThresholdOperatorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ThresholdOperator | EnumThresholdOperatorFieldRefInput<$PrismaModel>
    in?: $Enums.ThresholdOperator[] | ListEnumThresholdOperatorFieldRefInput<$PrismaModel>
    notIn?: $Enums.ThresholdOperator[] | ListEnumThresholdOperatorFieldRefInput<$PrismaModel>
    not?: NestedEnumThresholdOperatorWithAggregatesFilter<$PrismaModel> | $Enums.ThresholdOperator
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumThresholdOperatorFilter<$PrismaModel>
    _max?: NestedEnumThresholdOperatorFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IndicatorListRelationFilter = {
    every?: IndicatorWhereInput
    some?: IndicatorWhereInput
    none?: IndicatorWhereInput
  }

  export type IndicatorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IndicatorCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndicatorCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndicatorCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndicatorCategoryRelationFilter = {
    is?: IndicatorCategoryWhereInput
    isNot?: IndicatorCategoryWhereInput
  }

  export type IndicatorCountOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    source?: SortOrder
    unit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndicatorMaxOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    source?: SortOrder
    unit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndicatorMinOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    source?: SortOrder
    unit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GwlCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type GwlMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type GwlMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CalendarCreateNestedManyWithoutCropInput = {
    create?: XOR<CalendarCreateWithoutCropInput, CalendarUncheckedCreateWithoutCropInput> | CalendarCreateWithoutCropInput[] | CalendarUncheckedCreateWithoutCropInput[]
    connectOrCreate?: CalendarCreateOrConnectWithoutCropInput | CalendarCreateOrConnectWithoutCropInput[]
    createMany?: CalendarCreateManyCropInputEnvelope
    connect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
  }

  export type CalendarUncheckedCreateNestedManyWithoutCropInput = {
    create?: XOR<CalendarCreateWithoutCropInput, CalendarUncheckedCreateWithoutCropInput> | CalendarCreateWithoutCropInput[] | CalendarUncheckedCreateWithoutCropInput[]
    connectOrCreate?: CalendarCreateOrConnectWithoutCropInput | CalendarCreateOrConnectWithoutCropInput[]
    createMany?: CalendarCreateManyCropInputEnvelope
    connect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CalendarUpdateManyWithoutCropNestedInput = {
    create?: XOR<CalendarCreateWithoutCropInput, CalendarUncheckedCreateWithoutCropInput> | CalendarCreateWithoutCropInput[] | CalendarUncheckedCreateWithoutCropInput[]
    connectOrCreate?: CalendarCreateOrConnectWithoutCropInput | CalendarCreateOrConnectWithoutCropInput[]
    upsert?: CalendarUpsertWithWhereUniqueWithoutCropInput | CalendarUpsertWithWhereUniqueWithoutCropInput[]
    createMany?: CalendarCreateManyCropInputEnvelope
    set?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    disconnect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    delete?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    connect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    update?: CalendarUpdateWithWhereUniqueWithoutCropInput | CalendarUpdateWithWhereUniqueWithoutCropInput[]
    updateMany?: CalendarUpdateManyWithWhereWithoutCropInput | CalendarUpdateManyWithWhereWithoutCropInput[]
    deleteMany?: CalendarScalarWhereInput | CalendarScalarWhereInput[]
  }

  export type CalendarUncheckedUpdateManyWithoutCropNestedInput = {
    create?: XOR<CalendarCreateWithoutCropInput, CalendarUncheckedCreateWithoutCropInput> | CalendarCreateWithoutCropInput[] | CalendarUncheckedCreateWithoutCropInput[]
    connectOrCreate?: CalendarCreateOrConnectWithoutCropInput | CalendarCreateOrConnectWithoutCropInput[]
    upsert?: CalendarUpsertWithWhereUniqueWithoutCropInput | CalendarUpsertWithWhereUniqueWithoutCropInput[]
    createMany?: CalendarCreateManyCropInputEnvelope
    set?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    disconnect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    delete?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    connect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    update?: CalendarUpdateWithWhereUniqueWithoutCropInput | CalendarUpdateWithWhereUniqueWithoutCropInput[]
    updateMany?: CalendarUpdateManyWithWhereWithoutCropInput | CalendarUpdateManyWithWhereWithoutCropInput[]
    deleteMany?: CalendarScalarWhereInput | CalendarScalarWhereInput[]
  }

  export type CalendarCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CalendarCreateWithoutCreatorInput, CalendarUncheckedCreateWithoutCreatorInput> | CalendarCreateWithoutCreatorInput[] | CalendarUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CalendarCreateOrConnectWithoutCreatorInput | CalendarCreateOrConnectWithoutCreatorInput[]
    createMany?: CalendarCreateManyCreatorInputEnvelope
    connect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
  }

  export type CalendarUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CalendarCreateWithoutCreatorInput, CalendarUncheckedCreateWithoutCreatorInput> | CalendarCreateWithoutCreatorInput[] | CalendarUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CalendarCreateOrConnectWithoutCreatorInput | CalendarCreateOrConnectWithoutCreatorInput[]
    createMany?: CalendarCreateManyCreatorInputEnvelope
    connect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
  }

  export type CalendarUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CalendarCreateWithoutCreatorInput, CalendarUncheckedCreateWithoutCreatorInput> | CalendarCreateWithoutCreatorInput[] | CalendarUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CalendarCreateOrConnectWithoutCreatorInput | CalendarCreateOrConnectWithoutCreatorInput[]
    upsert?: CalendarUpsertWithWhereUniqueWithoutCreatorInput | CalendarUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CalendarCreateManyCreatorInputEnvelope
    set?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    disconnect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    delete?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    connect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    update?: CalendarUpdateWithWhereUniqueWithoutCreatorInput | CalendarUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CalendarUpdateManyWithWhereWithoutCreatorInput | CalendarUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CalendarScalarWhereInput | CalendarScalarWhereInput[]
  }

  export type CalendarUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CalendarCreateWithoutCreatorInput, CalendarUncheckedCreateWithoutCreatorInput> | CalendarCreateWithoutCreatorInput[] | CalendarUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CalendarCreateOrConnectWithoutCreatorInput | CalendarCreateOrConnectWithoutCreatorInput[]
    upsert?: CalendarUpsertWithWhereUniqueWithoutCreatorInput | CalendarUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CalendarCreateManyCreatorInputEnvelope
    set?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    disconnect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    delete?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    connect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    update?: CalendarUpdateWithWhereUniqueWithoutCreatorInput | CalendarUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CalendarUpdateManyWithWhereWithoutCreatorInput | CalendarUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CalendarScalarWhereInput | CalendarScalarWhereInput[]
  }

  export type CropCreateNestedOneWithoutCalendarsInput = {
    create?: XOR<CropCreateWithoutCalendarsInput, CropUncheckedCreateWithoutCalendarsInput>
    connectOrCreate?: CropCreateOrConnectWithoutCalendarsInput
    connect?: CropWhereUniqueInput
  }

  export type CreatorCreateNestedOneWithoutCalendarsInput = {
    create?: XOR<CreatorCreateWithoutCalendarsInput, CreatorUncheckedCreateWithoutCalendarsInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutCalendarsInput
    connect?: CreatorWhereUniqueInput
  }

  export type CalendarCreateNestedOneWithoutCopyInput = {
    create?: XOR<CalendarCreateWithoutCopyInput, CalendarUncheckedCreateWithoutCopyInput>
    connectOrCreate?: CalendarCreateOrConnectWithoutCopyInput
    connect?: CalendarWhereUniqueInput
  }

  export type CalendarCreateNestedOneWithoutSourceCalendarInput = {
    create?: XOR<CalendarCreateWithoutSourceCalendarInput, CalendarUncheckedCreateWithoutSourceCalendarInput>
    connectOrCreate?: CalendarCreateOrConnectWithoutSourceCalendarInput
    connect?: CalendarWhereUniqueInput
  }

  export type StageCreateNestedManyWithoutCalendarInput = {
    create?: XOR<StageCreateWithoutCalendarInput, StageUncheckedCreateWithoutCalendarInput> | StageCreateWithoutCalendarInput[] | StageUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: StageCreateOrConnectWithoutCalendarInput | StageCreateOrConnectWithoutCalendarInput[]
    createMany?: StageCreateManyCalendarInputEnvelope
    connect?: StageWhereUniqueInput | StageWhereUniqueInput[]
  }

  export type CalendarDistrictCreateNestedManyWithoutCalendarInput = {
    create?: XOR<CalendarDistrictCreateWithoutCalendarInput, CalendarDistrictUncheckedCreateWithoutCalendarInput> | CalendarDistrictCreateWithoutCalendarInput[] | CalendarDistrictUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: CalendarDistrictCreateOrConnectWithoutCalendarInput | CalendarDistrictCreateOrConnectWithoutCalendarInput[]
    createMany?: CalendarDistrictCreateManyCalendarInputEnvelope
    connect?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
  }

  export type CalendarUncheckedCreateNestedOneWithoutSourceCalendarInput = {
    create?: XOR<CalendarCreateWithoutSourceCalendarInput, CalendarUncheckedCreateWithoutSourceCalendarInput>
    connectOrCreate?: CalendarCreateOrConnectWithoutSourceCalendarInput
    connect?: CalendarWhereUniqueInput
  }

  export type StageUncheckedCreateNestedManyWithoutCalendarInput = {
    create?: XOR<StageCreateWithoutCalendarInput, StageUncheckedCreateWithoutCalendarInput> | StageCreateWithoutCalendarInput[] | StageUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: StageCreateOrConnectWithoutCalendarInput | StageCreateOrConnectWithoutCalendarInput[]
    createMany?: StageCreateManyCalendarInputEnvelope
    connect?: StageWhereUniqueInput | StageWhereUniqueInput[]
  }

  export type CalendarDistrictUncheckedCreateNestedManyWithoutCalendarInput = {
    create?: XOR<CalendarDistrictCreateWithoutCalendarInput, CalendarDistrictUncheckedCreateWithoutCalendarInput> | CalendarDistrictCreateWithoutCalendarInput[] | CalendarDistrictUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: CalendarDistrictCreateOrConnectWithoutCalendarInput | CalendarDistrictCreateOrConnectWithoutCalendarInput[]
    createMany?: CalendarDistrictCreateManyCalendarInputEnvelope
    connect?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumCalendarFileTypeFieldUpdateOperationsInput = {
    set?: $Enums.CalendarFileType
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CropUpdateOneRequiredWithoutCalendarsNestedInput = {
    create?: XOR<CropCreateWithoutCalendarsInput, CropUncheckedCreateWithoutCalendarsInput>
    connectOrCreate?: CropCreateOrConnectWithoutCalendarsInput
    upsert?: CropUpsertWithoutCalendarsInput
    connect?: CropWhereUniqueInput
    update?: XOR<XOR<CropUpdateToOneWithWhereWithoutCalendarsInput, CropUpdateWithoutCalendarsInput>, CropUncheckedUpdateWithoutCalendarsInput>
  }

  export type CreatorUpdateOneRequiredWithoutCalendarsNestedInput = {
    create?: XOR<CreatorCreateWithoutCalendarsInput, CreatorUncheckedCreateWithoutCalendarsInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutCalendarsInput
    upsert?: CreatorUpsertWithoutCalendarsInput
    connect?: CreatorWhereUniqueInput
    update?: XOR<XOR<CreatorUpdateToOneWithWhereWithoutCalendarsInput, CreatorUpdateWithoutCalendarsInput>, CreatorUncheckedUpdateWithoutCalendarsInput>
  }

  export type CalendarUpdateOneWithoutCopyNestedInput = {
    create?: XOR<CalendarCreateWithoutCopyInput, CalendarUncheckedCreateWithoutCopyInput>
    connectOrCreate?: CalendarCreateOrConnectWithoutCopyInput
    upsert?: CalendarUpsertWithoutCopyInput
    disconnect?: CalendarWhereInput | boolean
    delete?: CalendarWhereInput | boolean
    connect?: CalendarWhereUniqueInput
    update?: XOR<XOR<CalendarUpdateToOneWithWhereWithoutCopyInput, CalendarUpdateWithoutCopyInput>, CalendarUncheckedUpdateWithoutCopyInput>
  }

  export type CalendarUpdateOneWithoutSourceCalendarNestedInput = {
    create?: XOR<CalendarCreateWithoutSourceCalendarInput, CalendarUncheckedCreateWithoutSourceCalendarInput>
    connectOrCreate?: CalendarCreateOrConnectWithoutSourceCalendarInput
    upsert?: CalendarUpsertWithoutSourceCalendarInput
    disconnect?: CalendarWhereInput | boolean
    delete?: CalendarWhereInput | boolean
    connect?: CalendarWhereUniqueInput
    update?: XOR<XOR<CalendarUpdateToOneWithWhereWithoutSourceCalendarInput, CalendarUpdateWithoutSourceCalendarInput>, CalendarUncheckedUpdateWithoutSourceCalendarInput>
  }

  export type StageUpdateManyWithoutCalendarNestedInput = {
    create?: XOR<StageCreateWithoutCalendarInput, StageUncheckedCreateWithoutCalendarInput> | StageCreateWithoutCalendarInput[] | StageUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: StageCreateOrConnectWithoutCalendarInput | StageCreateOrConnectWithoutCalendarInput[]
    upsert?: StageUpsertWithWhereUniqueWithoutCalendarInput | StageUpsertWithWhereUniqueWithoutCalendarInput[]
    createMany?: StageCreateManyCalendarInputEnvelope
    set?: StageWhereUniqueInput | StageWhereUniqueInput[]
    disconnect?: StageWhereUniqueInput | StageWhereUniqueInput[]
    delete?: StageWhereUniqueInput | StageWhereUniqueInput[]
    connect?: StageWhereUniqueInput | StageWhereUniqueInput[]
    update?: StageUpdateWithWhereUniqueWithoutCalendarInput | StageUpdateWithWhereUniqueWithoutCalendarInput[]
    updateMany?: StageUpdateManyWithWhereWithoutCalendarInput | StageUpdateManyWithWhereWithoutCalendarInput[]
    deleteMany?: StageScalarWhereInput | StageScalarWhereInput[]
  }

  export type CalendarDistrictUpdateManyWithoutCalendarNestedInput = {
    create?: XOR<CalendarDistrictCreateWithoutCalendarInput, CalendarDistrictUncheckedCreateWithoutCalendarInput> | CalendarDistrictCreateWithoutCalendarInput[] | CalendarDistrictUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: CalendarDistrictCreateOrConnectWithoutCalendarInput | CalendarDistrictCreateOrConnectWithoutCalendarInput[]
    upsert?: CalendarDistrictUpsertWithWhereUniqueWithoutCalendarInput | CalendarDistrictUpsertWithWhereUniqueWithoutCalendarInput[]
    createMany?: CalendarDistrictCreateManyCalendarInputEnvelope
    set?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
    disconnect?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
    delete?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
    connect?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
    update?: CalendarDistrictUpdateWithWhereUniqueWithoutCalendarInput | CalendarDistrictUpdateWithWhereUniqueWithoutCalendarInput[]
    updateMany?: CalendarDistrictUpdateManyWithWhereWithoutCalendarInput | CalendarDistrictUpdateManyWithWhereWithoutCalendarInput[]
    deleteMany?: CalendarDistrictScalarWhereInput | CalendarDistrictScalarWhereInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type CalendarUncheckedUpdateOneWithoutSourceCalendarNestedInput = {
    create?: XOR<CalendarCreateWithoutSourceCalendarInput, CalendarUncheckedCreateWithoutSourceCalendarInput>
    connectOrCreate?: CalendarCreateOrConnectWithoutSourceCalendarInput
    upsert?: CalendarUpsertWithoutSourceCalendarInput
    disconnect?: CalendarWhereInput | boolean
    delete?: CalendarWhereInput | boolean
    connect?: CalendarWhereUniqueInput
    update?: XOR<XOR<CalendarUpdateToOneWithWhereWithoutSourceCalendarInput, CalendarUpdateWithoutSourceCalendarInput>, CalendarUncheckedUpdateWithoutSourceCalendarInput>
  }

  export type StageUncheckedUpdateManyWithoutCalendarNestedInput = {
    create?: XOR<StageCreateWithoutCalendarInput, StageUncheckedCreateWithoutCalendarInput> | StageCreateWithoutCalendarInput[] | StageUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: StageCreateOrConnectWithoutCalendarInput | StageCreateOrConnectWithoutCalendarInput[]
    upsert?: StageUpsertWithWhereUniqueWithoutCalendarInput | StageUpsertWithWhereUniqueWithoutCalendarInput[]
    createMany?: StageCreateManyCalendarInputEnvelope
    set?: StageWhereUniqueInput | StageWhereUniqueInput[]
    disconnect?: StageWhereUniqueInput | StageWhereUniqueInput[]
    delete?: StageWhereUniqueInput | StageWhereUniqueInput[]
    connect?: StageWhereUniqueInput | StageWhereUniqueInput[]
    update?: StageUpdateWithWhereUniqueWithoutCalendarInput | StageUpdateWithWhereUniqueWithoutCalendarInput[]
    updateMany?: StageUpdateManyWithWhereWithoutCalendarInput | StageUpdateManyWithWhereWithoutCalendarInput[]
    deleteMany?: StageScalarWhereInput | StageScalarWhereInput[]
  }

  export type CalendarDistrictUncheckedUpdateManyWithoutCalendarNestedInput = {
    create?: XOR<CalendarDistrictCreateWithoutCalendarInput, CalendarDistrictUncheckedCreateWithoutCalendarInput> | CalendarDistrictCreateWithoutCalendarInput[] | CalendarDistrictUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: CalendarDistrictCreateOrConnectWithoutCalendarInput | CalendarDistrictCreateOrConnectWithoutCalendarInput[]
    upsert?: CalendarDistrictUpsertWithWhereUniqueWithoutCalendarInput | CalendarDistrictUpsertWithWhereUniqueWithoutCalendarInput[]
    createMany?: CalendarDistrictCreateManyCalendarInputEnvelope
    set?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
    disconnect?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
    delete?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
    connect?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
    update?: CalendarDistrictUpdateWithWhereUniqueWithoutCalendarInput | CalendarDistrictUpdateWithWhereUniqueWithoutCalendarInput[]
    updateMany?: CalendarDistrictUpdateManyWithWhereWithoutCalendarInput | CalendarDistrictUpdateManyWithWhereWithoutCalendarInput[]
    deleteMany?: CalendarDistrictScalarWhereInput | CalendarDistrictScalarWhereInput[]
  }

  export type DistrictCreateNestedManyWithoutCityInput = {
    create?: XOR<DistrictCreateWithoutCityInput, DistrictUncheckedCreateWithoutCityInput> | DistrictCreateWithoutCityInput[] | DistrictUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DistrictCreateOrConnectWithoutCityInput | DistrictCreateOrConnectWithoutCityInput[]
    createMany?: DistrictCreateManyCityInputEnvelope
    connect?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
  }

  export type CalendarDistrictCreateNestedManyWithoutCityInput = {
    create?: XOR<CalendarDistrictCreateWithoutCityInput, CalendarDistrictUncheckedCreateWithoutCityInput> | CalendarDistrictCreateWithoutCityInput[] | CalendarDistrictUncheckedCreateWithoutCityInput[]
    connectOrCreate?: CalendarDistrictCreateOrConnectWithoutCityInput | CalendarDistrictCreateOrConnectWithoutCityInput[]
    createMany?: CalendarDistrictCreateManyCityInputEnvelope
    connect?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
  }

  export type DistrictUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<DistrictCreateWithoutCityInput, DistrictUncheckedCreateWithoutCityInput> | DistrictCreateWithoutCityInput[] | DistrictUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DistrictCreateOrConnectWithoutCityInput | DistrictCreateOrConnectWithoutCityInput[]
    createMany?: DistrictCreateManyCityInputEnvelope
    connect?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
  }

  export type CalendarDistrictUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<CalendarDistrictCreateWithoutCityInput, CalendarDistrictUncheckedCreateWithoutCityInput> | CalendarDistrictCreateWithoutCityInput[] | CalendarDistrictUncheckedCreateWithoutCityInput[]
    connectOrCreate?: CalendarDistrictCreateOrConnectWithoutCityInput | CalendarDistrictCreateOrConnectWithoutCityInput[]
    createMany?: CalendarDistrictCreateManyCityInputEnvelope
    connect?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
  }

  export type DistrictUpdateManyWithoutCityNestedInput = {
    create?: XOR<DistrictCreateWithoutCityInput, DistrictUncheckedCreateWithoutCityInput> | DistrictCreateWithoutCityInput[] | DistrictUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DistrictCreateOrConnectWithoutCityInput | DistrictCreateOrConnectWithoutCityInput[]
    upsert?: DistrictUpsertWithWhereUniqueWithoutCityInput | DistrictUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: DistrictCreateManyCityInputEnvelope
    set?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
    disconnect?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
    delete?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
    connect?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
    update?: DistrictUpdateWithWhereUniqueWithoutCityInput | DistrictUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: DistrictUpdateManyWithWhereWithoutCityInput | DistrictUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: DistrictScalarWhereInput | DistrictScalarWhereInput[]
  }

  export type CalendarDistrictUpdateManyWithoutCityNestedInput = {
    create?: XOR<CalendarDistrictCreateWithoutCityInput, CalendarDistrictUncheckedCreateWithoutCityInput> | CalendarDistrictCreateWithoutCityInput[] | CalendarDistrictUncheckedCreateWithoutCityInput[]
    connectOrCreate?: CalendarDistrictCreateOrConnectWithoutCityInput | CalendarDistrictCreateOrConnectWithoutCityInput[]
    upsert?: CalendarDistrictUpsertWithWhereUniqueWithoutCityInput | CalendarDistrictUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: CalendarDistrictCreateManyCityInputEnvelope
    set?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
    disconnect?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
    delete?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
    connect?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
    update?: CalendarDistrictUpdateWithWhereUniqueWithoutCityInput | CalendarDistrictUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: CalendarDistrictUpdateManyWithWhereWithoutCityInput | CalendarDistrictUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: CalendarDistrictScalarWhereInput | CalendarDistrictScalarWhereInput[]
  }

  export type DistrictUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<DistrictCreateWithoutCityInput, DistrictUncheckedCreateWithoutCityInput> | DistrictCreateWithoutCityInput[] | DistrictUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DistrictCreateOrConnectWithoutCityInput | DistrictCreateOrConnectWithoutCityInput[]
    upsert?: DistrictUpsertWithWhereUniqueWithoutCityInput | DistrictUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: DistrictCreateManyCityInputEnvelope
    set?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
    disconnect?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
    delete?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
    connect?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
    update?: DistrictUpdateWithWhereUniqueWithoutCityInput | DistrictUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: DistrictUpdateManyWithWhereWithoutCityInput | DistrictUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: DistrictScalarWhereInput | DistrictScalarWhereInput[]
  }

  export type CalendarDistrictUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<CalendarDistrictCreateWithoutCityInput, CalendarDistrictUncheckedCreateWithoutCityInput> | CalendarDistrictCreateWithoutCityInput[] | CalendarDistrictUncheckedCreateWithoutCityInput[]
    connectOrCreate?: CalendarDistrictCreateOrConnectWithoutCityInput | CalendarDistrictCreateOrConnectWithoutCityInput[]
    upsert?: CalendarDistrictUpsertWithWhereUniqueWithoutCityInput | CalendarDistrictUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: CalendarDistrictCreateManyCityInputEnvelope
    set?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
    disconnect?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
    delete?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
    connect?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
    update?: CalendarDistrictUpdateWithWhereUniqueWithoutCityInput | CalendarDistrictUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: CalendarDistrictUpdateManyWithWhereWithoutCityInput | CalendarDistrictUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: CalendarDistrictScalarWhereInput | CalendarDistrictScalarWhereInput[]
  }

  export type CityCreateNestedOneWithoutDistrictsInput = {
    create?: XOR<CityCreateWithoutDistrictsInput, CityUncheckedCreateWithoutDistrictsInput>
    connectOrCreate?: CityCreateOrConnectWithoutDistrictsInput
    connect?: CityWhereUniqueInput
  }

  export type CalendarDistrictCreateNestedManyWithoutDistrictInput = {
    create?: XOR<CalendarDistrictCreateWithoutDistrictInput, CalendarDistrictUncheckedCreateWithoutDistrictInput> | CalendarDistrictCreateWithoutDistrictInput[] | CalendarDistrictUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: CalendarDistrictCreateOrConnectWithoutDistrictInput | CalendarDistrictCreateOrConnectWithoutDistrictInput[]
    createMany?: CalendarDistrictCreateManyDistrictInputEnvelope
    connect?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
  }

  export type CalendarDistrictUncheckedCreateNestedManyWithoutDistrictInput = {
    create?: XOR<CalendarDistrictCreateWithoutDistrictInput, CalendarDistrictUncheckedCreateWithoutDistrictInput> | CalendarDistrictCreateWithoutDistrictInput[] | CalendarDistrictUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: CalendarDistrictCreateOrConnectWithoutDistrictInput | CalendarDistrictCreateOrConnectWithoutDistrictInput[]
    createMany?: CalendarDistrictCreateManyDistrictInputEnvelope
    connect?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
  }

  export type CityUpdateOneRequiredWithoutDistrictsNestedInput = {
    create?: XOR<CityCreateWithoutDistrictsInput, CityUncheckedCreateWithoutDistrictsInput>
    connectOrCreate?: CityCreateOrConnectWithoutDistrictsInput
    upsert?: CityUpsertWithoutDistrictsInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutDistrictsInput, CityUpdateWithoutDistrictsInput>, CityUncheckedUpdateWithoutDistrictsInput>
  }

  export type CalendarDistrictUpdateManyWithoutDistrictNestedInput = {
    create?: XOR<CalendarDistrictCreateWithoutDistrictInput, CalendarDistrictUncheckedCreateWithoutDistrictInput> | CalendarDistrictCreateWithoutDistrictInput[] | CalendarDistrictUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: CalendarDistrictCreateOrConnectWithoutDistrictInput | CalendarDistrictCreateOrConnectWithoutDistrictInput[]
    upsert?: CalendarDistrictUpsertWithWhereUniqueWithoutDistrictInput | CalendarDistrictUpsertWithWhereUniqueWithoutDistrictInput[]
    createMany?: CalendarDistrictCreateManyDistrictInputEnvelope
    set?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
    disconnect?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
    delete?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
    connect?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
    update?: CalendarDistrictUpdateWithWhereUniqueWithoutDistrictInput | CalendarDistrictUpdateWithWhereUniqueWithoutDistrictInput[]
    updateMany?: CalendarDistrictUpdateManyWithWhereWithoutDistrictInput | CalendarDistrictUpdateManyWithWhereWithoutDistrictInput[]
    deleteMany?: CalendarDistrictScalarWhereInput | CalendarDistrictScalarWhereInput[]
  }

  export type CalendarDistrictUncheckedUpdateManyWithoutDistrictNestedInput = {
    create?: XOR<CalendarDistrictCreateWithoutDistrictInput, CalendarDistrictUncheckedCreateWithoutDistrictInput> | CalendarDistrictCreateWithoutDistrictInput[] | CalendarDistrictUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: CalendarDistrictCreateOrConnectWithoutDistrictInput | CalendarDistrictCreateOrConnectWithoutDistrictInput[]
    upsert?: CalendarDistrictUpsertWithWhereUniqueWithoutDistrictInput | CalendarDistrictUpsertWithWhereUniqueWithoutDistrictInput[]
    createMany?: CalendarDistrictCreateManyDistrictInputEnvelope
    set?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
    disconnect?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
    delete?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
    connect?: CalendarDistrictWhereUniqueInput | CalendarDistrictWhereUniqueInput[]
    update?: CalendarDistrictUpdateWithWhereUniqueWithoutDistrictInput | CalendarDistrictUpdateWithWhereUniqueWithoutDistrictInput[]
    updateMany?: CalendarDistrictUpdateManyWithWhereWithoutDistrictInput | CalendarDistrictUpdateManyWithWhereWithoutDistrictInput[]
    deleteMany?: CalendarDistrictScalarWhereInput | CalendarDistrictScalarWhereInput[]
  }

  export type CalendarCreateNestedOneWithoutDistrictsInput = {
    create?: XOR<CalendarCreateWithoutDistrictsInput, CalendarUncheckedCreateWithoutDistrictsInput>
    connectOrCreate?: CalendarCreateOrConnectWithoutDistrictsInput
    connect?: CalendarWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutCalendarDistrictsInput = {
    create?: XOR<CityCreateWithoutCalendarDistrictsInput, CityUncheckedCreateWithoutCalendarDistrictsInput>
    connectOrCreate?: CityCreateOrConnectWithoutCalendarDistrictsInput
    connect?: CityWhereUniqueInput
  }

  export type DistrictCreateNestedOneWithoutCalendarDistrictsInput = {
    create?: XOR<DistrictCreateWithoutCalendarDistrictsInput, DistrictUncheckedCreateWithoutCalendarDistrictsInput>
    connectOrCreate?: DistrictCreateOrConnectWithoutCalendarDistrictsInput
    connect?: DistrictWhereUniqueInput
  }

  export type CalendarUpdateOneRequiredWithoutDistrictsNestedInput = {
    create?: XOR<CalendarCreateWithoutDistrictsInput, CalendarUncheckedCreateWithoutDistrictsInput>
    connectOrCreate?: CalendarCreateOrConnectWithoutDistrictsInput
    upsert?: CalendarUpsertWithoutDistrictsInput
    connect?: CalendarWhereUniqueInput
    update?: XOR<XOR<CalendarUpdateToOneWithWhereWithoutDistrictsInput, CalendarUpdateWithoutDistrictsInput>, CalendarUncheckedUpdateWithoutDistrictsInput>
  }

  export type CityUpdateOneRequiredWithoutCalendarDistrictsNestedInput = {
    create?: XOR<CityCreateWithoutCalendarDistrictsInput, CityUncheckedCreateWithoutCalendarDistrictsInput>
    connectOrCreate?: CityCreateOrConnectWithoutCalendarDistrictsInput
    upsert?: CityUpsertWithoutCalendarDistrictsInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutCalendarDistrictsInput, CityUpdateWithoutCalendarDistrictsInput>, CityUncheckedUpdateWithoutCalendarDistrictsInput>
  }

  export type DistrictUpdateOneRequiredWithoutCalendarDistrictsNestedInput = {
    create?: XOR<DistrictCreateWithoutCalendarDistrictsInput, DistrictUncheckedCreateWithoutCalendarDistrictsInput>
    connectOrCreate?: DistrictCreateOrConnectWithoutCalendarDistrictsInput
    upsert?: DistrictUpsertWithoutCalendarDistrictsInput
    connect?: DistrictWhereUniqueInput
    update?: XOR<XOR<DistrictUpdateToOneWithWhereWithoutCalendarDistrictsInput, DistrictUpdateWithoutCalendarDistrictsInput>, DistrictUncheckedUpdateWithoutCalendarDistrictsInput>
  }

  export type CalendarCreateNestedOneWithoutStagesInput = {
    create?: XOR<CalendarCreateWithoutStagesInput, CalendarUncheckedCreateWithoutStagesInput>
    connectOrCreate?: CalendarCreateOrConnectWithoutStagesInput
    connect?: CalendarWhereUniqueInput
  }

  export type StageThresholdCreateNestedManyWithoutStageInput = {
    create?: XOR<StageThresholdCreateWithoutStageInput, StageThresholdUncheckedCreateWithoutStageInput> | StageThresholdCreateWithoutStageInput[] | StageThresholdUncheckedCreateWithoutStageInput[]
    connectOrCreate?: StageThresholdCreateOrConnectWithoutStageInput | StageThresholdCreateOrConnectWithoutStageInput[]
    createMany?: StageThresholdCreateManyStageInputEnvelope
    connect?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
  }

  export type StageAlbumCreateNestedManyWithoutStageInput = {
    create?: XOR<StageAlbumCreateWithoutStageInput, StageAlbumUncheckedCreateWithoutStageInput> | StageAlbumCreateWithoutStageInput[] | StageAlbumUncheckedCreateWithoutStageInput[]
    connectOrCreate?: StageAlbumCreateOrConnectWithoutStageInput | StageAlbumCreateOrConnectWithoutStageInput[]
    createMany?: StageAlbumCreateManyStageInputEnvelope
    connect?: StageAlbumWhereUniqueInput | StageAlbumWhereUniqueInput[]
  }

  export type StageThresholdUncheckedCreateNestedManyWithoutStageInput = {
    create?: XOR<StageThresholdCreateWithoutStageInput, StageThresholdUncheckedCreateWithoutStageInput> | StageThresholdCreateWithoutStageInput[] | StageThresholdUncheckedCreateWithoutStageInput[]
    connectOrCreate?: StageThresholdCreateOrConnectWithoutStageInput | StageThresholdCreateOrConnectWithoutStageInput[]
    createMany?: StageThresholdCreateManyStageInputEnvelope
    connect?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
  }

  export type StageAlbumUncheckedCreateNestedManyWithoutStageInput = {
    create?: XOR<StageAlbumCreateWithoutStageInput, StageAlbumUncheckedCreateWithoutStageInput> | StageAlbumCreateWithoutStageInput[] | StageAlbumUncheckedCreateWithoutStageInput[]
    connectOrCreate?: StageAlbumCreateOrConnectWithoutStageInput | StageAlbumCreateOrConnectWithoutStageInput[]
    createMany?: StageAlbumCreateManyStageInputEnvelope
    connect?: StageAlbumWhereUniqueInput | StageAlbumWhereUniqueInput[]
  }

  export type NullableEnumDecadeFieldUpdateOperationsInput = {
    set?: $Enums.Decade | null
  }

  export type EnumStageStatusFieldUpdateOperationsInput = {
    set?: $Enums.StageStatus
  }

  export type CalendarUpdateOneRequiredWithoutStagesNestedInput = {
    create?: XOR<CalendarCreateWithoutStagesInput, CalendarUncheckedCreateWithoutStagesInput>
    connectOrCreate?: CalendarCreateOrConnectWithoutStagesInput
    upsert?: CalendarUpsertWithoutStagesInput
    connect?: CalendarWhereUniqueInput
    update?: XOR<XOR<CalendarUpdateToOneWithWhereWithoutStagesInput, CalendarUpdateWithoutStagesInput>, CalendarUncheckedUpdateWithoutStagesInput>
  }

  export type StageThresholdUpdateManyWithoutStageNestedInput = {
    create?: XOR<StageThresholdCreateWithoutStageInput, StageThresholdUncheckedCreateWithoutStageInput> | StageThresholdCreateWithoutStageInput[] | StageThresholdUncheckedCreateWithoutStageInput[]
    connectOrCreate?: StageThresholdCreateOrConnectWithoutStageInput | StageThresholdCreateOrConnectWithoutStageInput[]
    upsert?: StageThresholdUpsertWithWhereUniqueWithoutStageInput | StageThresholdUpsertWithWhereUniqueWithoutStageInput[]
    createMany?: StageThresholdCreateManyStageInputEnvelope
    set?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    disconnect?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    delete?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    connect?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    update?: StageThresholdUpdateWithWhereUniqueWithoutStageInput | StageThresholdUpdateWithWhereUniqueWithoutStageInput[]
    updateMany?: StageThresholdUpdateManyWithWhereWithoutStageInput | StageThresholdUpdateManyWithWhereWithoutStageInput[]
    deleteMany?: StageThresholdScalarWhereInput | StageThresholdScalarWhereInput[]
  }

  export type StageAlbumUpdateManyWithoutStageNestedInput = {
    create?: XOR<StageAlbumCreateWithoutStageInput, StageAlbumUncheckedCreateWithoutStageInput> | StageAlbumCreateWithoutStageInput[] | StageAlbumUncheckedCreateWithoutStageInput[]
    connectOrCreate?: StageAlbumCreateOrConnectWithoutStageInput | StageAlbumCreateOrConnectWithoutStageInput[]
    upsert?: StageAlbumUpsertWithWhereUniqueWithoutStageInput | StageAlbumUpsertWithWhereUniqueWithoutStageInput[]
    createMany?: StageAlbumCreateManyStageInputEnvelope
    set?: StageAlbumWhereUniqueInput | StageAlbumWhereUniqueInput[]
    disconnect?: StageAlbumWhereUniqueInput | StageAlbumWhereUniqueInput[]
    delete?: StageAlbumWhereUniqueInput | StageAlbumWhereUniqueInput[]
    connect?: StageAlbumWhereUniqueInput | StageAlbumWhereUniqueInput[]
    update?: StageAlbumUpdateWithWhereUniqueWithoutStageInput | StageAlbumUpdateWithWhereUniqueWithoutStageInput[]
    updateMany?: StageAlbumUpdateManyWithWhereWithoutStageInput | StageAlbumUpdateManyWithWhereWithoutStageInput[]
    deleteMany?: StageAlbumScalarWhereInput | StageAlbumScalarWhereInput[]
  }

  export type StageThresholdUncheckedUpdateManyWithoutStageNestedInput = {
    create?: XOR<StageThresholdCreateWithoutStageInput, StageThresholdUncheckedCreateWithoutStageInput> | StageThresholdCreateWithoutStageInput[] | StageThresholdUncheckedCreateWithoutStageInput[]
    connectOrCreate?: StageThresholdCreateOrConnectWithoutStageInput | StageThresholdCreateOrConnectWithoutStageInput[]
    upsert?: StageThresholdUpsertWithWhereUniqueWithoutStageInput | StageThresholdUpsertWithWhereUniqueWithoutStageInput[]
    createMany?: StageThresholdCreateManyStageInputEnvelope
    set?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    disconnect?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    delete?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    connect?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    update?: StageThresholdUpdateWithWhereUniqueWithoutStageInput | StageThresholdUpdateWithWhereUniqueWithoutStageInput[]
    updateMany?: StageThresholdUpdateManyWithWhereWithoutStageInput | StageThresholdUpdateManyWithWhereWithoutStageInput[]
    deleteMany?: StageThresholdScalarWhereInput | StageThresholdScalarWhereInput[]
  }

  export type StageAlbumUncheckedUpdateManyWithoutStageNestedInput = {
    create?: XOR<StageAlbumCreateWithoutStageInput, StageAlbumUncheckedCreateWithoutStageInput> | StageAlbumCreateWithoutStageInput[] | StageAlbumUncheckedCreateWithoutStageInput[]
    connectOrCreate?: StageAlbumCreateOrConnectWithoutStageInput | StageAlbumCreateOrConnectWithoutStageInput[]
    upsert?: StageAlbumUpsertWithWhereUniqueWithoutStageInput | StageAlbumUpsertWithWhereUniqueWithoutStageInput[]
    createMany?: StageAlbumCreateManyStageInputEnvelope
    set?: StageAlbumWhereUniqueInput | StageAlbumWhereUniqueInput[]
    disconnect?: StageAlbumWhereUniqueInput | StageAlbumWhereUniqueInput[]
    delete?: StageAlbumWhereUniqueInput | StageAlbumWhereUniqueInput[]
    connect?: StageAlbumWhereUniqueInput | StageAlbumWhereUniqueInput[]
    update?: StageAlbumUpdateWithWhereUniqueWithoutStageInput | StageAlbumUpdateWithWhereUniqueWithoutStageInput[]
    updateMany?: StageAlbumUpdateManyWithWhereWithoutStageInput | StageAlbumUpdateManyWithWhereWithoutStageInput[]
    deleteMany?: StageAlbumScalarWhereInput | StageAlbumScalarWhereInput[]
  }

  export type StageCreateNestedOneWithoutAlbumsInput = {
    create?: XOR<StageCreateWithoutAlbumsInput, StageUncheckedCreateWithoutAlbumsInput>
    connectOrCreate?: StageCreateOrConnectWithoutAlbumsInput
    connect?: StageWhereUniqueInput
  }

  export type StageUpdateOneRequiredWithoutAlbumsNestedInput = {
    create?: XOR<StageCreateWithoutAlbumsInput, StageUncheckedCreateWithoutAlbumsInput>
    connectOrCreate?: StageCreateOrConnectWithoutAlbumsInput
    upsert?: StageUpsertWithoutAlbumsInput
    connect?: StageWhereUniqueInput
    update?: XOR<XOR<StageUpdateToOneWithWhereWithoutAlbumsInput, StageUpdateWithoutAlbumsInput>, StageUncheckedUpdateWithoutAlbumsInput>
  }

  export type StageCreateNestedOneWithoutThresholdsInput = {
    create?: XOR<StageCreateWithoutThresholdsInput, StageUncheckedCreateWithoutThresholdsInput>
    connectOrCreate?: StageCreateOrConnectWithoutThresholdsInput
    connect?: StageWhereUniqueInput
  }

  export type IndicatorCreateNestedOneWithoutThresholdsInput = {
    create?: XOR<IndicatorCreateWithoutThresholdsInput, IndicatorUncheckedCreateWithoutThresholdsInput>
    connectOrCreate?: IndicatorCreateOrConnectWithoutThresholdsInput
    connect?: IndicatorWhereUniqueInput
  }

  export type EnumThresholdOperatorFieldUpdateOperationsInput = {
    set?: $Enums.ThresholdOperator
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StageUpdateOneRequiredWithoutThresholdsNestedInput = {
    create?: XOR<StageCreateWithoutThresholdsInput, StageUncheckedCreateWithoutThresholdsInput>
    connectOrCreate?: StageCreateOrConnectWithoutThresholdsInput
    upsert?: StageUpsertWithoutThresholdsInput
    connect?: StageWhereUniqueInput
    update?: XOR<XOR<StageUpdateToOneWithWhereWithoutThresholdsInput, StageUpdateWithoutThresholdsInput>, StageUncheckedUpdateWithoutThresholdsInput>
  }

  export type IndicatorUpdateOneRequiredWithoutThresholdsNestedInput = {
    create?: XOR<IndicatorCreateWithoutThresholdsInput, IndicatorUncheckedCreateWithoutThresholdsInput>
    connectOrCreate?: IndicatorCreateOrConnectWithoutThresholdsInput
    upsert?: IndicatorUpsertWithoutThresholdsInput
    connect?: IndicatorWhereUniqueInput
    update?: XOR<XOR<IndicatorUpdateToOneWithWhereWithoutThresholdsInput, IndicatorUpdateWithoutThresholdsInput>, IndicatorUncheckedUpdateWithoutThresholdsInput>
  }

  export type IndicatorCreateNestedManyWithoutCategoryInput = {
    create?: XOR<IndicatorCreateWithoutCategoryInput, IndicatorUncheckedCreateWithoutCategoryInput> | IndicatorCreateWithoutCategoryInput[] | IndicatorUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: IndicatorCreateOrConnectWithoutCategoryInput | IndicatorCreateOrConnectWithoutCategoryInput[]
    createMany?: IndicatorCreateManyCategoryInputEnvelope
    connect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
  }

  export type IndicatorUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<IndicatorCreateWithoutCategoryInput, IndicatorUncheckedCreateWithoutCategoryInput> | IndicatorCreateWithoutCategoryInput[] | IndicatorUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: IndicatorCreateOrConnectWithoutCategoryInput | IndicatorCreateOrConnectWithoutCategoryInput[]
    createMany?: IndicatorCreateManyCategoryInputEnvelope
    connect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
  }

  export type IndicatorUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<IndicatorCreateWithoutCategoryInput, IndicatorUncheckedCreateWithoutCategoryInput> | IndicatorCreateWithoutCategoryInput[] | IndicatorUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: IndicatorCreateOrConnectWithoutCategoryInput | IndicatorCreateOrConnectWithoutCategoryInput[]
    upsert?: IndicatorUpsertWithWhereUniqueWithoutCategoryInput | IndicatorUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: IndicatorCreateManyCategoryInputEnvelope
    set?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    disconnect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    delete?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    connect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    update?: IndicatorUpdateWithWhereUniqueWithoutCategoryInput | IndicatorUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: IndicatorUpdateManyWithWhereWithoutCategoryInput | IndicatorUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: IndicatorScalarWhereInput | IndicatorScalarWhereInput[]
  }

  export type IndicatorUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<IndicatorCreateWithoutCategoryInput, IndicatorUncheckedCreateWithoutCategoryInput> | IndicatorCreateWithoutCategoryInput[] | IndicatorUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: IndicatorCreateOrConnectWithoutCategoryInput | IndicatorCreateOrConnectWithoutCategoryInput[]
    upsert?: IndicatorUpsertWithWhereUniqueWithoutCategoryInput | IndicatorUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: IndicatorCreateManyCategoryInputEnvelope
    set?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    disconnect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    delete?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    connect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    update?: IndicatorUpdateWithWhereUniqueWithoutCategoryInput | IndicatorUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: IndicatorUpdateManyWithWhereWithoutCategoryInput | IndicatorUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: IndicatorScalarWhereInput | IndicatorScalarWhereInput[]
  }

  export type IndicatorCategoryCreateNestedOneWithoutIndicatorsInput = {
    create?: XOR<IndicatorCategoryCreateWithoutIndicatorsInput, IndicatorCategoryUncheckedCreateWithoutIndicatorsInput>
    connectOrCreate?: IndicatorCategoryCreateOrConnectWithoutIndicatorsInput
    connect?: IndicatorCategoryWhereUniqueInput
  }

  export type StageThresholdCreateNestedManyWithoutIndicatorInput = {
    create?: XOR<StageThresholdCreateWithoutIndicatorInput, StageThresholdUncheckedCreateWithoutIndicatorInput> | StageThresholdCreateWithoutIndicatorInput[] | StageThresholdUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: StageThresholdCreateOrConnectWithoutIndicatorInput | StageThresholdCreateOrConnectWithoutIndicatorInput[]
    createMany?: StageThresholdCreateManyIndicatorInputEnvelope
    connect?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
  }

  export type StageThresholdUncheckedCreateNestedManyWithoutIndicatorInput = {
    create?: XOR<StageThresholdCreateWithoutIndicatorInput, StageThresholdUncheckedCreateWithoutIndicatorInput> | StageThresholdCreateWithoutIndicatorInput[] | StageThresholdUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: StageThresholdCreateOrConnectWithoutIndicatorInput | StageThresholdCreateOrConnectWithoutIndicatorInput[]
    createMany?: StageThresholdCreateManyIndicatorInputEnvelope
    connect?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
  }

  export type IndicatorCategoryUpdateOneRequiredWithoutIndicatorsNestedInput = {
    create?: XOR<IndicatorCategoryCreateWithoutIndicatorsInput, IndicatorCategoryUncheckedCreateWithoutIndicatorsInput>
    connectOrCreate?: IndicatorCategoryCreateOrConnectWithoutIndicatorsInput
    upsert?: IndicatorCategoryUpsertWithoutIndicatorsInput
    connect?: IndicatorCategoryWhereUniqueInput
    update?: XOR<XOR<IndicatorCategoryUpdateToOneWithWhereWithoutIndicatorsInput, IndicatorCategoryUpdateWithoutIndicatorsInput>, IndicatorCategoryUncheckedUpdateWithoutIndicatorsInput>
  }

  export type StageThresholdUpdateManyWithoutIndicatorNestedInput = {
    create?: XOR<StageThresholdCreateWithoutIndicatorInput, StageThresholdUncheckedCreateWithoutIndicatorInput> | StageThresholdCreateWithoutIndicatorInput[] | StageThresholdUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: StageThresholdCreateOrConnectWithoutIndicatorInput | StageThresholdCreateOrConnectWithoutIndicatorInput[]
    upsert?: StageThresholdUpsertWithWhereUniqueWithoutIndicatorInput | StageThresholdUpsertWithWhereUniqueWithoutIndicatorInput[]
    createMany?: StageThresholdCreateManyIndicatorInputEnvelope
    set?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    disconnect?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    delete?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    connect?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    update?: StageThresholdUpdateWithWhereUniqueWithoutIndicatorInput | StageThresholdUpdateWithWhereUniqueWithoutIndicatorInput[]
    updateMany?: StageThresholdUpdateManyWithWhereWithoutIndicatorInput | StageThresholdUpdateManyWithWhereWithoutIndicatorInput[]
    deleteMany?: StageThresholdScalarWhereInput | StageThresholdScalarWhereInput[]
  }

  export type StageThresholdUncheckedUpdateManyWithoutIndicatorNestedInput = {
    create?: XOR<StageThresholdCreateWithoutIndicatorInput, StageThresholdUncheckedCreateWithoutIndicatorInput> | StageThresholdCreateWithoutIndicatorInput[] | StageThresholdUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: StageThresholdCreateOrConnectWithoutIndicatorInput | StageThresholdCreateOrConnectWithoutIndicatorInput[]
    upsert?: StageThresholdUpsertWithWhereUniqueWithoutIndicatorInput | StageThresholdUpsertWithWhereUniqueWithoutIndicatorInput[]
    createMany?: StageThresholdCreateManyIndicatorInputEnvelope
    set?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    disconnect?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    delete?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    connect?: StageThresholdWhereUniqueInput | StageThresholdWhereUniqueInput[]
    update?: StageThresholdUpdateWithWhereUniqueWithoutIndicatorInput | StageThresholdUpdateWithWhereUniqueWithoutIndicatorInput[]
    updateMany?: StageThresholdUpdateManyWithWhereWithoutIndicatorInput | StageThresholdUpdateManyWithWhereWithoutIndicatorInput[]
    deleteMany?: StageThresholdScalarWhereInput | StageThresholdScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumCalendarFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CalendarFileType | EnumCalendarFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CalendarFileType[] | ListEnumCalendarFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalendarFileType[] | ListEnumCalendarFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCalendarFileTypeFilter<$PrismaModel> | $Enums.CalendarFileType
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumCalendarFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CalendarFileType | EnumCalendarFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CalendarFileType[] | ListEnumCalendarFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalendarFileType[] | ListEnumCalendarFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCalendarFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.CalendarFileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCalendarFileTypeFilter<$PrismaModel>
    _max?: NestedEnumCalendarFileTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumDecadeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Decade | EnumDecadeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Decade[] | ListEnumDecadeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Decade[] | ListEnumDecadeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDecadeNullableFilter<$PrismaModel> | $Enums.Decade | null
  }

  export type NestedEnumStageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StageStatus | EnumStageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StageStatus[] | ListEnumStageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StageStatus[] | ListEnumStageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStageStatusFilter<$PrismaModel> | $Enums.StageStatus
  }

  export type NestedEnumDecadeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Decade | EnumDecadeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Decade[] | ListEnumDecadeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Decade[] | ListEnumDecadeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDecadeNullableWithAggregatesFilter<$PrismaModel> | $Enums.Decade | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDecadeNullableFilter<$PrismaModel>
    _max?: NestedEnumDecadeNullableFilter<$PrismaModel>
  }

  export type NestedEnumStageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StageStatus | EnumStageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StageStatus[] | ListEnumStageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StageStatus[] | ListEnumStageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStageStatusWithAggregatesFilter<$PrismaModel> | $Enums.StageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStageStatusFilter<$PrismaModel>
    _max?: NestedEnumStageStatusFilter<$PrismaModel>
  }

  export type NestedEnumThresholdOperatorFilter<$PrismaModel = never> = {
    equals?: $Enums.ThresholdOperator | EnumThresholdOperatorFieldRefInput<$PrismaModel>
    in?: $Enums.ThresholdOperator[] | ListEnumThresholdOperatorFieldRefInput<$PrismaModel>
    notIn?: $Enums.ThresholdOperator[] | ListEnumThresholdOperatorFieldRefInput<$PrismaModel>
    not?: NestedEnumThresholdOperatorFilter<$PrismaModel> | $Enums.ThresholdOperator
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumThresholdOperatorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ThresholdOperator | EnumThresholdOperatorFieldRefInput<$PrismaModel>
    in?: $Enums.ThresholdOperator[] | ListEnumThresholdOperatorFieldRefInput<$PrismaModel>
    notIn?: $Enums.ThresholdOperator[] | ListEnumThresholdOperatorFieldRefInput<$PrismaModel>
    not?: NestedEnumThresholdOperatorWithAggregatesFilter<$PrismaModel> | $Enums.ThresholdOperator
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumThresholdOperatorFilter<$PrismaModel>
    _max?: NestedEnumThresholdOperatorFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type CalendarCreateWithoutCropInput = {
    id?: string
    title: string
    zoneName?: string
    isShared?: boolean
    isPublished?: boolean
    fileType?: $Enums.CalendarFileType
    allowCenterUse?: boolean
    sharedAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: CreatorCreateNestedOneWithoutCalendarsInput
    sourceCalendar?: CalendarCreateNestedOneWithoutCopyInput
    copy?: CalendarCreateNestedOneWithoutSourceCalendarInput
    stages?: StageCreateNestedManyWithoutCalendarInput
    districts?: CalendarDistrictCreateNestedManyWithoutCalendarInput
  }

  export type CalendarUncheckedCreateWithoutCropInput = {
    id?: string
    creatorId: string
    sourceCalendarId?: string | null
    title: string
    zoneName?: string
    isShared?: boolean
    isPublished?: boolean
    fileType?: $Enums.CalendarFileType
    allowCenterUse?: boolean
    sharedAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    copy?: CalendarUncheckedCreateNestedOneWithoutSourceCalendarInput
    stages?: StageUncheckedCreateNestedManyWithoutCalendarInput
    districts?: CalendarDistrictUncheckedCreateNestedManyWithoutCalendarInput
  }

  export type CalendarCreateOrConnectWithoutCropInput = {
    where: CalendarWhereUniqueInput
    create: XOR<CalendarCreateWithoutCropInput, CalendarUncheckedCreateWithoutCropInput>
  }

  export type CalendarCreateManyCropInputEnvelope = {
    data: CalendarCreateManyCropInput | CalendarCreateManyCropInput[]
    skipDuplicates?: boolean
  }

  export type CalendarUpsertWithWhereUniqueWithoutCropInput = {
    where: CalendarWhereUniqueInput
    update: XOR<CalendarUpdateWithoutCropInput, CalendarUncheckedUpdateWithoutCropInput>
    create: XOR<CalendarCreateWithoutCropInput, CalendarUncheckedCreateWithoutCropInput>
  }

  export type CalendarUpdateWithWhereUniqueWithoutCropInput = {
    where: CalendarWhereUniqueInput
    data: XOR<CalendarUpdateWithoutCropInput, CalendarUncheckedUpdateWithoutCropInput>
  }

  export type CalendarUpdateManyWithWhereWithoutCropInput = {
    where: CalendarScalarWhereInput
    data: XOR<CalendarUpdateManyMutationInput, CalendarUncheckedUpdateManyWithoutCropInput>
  }

  export type CalendarScalarWhereInput = {
    AND?: CalendarScalarWhereInput | CalendarScalarWhereInput[]
    OR?: CalendarScalarWhereInput[]
    NOT?: CalendarScalarWhereInput | CalendarScalarWhereInput[]
    id?: StringFilter<"Calendar"> | string
    cropId?: StringFilter<"Calendar"> | string
    creatorId?: StringFilter<"Calendar"> | string
    sourceCalendarId?: StringNullableFilter<"Calendar"> | string | null
    title?: StringFilter<"Calendar"> | string
    zoneName?: StringFilter<"Calendar"> | string
    isShared?: BoolFilter<"Calendar"> | boolean
    isPublished?: BoolFilter<"Calendar"> | boolean
    fileType?: EnumCalendarFileTypeFilter<"Calendar"> | $Enums.CalendarFileType
    allowCenterUse?: BoolFilter<"Calendar"> | boolean
    sharedAt?: DateTimeNullableFilter<"Calendar"> | Date | string | null
    publishedAt?: DateTimeNullableFilter<"Calendar"> | Date | string | null
    createdAt?: DateTimeFilter<"Calendar"> | Date | string
    updatedAt?: DateTimeFilter<"Calendar"> | Date | string
  }

  export type CalendarCreateWithoutCreatorInput = {
    id?: string
    title: string
    zoneName?: string
    isShared?: boolean
    isPublished?: boolean
    fileType?: $Enums.CalendarFileType
    allowCenterUse?: boolean
    sharedAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    crop: CropCreateNestedOneWithoutCalendarsInput
    sourceCalendar?: CalendarCreateNestedOneWithoutCopyInput
    copy?: CalendarCreateNestedOneWithoutSourceCalendarInput
    stages?: StageCreateNestedManyWithoutCalendarInput
    districts?: CalendarDistrictCreateNestedManyWithoutCalendarInput
  }

  export type CalendarUncheckedCreateWithoutCreatorInput = {
    id?: string
    cropId: string
    sourceCalendarId?: string | null
    title: string
    zoneName?: string
    isShared?: boolean
    isPublished?: boolean
    fileType?: $Enums.CalendarFileType
    allowCenterUse?: boolean
    sharedAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    copy?: CalendarUncheckedCreateNestedOneWithoutSourceCalendarInput
    stages?: StageUncheckedCreateNestedManyWithoutCalendarInput
    districts?: CalendarDistrictUncheckedCreateNestedManyWithoutCalendarInput
  }

  export type CalendarCreateOrConnectWithoutCreatorInput = {
    where: CalendarWhereUniqueInput
    create: XOR<CalendarCreateWithoutCreatorInput, CalendarUncheckedCreateWithoutCreatorInput>
  }

  export type CalendarCreateManyCreatorInputEnvelope = {
    data: CalendarCreateManyCreatorInput | CalendarCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type CalendarUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CalendarWhereUniqueInput
    update: XOR<CalendarUpdateWithoutCreatorInput, CalendarUncheckedUpdateWithoutCreatorInput>
    create: XOR<CalendarCreateWithoutCreatorInput, CalendarUncheckedCreateWithoutCreatorInput>
  }

  export type CalendarUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CalendarWhereUniqueInput
    data: XOR<CalendarUpdateWithoutCreatorInput, CalendarUncheckedUpdateWithoutCreatorInput>
  }

  export type CalendarUpdateManyWithWhereWithoutCreatorInput = {
    where: CalendarScalarWhereInput
    data: XOR<CalendarUpdateManyMutationInput, CalendarUncheckedUpdateManyWithoutCreatorInput>
  }

  export type CropCreateWithoutCalendarsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CropUncheckedCreateWithoutCalendarsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CropCreateOrConnectWithoutCalendarsInput = {
    where: CropWhereUniqueInput
    create: XOR<CropCreateWithoutCalendarsInput, CropUncheckedCreateWithoutCalendarsInput>
  }

  export type CreatorCreateWithoutCalendarsInput = {
    id?: string
    name: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreatorUncheckedCreateWithoutCalendarsInput = {
    id?: string
    name: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreatorCreateOrConnectWithoutCalendarsInput = {
    where: CreatorWhereUniqueInput
    create: XOR<CreatorCreateWithoutCalendarsInput, CreatorUncheckedCreateWithoutCalendarsInput>
  }

  export type CalendarCreateWithoutCopyInput = {
    id?: string
    title: string
    zoneName?: string
    isShared?: boolean
    isPublished?: boolean
    fileType?: $Enums.CalendarFileType
    allowCenterUse?: boolean
    sharedAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    crop: CropCreateNestedOneWithoutCalendarsInput
    creator: CreatorCreateNestedOneWithoutCalendarsInput
    sourceCalendar?: CalendarCreateNestedOneWithoutCopyInput
    stages?: StageCreateNestedManyWithoutCalendarInput
    districts?: CalendarDistrictCreateNestedManyWithoutCalendarInput
  }

  export type CalendarUncheckedCreateWithoutCopyInput = {
    id?: string
    cropId: string
    creatorId: string
    sourceCalendarId?: string | null
    title: string
    zoneName?: string
    isShared?: boolean
    isPublished?: boolean
    fileType?: $Enums.CalendarFileType
    allowCenterUse?: boolean
    sharedAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stages?: StageUncheckedCreateNestedManyWithoutCalendarInput
    districts?: CalendarDistrictUncheckedCreateNestedManyWithoutCalendarInput
  }

  export type CalendarCreateOrConnectWithoutCopyInput = {
    where: CalendarWhereUniqueInput
    create: XOR<CalendarCreateWithoutCopyInput, CalendarUncheckedCreateWithoutCopyInput>
  }

  export type CalendarCreateWithoutSourceCalendarInput = {
    id?: string
    title: string
    zoneName?: string
    isShared?: boolean
    isPublished?: boolean
    fileType?: $Enums.CalendarFileType
    allowCenterUse?: boolean
    sharedAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    crop: CropCreateNestedOneWithoutCalendarsInput
    creator: CreatorCreateNestedOneWithoutCalendarsInput
    copy?: CalendarCreateNestedOneWithoutSourceCalendarInput
    stages?: StageCreateNestedManyWithoutCalendarInput
    districts?: CalendarDistrictCreateNestedManyWithoutCalendarInput
  }

  export type CalendarUncheckedCreateWithoutSourceCalendarInput = {
    id?: string
    cropId: string
    creatorId: string
    title: string
    zoneName?: string
    isShared?: boolean
    isPublished?: boolean
    fileType?: $Enums.CalendarFileType
    allowCenterUse?: boolean
    sharedAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    copy?: CalendarUncheckedCreateNestedOneWithoutSourceCalendarInput
    stages?: StageUncheckedCreateNestedManyWithoutCalendarInput
    districts?: CalendarDistrictUncheckedCreateNestedManyWithoutCalendarInput
  }

  export type CalendarCreateOrConnectWithoutSourceCalendarInput = {
    where: CalendarWhereUniqueInput
    create: XOR<CalendarCreateWithoutSourceCalendarInput, CalendarUncheckedCreateWithoutSourceCalendarInput>
  }

  export type StageCreateWithoutCalendarInput = {
    id?: string
    name: string
    description?: string | null
    startMonth?: string | null
    startDecade?: $Enums.Decade | null
    endMonth?: string | null
    endDecade?: $Enums.Decade | null
    color?: string
    status?: $Enums.StageStatus
    coverUrl?: string | null
    coverName?: string | null
    coverThumbnail?: string | null
    coverSource?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    thresholds?: StageThresholdCreateNestedManyWithoutStageInput
    albums?: StageAlbumCreateNestedManyWithoutStageInput
  }

  export type StageUncheckedCreateWithoutCalendarInput = {
    id?: string
    name: string
    description?: string | null
    startMonth?: string | null
    startDecade?: $Enums.Decade | null
    endMonth?: string | null
    endDecade?: $Enums.Decade | null
    color?: string
    status?: $Enums.StageStatus
    coverUrl?: string | null
    coverName?: string | null
    coverThumbnail?: string | null
    coverSource?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    thresholds?: StageThresholdUncheckedCreateNestedManyWithoutStageInput
    albums?: StageAlbumUncheckedCreateNestedManyWithoutStageInput
  }

  export type StageCreateOrConnectWithoutCalendarInput = {
    where: StageWhereUniqueInput
    create: XOR<StageCreateWithoutCalendarInput, StageUncheckedCreateWithoutCalendarInput>
  }

  export type StageCreateManyCalendarInputEnvelope = {
    data: StageCreateManyCalendarInput | StageCreateManyCalendarInput[]
    skipDuplicates?: boolean
  }

  export type CalendarDistrictCreateWithoutCalendarInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutCalendarDistrictsInput
    district: DistrictCreateNestedOneWithoutCalendarDistrictsInput
  }

  export type CalendarDistrictUncheckedCreateWithoutCalendarInput = {
    cityId: string
    districtId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarDistrictCreateOrConnectWithoutCalendarInput = {
    where: CalendarDistrictWhereUniqueInput
    create: XOR<CalendarDistrictCreateWithoutCalendarInput, CalendarDistrictUncheckedCreateWithoutCalendarInput>
  }

  export type CalendarDistrictCreateManyCalendarInputEnvelope = {
    data: CalendarDistrictCreateManyCalendarInput | CalendarDistrictCreateManyCalendarInput[]
    skipDuplicates?: boolean
  }

  export type CropUpsertWithoutCalendarsInput = {
    update: XOR<CropUpdateWithoutCalendarsInput, CropUncheckedUpdateWithoutCalendarsInput>
    create: XOR<CropCreateWithoutCalendarsInput, CropUncheckedCreateWithoutCalendarsInput>
    where?: CropWhereInput
  }

  export type CropUpdateToOneWithWhereWithoutCalendarsInput = {
    where?: CropWhereInput
    data: XOR<CropUpdateWithoutCalendarsInput, CropUncheckedUpdateWithoutCalendarsInput>
  }

  export type CropUpdateWithoutCalendarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropUncheckedUpdateWithoutCalendarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorUpsertWithoutCalendarsInput = {
    update: XOR<CreatorUpdateWithoutCalendarsInput, CreatorUncheckedUpdateWithoutCalendarsInput>
    create: XOR<CreatorCreateWithoutCalendarsInput, CreatorUncheckedCreateWithoutCalendarsInput>
    where?: CreatorWhereInput
  }

  export type CreatorUpdateToOneWithWhereWithoutCalendarsInput = {
    where?: CreatorWhereInput
    data: XOR<CreatorUpdateWithoutCalendarsInput, CreatorUncheckedUpdateWithoutCalendarsInput>
  }

  export type CreatorUpdateWithoutCalendarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorUncheckedUpdateWithoutCalendarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarUpsertWithoutCopyInput = {
    update: XOR<CalendarUpdateWithoutCopyInput, CalendarUncheckedUpdateWithoutCopyInput>
    create: XOR<CalendarCreateWithoutCopyInput, CalendarUncheckedCreateWithoutCopyInput>
    where?: CalendarWhereInput
  }

  export type CalendarUpdateToOneWithWhereWithoutCopyInput = {
    where?: CalendarWhereInput
    data: XOR<CalendarUpdateWithoutCopyInput, CalendarUncheckedUpdateWithoutCopyInput>
  }

  export type CalendarUpdateWithoutCopyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crop?: CropUpdateOneRequiredWithoutCalendarsNestedInput
    creator?: CreatorUpdateOneRequiredWithoutCalendarsNestedInput
    sourceCalendar?: CalendarUpdateOneWithoutCopyNestedInput
    stages?: StageUpdateManyWithoutCalendarNestedInput
    districts?: CalendarDistrictUpdateManyWithoutCalendarNestedInput
  }

  export type CalendarUncheckedUpdateWithoutCopyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    sourceCalendarId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stages?: StageUncheckedUpdateManyWithoutCalendarNestedInput
    districts?: CalendarDistrictUncheckedUpdateManyWithoutCalendarNestedInput
  }

  export type CalendarUpsertWithoutSourceCalendarInput = {
    update: XOR<CalendarUpdateWithoutSourceCalendarInput, CalendarUncheckedUpdateWithoutSourceCalendarInput>
    create: XOR<CalendarCreateWithoutSourceCalendarInput, CalendarUncheckedCreateWithoutSourceCalendarInput>
    where?: CalendarWhereInput
  }

  export type CalendarUpdateToOneWithWhereWithoutSourceCalendarInput = {
    where?: CalendarWhereInput
    data: XOR<CalendarUpdateWithoutSourceCalendarInput, CalendarUncheckedUpdateWithoutSourceCalendarInput>
  }

  export type CalendarUpdateWithoutSourceCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crop?: CropUpdateOneRequiredWithoutCalendarsNestedInput
    creator?: CreatorUpdateOneRequiredWithoutCalendarsNestedInput
    copy?: CalendarUpdateOneWithoutSourceCalendarNestedInput
    stages?: StageUpdateManyWithoutCalendarNestedInput
    districts?: CalendarDistrictUpdateManyWithoutCalendarNestedInput
  }

  export type CalendarUncheckedUpdateWithoutSourceCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    copy?: CalendarUncheckedUpdateOneWithoutSourceCalendarNestedInput
    stages?: StageUncheckedUpdateManyWithoutCalendarNestedInput
    districts?: CalendarDistrictUncheckedUpdateManyWithoutCalendarNestedInput
  }

  export type StageUpsertWithWhereUniqueWithoutCalendarInput = {
    where: StageWhereUniqueInput
    update: XOR<StageUpdateWithoutCalendarInput, StageUncheckedUpdateWithoutCalendarInput>
    create: XOR<StageCreateWithoutCalendarInput, StageUncheckedCreateWithoutCalendarInput>
  }

  export type StageUpdateWithWhereUniqueWithoutCalendarInput = {
    where: StageWhereUniqueInput
    data: XOR<StageUpdateWithoutCalendarInput, StageUncheckedUpdateWithoutCalendarInput>
  }

  export type StageUpdateManyWithWhereWithoutCalendarInput = {
    where: StageScalarWhereInput
    data: XOR<StageUpdateManyMutationInput, StageUncheckedUpdateManyWithoutCalendarInput>
  }

  export type StageScalarWhereInput = {
    AND?: StageScalarWhereInput | StageScalarWhereInput[]
    OR?: StageScalarWhereInput[]
    NOT?: StageScalarWhereInput | StageScalarWhereInput[]
    id?: StringFilter<"Stage"> | string
    calendarId?: StringFilter<"Stage"> | string
    name?: StringFilter<"Stage"> | string
    description?: StringNullableFilter<"Stage"> | string | null
    startMonth?: StringNullableFilter<"Stage"> | string | null
    startDecade?: EnumDecadeNullableFilter<"Stage"> | $Enums.Decade | null
    endMonth?: StringNullableFilter<"Stage"> | string | null
    endDecade?: EnumDecadeNullableFilter<"Stage"> | $Enums.Decade | null
    color?: StringFilter<"Stage"> | string
    status?: EnumStageStatusFilter<"Stage"> | $Enums.StageStatus
    coverUrl?: StringNullableFilter<"Stage"> | string | null
    coverName?: StringNullableFilter<"Stage"> | string | null
    coverThumbnail?: StringNullableFilter<"Stage"> | string | null
    coverSource?: StringNullableFilter<"Stage"> | string | null
    createdAt?: DateTimeFilter<"Stage"> | Date | string
    updatedAt?: DateTimeFilter<"Stage"> | Date | string
  }

  export type CalendarDistrictUpsertWithWhereUniqueWithoutCalendarInput = {
    where: CalendarDistrictWhereUniqueInput
    update: XOR<CalendarDistrictUpdateWithoutCalendarInput, CalendarDistrictUncheckedUpdateWithoutCalendarInput>
    create: XOR<CalendarDistrictCreateWithoutCalendarInput, CalendarDistrictUncheckedCreateWithoutCalendarInput>
  }

  export type CalendarDistrictUpdateWithWhereUniqueWithoutCalendarInput = {
    where: CalendarDistrictWhereUniqueInput
    data: XOR<CalendarDistrictUpdateWithoutCalendarInput, CalendarDistrictUncheckedUpdateWithoutCalendarInput>
  }

  export type CalendarDistrictUpdateManyWithWhereWithoutCalendarInput = {
    where: CalendarDistrictScalarWhereInput
    data: XOR<CalendarDistrictUpdateManyMutationInput, CalendarDistrictUncheckedUpdateManyWithoutCalendarInput>
  }

  export type CalendarDistrictScalarWhereInput = {
    AND?: CalendarDistrictScalarWhereInput | CalendarDistrictScalarWhereInput[]
    OR?: CalendarDistrictScalarWhereInput[]
    NOT?: CalendarDistrictScalarWhereInput | CalendarDistrictScalarWhereInput[]
    calendarId?: StringFilter<"CalendarDistrict"> | string
    cityId?: StringFilter<"CalendarDistrict"> | string
    districtId?: StringFilter<"CalendarDistrict"> | string
    createdAt?: DateTimeFilter<"CalendarDistrict"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarDistrict"> | Date | string
  }

  export type DistrictCreateWithoutCityInput = {
    id: string
    name: string
    calendarDistricts?: CalendarDistrictCreateNestedManyWithoutDistrictInput
  }

  export type DistrictUncheckedCreateWithoutCityInput = {
    id: string
    name: string
    calendarDistricts?: CalendarDistrictUncheckedCreateNestedManyWithoutDistrictInput
  }

  export type DistrictCreateOrConnectWithoutCityInput = {
    where: DistrictWhereUniqueInput
    create: XOR<DistrictCreateWithoutCityInput, DistrictUncheckedCreateWithoutCityInput>
  }

  export type DistrictCreateManyCityInputEnvelope = {
    data: DistrictCreateManyCityInput | DistrictCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type CalendarDistrictCreateWithoutCityInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    calendar: CalendarCreateNestedOneWithoutDistrictsInput
    district: DistrictCreateNestedOneWithoutCalendarDistrictsInput
  }

  export type CalendarDistrictUncheckedCreateWithoutCityInput = {
    calendarId: string
    districtId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarDistrictCreateOrConnectWithoutCityInput = {
    where: CalendarDistrictWhereUniqueInput
    create: XOR<CalendarDistrictCreateWithoutCityInput, CalendarDistrictUncheckedCreateWithoutCityInput>
  }

  export type CalendarDistrictCreateManyCityInputEnvelope = {
    data: CalendarDistrictCreateManyCityInput | CalendarDistrictCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type DistrictUpsertWithWhereUniqueWithoutCityInput = {
    where: DistrictWhereUniqueInput
    update: XOR<DistrictUpdateWithoutCityInput, DistrictUncheckedUpdateWithoutCityInput>
    create: XOR<DistrictCreateWithoutCityInput, DistrictUncheckedCreateWithoutCityInput>
  }

  export type DistrictUpdateWithWhereUniqueWithoutCityInput = {
    where: DistrictWhereUniqueInput
    data: XOR<DistrictUpdateWithoutCityInput, DistrictUncheckedUpdateWithoutCityInput>
  }

  export type DistrictUpdateManyWithWhereWithoutCityInput = {
    where: DistrictScalarWhereInput
    data: XOR<DistrictUpdateManyMutationInput, DistrictUncheckedUpdateManyWithoutCityInput>
  }

  export type DistrictScalarWhereInput = {
    AND?: DistrictScalarWhereInput | DistrictScalarWhereInput[]
    OR?: DistrictScalarWhereInput[]
    NOT?: DistrictScalarWhereInput | DistrictScalarWhereInput[]
    id?: StringFilter<"District"> | string
    cityId?: StringFilter<"District"> | string
    name?: StringFilter<"District"> | string
  }

  export type CalendarDistrictUpsertWithWhereUniqueWithoutCityInput = {
    where: CalendarDistrictWhereUniqueInput
    update: XOR<CalendarDistrictUpdateWithoutCityInput, CalendarDistrictUncheckedUpdateWithoutCityInput>
    create: XOR<CalendarDistrictCreateWithoutCityInput, CalendarDistrictUncheckedCreateWithoutCityInput>
  }

  export type CalendarDistrictUpdateWithWhereUniqueWithoutCityInput = {
    where: CalendarDistrictWhereUniqueInput
    data: XOR<CalendarDistrictUpdateWithoutCityInput, CalendarDistrictUncheckedUpdateWithoutCityInput>
  }

  export type CalendarDistrictUpdateManyWithWhereWithoutCityInput = {
    where: CalendarDistrictScalarWhereInput
    data: XOR<CalendarDistrictUpdateManyMutationInput, CalendarDistrictUncheckedUpdateManyWithoutCityInput>
  }

  export type CityCreateWithoutDistrictsInput = {
    id: string
    name: string
    calendarDistricts?: CalendarDistrictCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutDistrictsInput = {
    id: string
    name: string
    calendarDistricts?: CalendarDistrictUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutDistrictsInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutDistrictsInput, CityUncheckedCreateWithoutDistrictsInput>
  }

  export type CalendarDistrictCreateWithoutDistrictInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    calendar: CalendarCreateNestedOneWithoutDistrictsInput
    city: CityCreateNestedOneWithoutCalendarDistrictsInput
  }

  export type CalendarDistrictUncheckedCreateWithoutDistrictInput = {
    calendarId: string
    cityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarDistrictCreateOrConnectWithoutDistrictInput = {
    where: CalendarDistrictWhereUniqueInput
    create: XOR<CalendarDistrictCreateWithoutDistrictInput, CalendarDistrictUncheckedCreateWithoutDistrictInput>
  }

  export type CalendarDistrictCreateManyDistrictInputEnvelope = {
    data: CalendarDistrictCreateManyDistrictInput | CalendarDistrictCreateManyDistrictInput[]
    skipDuplicates?: boolean
  }

  export type CityUpsertWithoutDistrictsInput = {
    update: XOR<CityUpdateWithoutDistrictsInput, CityUncheckedUpdateWithoutDistrictsInput>
    create: XOR<CityCreateWithoutDistrictsInput, CityUncheckedCreateWithoutDistrictsInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutDistrictsInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutDistrictsInput, CityUncheckedUpdateWithoutDistrictsInput>
  }

  export type CityUpdateWithoutDistrictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    calendarDistricts?: CalendarDistrictUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutDistrictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    calendarDistricts?: CalendarDistrictUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CalendarDistrictUpsertWithWhereUniqueWithoutDistrictInput = {
    where: CalendarDistrictWhereUniqueInput
    update: XOR<CalendarDistrictUpdateWithoutDistrictInput, CalendarDistrictUncheckedUpdateWithoutDistrictInput>
    create: XOR<CalendarDistrictCreateWithoutDistrictInput, CalendarDistrictUncheckedCreateWithoutDistrictInput>
  }

  export type CalendarDistrictUpdateWithWhereUniqueWithoutDistrictInput = {
    where: CalendarDistrictWhereUniqueInput
    data: XOR<CalendarDistrictUpdateWithoutDistrictInput, CalendarDistrictUncheckedUpdateWithoutDistrictInput>
  }

  export type CalendarDistrictUpdateManyWithWhereWithoutDistrictInput = {
    where: CalendarDistrictScalarWhereInput
    data: XOR<CalendarDistrictUpdateManyMutationInput, CalendarDistrictUncheckedUpdateManyWithoutDistrictInput>
  }

  export type CalendarCreateWithoutDistrictsInput = {
    id?: string
    title: string
    zoneName?: string
    isShared?: boolean
    isPublished?: boolean
    fileType?: $Enums.CalendarFileType
    allowCenterUse?: boolean
    sharedAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    crop: CropCreateNestedOneWithoutCalendarsInput
    creator: CreatorCreateNestedOneWithoutCalendarsInput
    sourceCalendar?: CalendarCreateNestedOneWithoutCopyInput
    copy?: CalendarCreateNestedOneWithoutSourceCalendarInput
    stages?: StageCreateNestedManyWithoutCalendarInput
  }

  export type CalendarUncheckedCreateWithoutDistrictsInput = {
    id?: string
    cropId: string
    creatorId: string
    sourceCalendarId?: string | null
    title: string
    zoneName?: string
    isShared?: boolean
    isPublished?: boolean
    fileType?: $Enums.CalendarFileType
    allowCenterUse?: boolean
    sharedAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    copy?: CalendarUncheckedCreateNestedOneWithoutSourceCalendarInput
    stages?: StageUncheckedCreateNestedManyWithoutCalendarInput
  }

  export type CalendarCreateOrConnectWithoutDistrictsInput = {
    where: CalendarWhereUniqueInput
    create: XOR<CalendarCreateWithoutDistrictsInput, CalendarUncheckedCreateWithoutDistrictsInput>
  }

  export type CityCreateWithoutCalendarDistrictsInput = {
    id: string
    name: string
    districts?: DistrictCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutCalendarDistrictsInput = {
    id: string
    name: string
    districts?: DistrictUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutCalendarDistrictsInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutCalendarDistrictsInput, CityUncheckedCreateWithoutCalendarDistrictsInput>
  }

  export type DistrictCreateWithoutCalendarDistrictsInput = {
    id: string
    name: string
    city: CityCreateNestedOneWithoutDistrictsInput
  }

  export type DistrictUncheckedCreateWithoutCalendarDistrictsInput = {
    id: string
    cityId: string
    name: string
  }

  export type DistrictCreateOrConnectWithoutCalendarDistrictsInput = {
    where: DistrictWhereUniqueInput
    create: XOR<DistrictCreateWithoutCalendarDistrictsInput, DistrictUncheckedCreateWithoutCalendarDistrictsInput>
  }

  export type CalendarUpsertWithoutDistrictsInput = {
    update: XOR<CalendarUpdateWithoutDistrictsInput, CalendarUncheckedUpdateWithoutDistrictsInput>
    create: XOR<CalendarCreateWithoutDistrictsInput, CalendarUncheckedCreateWithoutDistrictsInput>
    where?: CalendarWhereInput
  }

  export type CalendarUpdateToOneWithWhereWithoutDistrictsInput = {
    where?: CalendarWhereInput
    data: XOR<CalendarUpdateWithoutDistrictsInput, CalendarUncheckedUpdateWithoutDistrictsInput>
  }

  export type CalendarUpdateWithoutDistrictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crop?: CropUpdateOneRequiredWithoutCalendarsNestedInput
    creator?: CreatorUpdateOneRequiredWithoutCalendarsNestedInput
    sourceCalendar?: CalendarUpdateOneWithoutCopyNestedInput
    copy?: CalendarUpdateOneWithoutSourceCalendarNestedInput
    stages?: StageUpdateManyWithoutCalendarNestedInput
  }

  export type CalendarUncheckedUpdateWithoutDistrictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    sourceCalendarId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    copy?: CalendarUncheckedUpdateOneWithoutSourceCalendarNestedInput
    stages?: StageUncheckedUpdateManyWithoutCalendarNestedInput
  }

  export type CityUpsertWithoutCalendarDistrictsInput = {
    update: XOR<CityUpdateWithoutCalendarDistrictsInput, CityUncheckedUpdateWithoutCalendarDistrictsInput>
    create: XOR<CityCreateWithoutCalendarDistrictsInput, CityUncheckedCreateWithoutCalendarDistrictsInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutCalendarDistrictsInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutCalendarDistrictsInput, CityUncheckedUpdateWithoutCalendarDistrictsInput>
  }

  export type CityUpdateWithoutCalendarDistrictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    districts?: DistrictUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutCalendarDistrictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    districts?: DistrictUncheckedUpdateManyWithoutCityNestedInput
  }

  export type DistrictUpsertWithoutCalendarDistrictsInput = {
    update: XOR<DistrictUpdateWithoutCalendarDistrictsInput, DistrictUncheckedUpdateWithoutCalendarDistrictsInput>
    create: XOR<DistrictCreateWithoutCalendarDistrictsInput, DistrictUncheckedCreateWithoutCalendarDistrictsInput>
    where?: DistrictWhereInput
  }

  export type DistrictUpdateToOneWithWhereWithoutCalendarDistrictsInput = {
    where?: DistrictWhereInput
    data: XOR<DistrictUpdateWithoutCalendarDistrictsInput, DistrictUncheckedUpdateWithoutCalendarDistrictsInput>
  }

  export type DistrictUpdateWithoutCalendarDistrictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneRequiredWithoutDistrictsNestedInput
  }

  export type DistrictUncheckedUpdateWithoutCalendarDistrictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CalendarCreateWithoutStagesInput = {
    id?: string
    title: string
    zoneName?: string
    isShared?: boolean
    isPublished?: boolean
    fileType?: $Enums.CalendarFileType
    allowCenterUse?: boolean
    sharedAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    crop: CropCreateNestedOneWithoutCalendarsInput
    creator: CreatorCreateNestedOneWithoutCalendarsInput
    sourceCalendar?: CalendarCreateNestedOneWithoutCopyInput
    copy?: CalendarCreateNestedOneWithoutSourceCalendarInput
    districts?: CalendarDistrictCreateNestedManyWithoutCalendarInput
  }

  export type CalendarUncheckedCreateWithoutStagesInput = {
    id?: string
    cropId: string
    creatorId: string
    sourceCalendarId?: string | null
    title: string
    zoneName?: string
    isShared?: boolean
    isPublished?: boolean
    fileType?: $Enums.CalendarFileType
    allowCenterUse?: boolean
    sharedAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    copy?: CalendarUncheckedCreateNestedOneWithoutSourceCalendarInput
    districts?: CalendarDistrictUncheckedCreateNestedManyWithoutCalendarInput
  }

  export type CalendarCreateOrConnectWithoutStagesInput = {
    where: CalendarWhereUniqueInput
    create: XOR<CalendarCreateWithoutStagesInput, CalendarUncheckedCreateWithoutStagesInput>
  }

  export type StageThresholdCreateWithoutStageInput = {
    id?: string
    operator: $Enums.ThresholdOperator
    value: number
    durationDays?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    indicator: IndicatorCreateNestedOneWithoutThresholdsInput
  }

  export type StageThresholdUncheckedCreateWithoutStageInput = {
    id?: string
    indicatorId: string
    operator: $Enums.ThresholdOperator
    value: number
    durationDays?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageThresholdCreateOrConnectWithoutStageInput = {
    where: StageThresholdWhereUniqueInput
    create: XOR<StageThresholdCreateWithoutStageInput, StageThresholdUncheckedCreateWithoutStageInput>
  }

  export type StageThresholdCreateManyStageInputEnvelope = {
    data: StageThresholdCreateManyStageInput | StageThresholdCreateManyStageInput[]
    skipDuplicates?: boolean
  }

  export type StageAlbumCreateWithoutStageInput = {
    id?: string
    url: string
    name?: string | null
    thumbnail?: string | null
    source?: string | null
    sortOrder?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageAlbumUncheckedCreateWithoutStageInput = {
    id?: string
    url: string
    name?: string | null
    thumbnail?: string | null
    source?: string | null
    sortOrder?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageAlbumCreateOrConnectWithoutStageInput = {
    where: StageAlbumWhereUniqueInput
    create: XOR<StageAlbumCreateWithoutStageInput, StageAlbumUncheckedCreateWithoutStageInput>
  }

  export type StageAlbumCreateManyStageInputEnvelope = {
    data: StageAlbumCreateManyStageInput | StageAlbumCreateManyStageInput[]
    skipDuplicates?: boolean
  }

  export type CalendarUpsertWithoutStagesInput = {
    update: XOR<CalendarUpdateWithoutStagesInput, CalendarUncheckedUpdateWithoutStagesInput>
    create: XOR<CalendarCreateWithoutStagesInput, CalendarUncheckedCreateWithoutStagesInput>
    where?: CalendarWhereInput
  }

  export type CalendarUpdateToOneWithWhereWithoutStagesInput = {
    where?: CalendarWhereInput
    data: XOR<CalendarUpdateWithoutStagesInput, CalendarUncheckedUpdateWithoutStagesInput>
  }

  export type CalendarUpdateWithoutStagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crop?: CropUpdateOneRequiredWithoutCalendarsNestedInput
    creator?: CreatorUpdateOneRequiredWithoutCalendarsNestedInput
    sourceCalendar?: CalendarUpdateOneWithoutCopyNestedInput
    copy?: CalendarUpdateOneWithoutSourceCalendarNestedInput
    districts?: CalendarDistrictUpdateManyWithoutCalendarNestedInput
  }

  export type CalendarUncheckedUpdateWithoutStagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    sourceCalendarId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    copy?: CalendarUncheckedUpdateOneWithoutSourceCalendarNestedInput
    districts?: CalendarDistrictUncheckedUpdateManyWithoutCalendarNestedInput
  }

  export type StageThresholdUpsertWithWhereUniqueWithoutStageInput = {
    where: StageThresholdWhereUniqueInput
    update: XOR<StageThresholdUpdateWithoutStageInput, StageThresholdUncheckedUpdateWithoutStageInput>
    create: XOR<StageThresholdCreateWithoutStageInput, StageThresholdUncheckedCreateWithoutStageInput>
  }

  export type StageThresholdUpdateWithWhereUniqueWithoutStageInput = {
    where: StageThresholdWhereUniqueInput
    data: XOR<StageThresholdUpdateWithoutStageInput, StageThresholdUncheckedUpdateWithoutStageInput>
  }

  export type StageThresholdUpdateManyWithWhereWithoutStageInput = {
    where: StageThresholdScalarWhereInput
    data: XOR<StageThresholdUpdateManyMutationInput, StageThresholdUncheckedUpdateManyWithoutStageInput>
  }

  export type StageThresholdScalarWhereInput = {
    AND?: StageThresholdScalarWhereInput | StageThresholdScalarWhereInput[]
    OR?: StageThresholdScalarWhereInput[]
    NOT?: StageThresholdScalarWhereInput | StageThresholdScalarWhereInput[]
    id?: StringFilter<"StageThreshold"> | string
    stageId?: StringFilter<"StageThreshold"> | string
    indicatorId?: StringFilter<"StageThreshold"> | string
    operator?: EnumThresholdOperatorFilter<"StageThreshold"> | $Enums.ThresholdOperator
    value?: FloatFilter<"StageThreshold"> | number
    durationDays?: StringFilter<"StageThreshold"> | string
    createdAt?: DateTimeFilter<"StageThreshold"> | Date | string
    updatedAt?: DateTimeFilter<"StageThreshold"> | Date | string
  }

  export type StageAlbumUpsertWithWhereUniqueWithoutStageInput = {
    where: StageAlbumWhereUniqueInput
    update: XOR<StageAlbumUpdateWithoutStageInput, StageAlbumUncheckedUpdateWithoutStageInput>
    create: XOR<StageAlbumCreateWithoutStageInput, StageAlbumUncheckedCreateWithoutStageInput>
  }

  export type StageAlbumUpdateWithWhereUniqueWithoutStageInput = {
    where: StageAlbumWhereUniqueInput
    data: XOR<StageAlbumUpdateWithoutStageInput, StageAlbumUncheckedUpdateWithoutStageInput>
  }

  export type StageAlbumUpdateManyWithWhereWithoutStageInput = {
    where: StageAlbumScalarWhereInput
    data: XOR<StageAlbumUpdateManyMutationInput, StageAlbumUncheckedUpdateManyWithoutStageInput>
  }

  export type StageAlbumScalarWhereInput = {
    AND?: StageAlbumScalarWhereInput | StageAlbumScalarWhereInput[]
    OR?: StageAlbumScalarWhereInput[]
    NOT?: StageAlbumScalarWhereInput | StageAlbumScalarWhereInput[]
    id?: StringFilter<"StageAlbum"> | string
    stageId?: StringFilter<"StageAlbum"> | string
    url?: StringFilter<"StageAlbum"> | string
    name?: StringNullableFilter<"StageAlbum"> | string | null
    thumbnail?: StringNullableFilter<"StageAlbum"> | string | null
    source?: StringNullableFilter<"StageAlbum"> | string | null
    sortOrder?: StringFilter<"StageAlbum"> | string
    createdAt?: DateTimeFilter<"StageAlbum"> | Date | string
    updatedAt?: DateTimeFilter<"StageAlbum"> | Date | string
  }

  export type StageCreateWithoutAlbumsInput = {
    id?: string
    name: string
    description?: string | null
    startMonth?: string | null
    startDecade?: $Enums.Decade | null
    endMonth?: string | null
    endDecade?: $Enums.Decade | null
    color?: string
    status?: $Enums.StageStatus
    coverUrl?: string | null
    coverName?: string | null
    coverThumbnail?: string | null
    coverSource?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    calendar: CalendarCreateNestedOneWithoutStagesInput
    thresholds?: StageThresholdCreateNestedManyWithoutStageInput
  }

  export type StageUncheckedCreateWithoutAlbumsInput = {
    id?: string
    calendarId: string
    name: string
    description?: string | null
    startMonth?: string | null
    startDecade?: $Enums.Decade | null
    endMonth?: string | null
    endDecade?: $Enums.Decade | null
    color?: string
    status?: $Enums.StageStatus
    coverUrl?: string | null
    coverName?: string | null
    coverThumbnail?: string | null
    coverSource?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    thresholds?: StageThresholdUncheckedCreateNestedManyWithoutStageInput
  }

  export type StageCreateOrConnectWithoutAlbumsInput = {
    where: StageWhereUniqueInput
    create: XOR<StageCreateWithoutAlbumsInput, StageUncheckedCreateWithoutAlbumsInput>
  }

  export type StageUpsertWithoutAlbumsInput = {
    update: XOR<StageUpdateWithoutAlbumsInput, StageUncheckedUpdateWithoutAlbumsInput>
    create: XOR<StageCreateWithoutAlbumsInput, StageUncheckedCreateWithoutAlbumsInput>
    where?: StageWhereInput
  }

  export type StageUpdateToOneWithWhereWithoutAlbumsInput = {
    where?: StageWhereInput
    data: XOR<StageUpdateWithoutAlbumsInput, StageUncheckedUpdateWithoutAlbumsInput>
  }

  export type StageUpdateWithoutAlbumsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: NullableStringFieldUpdateOperationsInput | string | null
    startDecade?: NullableEnumDecadeFieldUpdateOperationsInput | $Enums.Decade | null
    endMonth?: NullableStringFieldUpdateOperationsInput | string | null
    endDecade?: NullableEnumDecadeFieldUpdateOperationsInput | $Enums.Decade | null
    color?: StringFieldUpdateOperationsInput | string
    status?: EnumStageStatusFieldUpdateOperationsInput | $Enums.StageStatus
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverName?: NullableStringFieldUpdateOperationsInput | string | null
    coverThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendar?: CalendarUpdateOneRequiredWithoutStagesNestedInput
    thresholds?: StageThresholdUpdateManyWithoutStageNestedInput
  }

  export type StageUncheckedUpdateWithoutAlbumsInput = {
    id?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: NullableStringFieldUpdateOperationsInput | string | null
    startDecade?: NullableEnumDecadeFieldUpdateOperationsInput | $Enums.Decade | null
    endMonth?: NullableStringFieldUpdateOperationsInput | string | null
    endDecade?: NullableEnumDecadeFieldUpdateOperationsInput | $Enums.Decade | null
    color?: StringFieldUpdateOperationsInput | string
    status?: EnumStageStatusFieldUpdateOperationsInput | $Enums.StageStatus
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverName?: NullableStringFieldUpdateOperationsInput | string | null
    coverThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thresholds?: StageThresholdUncheckedUpdateManyWithoutStageNestedInput
  }

  export type StageCreateWithoutThresholdsInput = {
    id?: string
    name: string
    description?: string | null
    startMonth?: string | null
    startDecade?: $Enums.Decade | null
    endMonth?: string | null
    endDecade?: $Enums.Decade | null
    color?: string
    status?: $Enums.StageStatus
    coverUrl?: string | null
    coverName?: string | null
    coverThumbnail?: string | null
    coverSource?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    calendar: CalendarCreateNestedOneWithoutStagesInput
    albums?: StageAlbumCreateNestedManyWithoutStageInput
  }

  export type StageUncheckedCreateWithoutThresholdsInput = {
    id?: string
    calendarId: string
    name: string
    description?: string | null
    startMonth?: string | null
    startDecade?: $Enums.Decade | null
    endMonth?: string | null
    endDecade?: $Enums.Decade | null
    color?: string
    status?: $Enums.StageStatus
    coverUrl?: string | null
    coverName?: string | null
    coverThumbnail?: string | null
    coverSource?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    albums?: StageAlbumUncheckedCreateNestedManyWithoutStageInput
  }

  export type StageCreateOrConnectWithoutThresholdsInput = {
    where: StageWhereUniqueInput
    create: XOR<StageCreateWithoutThresholdsInput, StageUncheckedCreateWithoutThresholdsInput>
  }

  export type IndicatorCreateWithoutThresholdsInput = {
    id?: string
    name: string
    source?: string
    unit: string
    createdAt?: Date | string
    updatedAt?: Date | string
    category: IndicatorCategoryCreateNestedOneWithoutIndicatorsInput
  }

  export type IndicatorUncheckedCreateWithoutThresholdsInput = {
    id?: string
    categoryId: string
    name: string
    source?: string
    unit: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndicatorCreateOrConnectWithoutThresholdsInput = {
    where: IndicatorWhereUniqueInput
    create: XOR<IndicatorCreateWithoutThresholdsInput, IndicatorUncheckedCreateWithoutThresholdsInput>
  }

  export type StageUpsertWithoutThresholdsInput = {
    update: XOR<StageUpdateWithoutThresholdsInput, StageUncheckedUpdateWithoutThresholdsInput>
    create: XOR<StageCreateWithoutThresholdsInput, StageUncheckedCreateWithoutThresholdsInput>
    where?: StageWhereInput
  }

  export type StageUpdateToOneWithWhereWithoutThresholdsInput = {
    where?: StageWhereInput
    data: XOR<StageUpdateWithoutThresholdsInput, StageUncheckedUpdateWithoutThresholdsInput>
  }

  export type StageUpdateWithoutThresholdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: NullableStringFieldUpdateOperationsInput | string | null
    startDecade?: NullableEnumDecadeFieldUpdateOperationsInput | $Enums.Decade | null
    endMonth?: NullableStringFieldUpdateOperationsInput | string | null
    endDecade?: NullableEnumDecadeFieldUpdateOperationsInput | $Enums.Decade | null
    color?: StringFieldUpdateOperationsInput | string
    status?: EnumStageStatusFieldUpdateOperationsInput | $Enums.StageStatus
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverName?: NullableStringFieldUpdateOperationsInput | string | null
    coverThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendar?: CalendarUpdateOneRequiredWithoutStagesNestedInput
    albums?: StageAlbumUpdateManyWithoutStageNestedInput
  }

  export type StageUncheckedUpdateWithoutThresholdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: NullableStringFieldUpdateOperationsInput | string | null
    startDecade?: NullableEnumDecadeFieldUpdateOperationsInput | $Enums.Decade | null
    endMonth?: NullableStringFieldUpdateOperationsInput | string | null
    endDecade?: NullableEnumDecadeFieldUpdateOperationsInput | $Enums.Decade | null
    color?: StringFieldUpdateOperationsInput | string
    status?: EnumStageStatusFieldUpdateOperationsInput | $Enums.StageStatus
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverName?: NullableStringFieldUpdateOperationsInput | string | null
    coverThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albums?: StageAlbumUncheckedUpdateManyWithoutStageNestedInput
  }

  export type IndicatorUpsertWithoutThresholdsInput = {
    update: XOR<IndicatorUpdateWithoutThresholdsInput, IndicatorUncheckedUpdateWithoutThresholdsInput>
    create: XOR<IndicatorCreateWithoutThresholdsInput, IndicatorUncheckedCreateWithoutThresholdsInput>
    where?: IndicatorWhereInput
  }

  export type IndicatorUpdateToOneWithWhereWithoutThresholdsInput = {
    where?: IndicatorWhereInput
    data: XOR<IndicatorUpdateWithoutThresholdsInput, IndicatorUncheckedUpdateWithoutThresholdsInput>
  }

  export type IndicatorUpdateWithoutThresholdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: IndicatorCategoryUpdateOneRequiredWithoutIndicatorsNestedInput
  }

  export type IndicatorUncheckedUpdateWithoutThresholdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicatorCreateWithoutCategoryInput = {
    id?: string
    name: string
    source?: string
    unit: string
    createdAt?: Date | string
    updatedAt?: Date | string
    thresholds?: StageThresholdCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    source?: string
    unit: string
    createdAt?: Date | string
    updatedAt?: Date | string
    thresholds?: StageThresholdUncheckedCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorCreateOrConnectWithoutCategoryInput = {
    where: IndicatorWhereUniqueInput
    create: XOR<IndicatorCreateWithoutCategoryInput, IndicatorUncheckedCreateWithoutCategoryInput>
  }

  export type IndicatorCreateManyCategoryInputEnvelope = {
    data: IndicatorCreateManyCategoryInput | IndicatorCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type IndicatorUpsertWithWhereUniqueWithoutCategoryInput = {
    where: IndicatorWhereUniqueInput
    update: XOR<IndicatorUpdateWithoutCategoryInput, IndicatorUncheckedUpdateWithoutCategoryInput>
    create: XOR<IndicatorCreateWithoutCategoryInput, IndicatorUncheckedCreateWithoutCategoryInput>
  }

  export type IndicatorUpdateWithWhereUniqueWithoutCategoryInput = {
    where: IndicatorWhereUniqueInput
    data: XOR<IndicatorUpdateWithoutCategoryInput, IndicatorUncheckedUpdateWithoutCategoryInput>
  }

  export type IndicatorUpdateManyWithWhereWithoutCategoryInput = {
    where: IndicatorScalarWhereInput
    data: XOR<IndicatorUpdateManyMutationInput, IndicatorUncheckedUpdateManyWithoutCategoryInput>
  }

  export type IndicatorScalarWhereInput = {
    AND?: IndicatorScalarWhereInput | IndicatorScalarWhereInput[]
    OR?: IndicatorScalarWhereInput[]
    NOT?: IndicatorScalarWhereInput | IndicatorScalarWhereInput[]
    id?: StringFilter<"Indicator"> | string
    categoryId?: StringFilter<"Indicator"> | string
    name?: StringFilter<"Indicator"> | string
    source?: StringFilter<"Indicator"> | string
    unit?: StringFilter<"Indicator"> | string
    createdAt?: DateTimeFilter<"Indicator"> | Date | string
    updatedAt?: DateTimeFilter<"Indicator"> | Date | string
  }

  export type IndicatorCategoryCreateWithoutIndicatorsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndicatorCategoryUncheckedCreateWithoutIndicatorsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndicatorCategoryCreateOrConnectWithoutIndicatorsInput = {
    where: IndicatorCategoryWhereUniqueInput
    create: XOR<IndicatorCategoryCreateWithoutIndicatorsInput, IndicatorCategoryUncheckedCreateWithoutIndicatorsInput>
  }

  export type StageThresholdCreateWithoutIndicatorInput = {
    id?: string
    operator: $Enums.ThresholdOperator
    value: number
    durationDays?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stage: StageCreateNestedOneWithoutThresholdsInput
  }

  export type StageThresholdUncheckedCreateWithoutIndicatorInput = {
    id?: string
    stageId: string
    operator: $Enums.ThresholdOperator
    value: number
    durationDays?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageThresholdCreateOrConnectWithoutIndicatorInput = {
    where: StageThresholdWhereUniqueInput
    create: XOR<StageThresholdCreateWithoutIndicatorInput, StageThresholdUncheckedCreateWithoutIndicatorInput>
  }

  export type StageThresholdCreateManyIndicatorInputEnvelope = {
    data: StageThresholdCreateManyIndicatorInput | StageThresholdCreateManyIndicatorInput[]
    skipDuplicates?: boolean
  }

  export type IndicatorCategoryUpsertWithoutIndicatorsInput = {
    update: XOR<IndicatorCategoryUpdateWithoutIndicatorsInput, IndicatorCategoryUncheckedUpdateWithoutIndicatorsInput>
    create: XOR<IndicatorCategoryCreateWithoutIndicatorsInput, IndicatorCategoryUncheckedCreateWithoutIndicatorsInput>
    where?: IndicatorCategoryWhereInput
  }

  export type IndicatorCategoryUpdateToOneWithWhereWithoutIndicatorsInput = {
    where?: IndicatorCategoryWhereInput
    data: XOR<IndicatorCategoryUpdateWithoutIndicatorsInput, IndicatorCategoryUncheckedUpdateWithoutIndicatorsInput>
  }

  export type IndicatorCategoryUpdateWithoutIndicatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicatorCategoryUncheckedUpdateWithoutIndicatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageThresholdUpsertWithWhereUniqueWithoutIndicatorInput = {
    where: StageThresholdWhereUniqueInput
    update: XOR<StageThresholdUpdateWithoutIndicatorInput, StageThresholdUncheckedUpdateWithoutIndicatorInput>
    create: XOR<StageThresholdCreateWithoutIndicatorInput, StageThresholdUncheckedCreateWithoutIndicatorInput>
  }

  export type StageThresholdUpdateWithWhereUniqueWithoutIndicatorInput = {
    where: StageThresholdWhereUniqueInput
    data: XOR<StageThresholdUpdateWithoutIndicatorInput, StageThresholdUncheckedUpdateWithoutIndicatorInput>
  }

  export type StageThresholdUpdateManyWithWhereWithoutIndicatorInput = {
    where: StageThresholdScalarWhereInput
    data: XOR<StageThresholdUpdateManyMutationInput, StageThresholdUncheckedUpdateManyWithoutIndicatorInput>
  }

  export type CalendarCreateManyCropInput = {
    id?: string
    creatorId: string
    sourceCalendarId?: string | null
    title: string
    zoneName?: string
    isShared?: boolean
    isPublished?: boolean
    fileType?: $Enums.CalendarFileType
    allowCenterUse?: boolean
    sharedAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarUpdateWithoutCropInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: CreatorUpdateOneRequiredWithoutCalendarsNestedInput
    sourceCalendar?: CalendarUpdateOneWithoutCopyNestedInput
    copy?: CalendarUpdateOneWithoutSourceCalendarNestedInput
    stages?: StageUpdateManyWithoutCalendarNestedInput
    districts?: CalendarDistrictUpdateManyWithoutCalendarNestedInput
  }

  export type CalendarUncheckedUpdateWithoutCropInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    sourceCalendarId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    copy?: CalendarUncheckedUpdateOneWithoutSourceCalendarNestedInput
    stages?: StageUncheckedUpdateManyWithoutCalendarNestedInput
    districts?: CalendarDistrictUncheckedUpdateManyWithoutCalendarNestedInput
  }

  export type CalendarUncheckedUpdateManyWithoutCropInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    sourceCalendarId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarCreateManyCreatorInput = {
    id?: string
    cropId: string
    sourceCalendarId?: string | null
    title: string
    zoneName?: string
    isShared?: boolean
    isPublished?: boolean
    fileType?: $Enums.CalendarFileType
    allowCenterUse?: boolean
    sharedAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crop?: CropUpdateOneRequiredWithoutCalendarsNestedInput
    sourceCalendar?: CalendarUpdateOneWithoutCopyNestedInput
    copy?: CalendarUpdateOneWithoutSourceCalendarNestedInput
    stages?: StageUpdateManyWithoutCalendarNestedInput
    districts?: CalendarDistrictUpdateManyWithoutCalendarNestedInput
  }

  export type CalendarUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropId?: StringFieldUpdateOperationsInput | string
    sourceCalendarId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    copy?: CalendarUncheckedUpdateOneWithoutSourceCalendarNestedInput
    stages?: StageUncheckedUpdateManyWithoutCalendarNestedInput
    districts?: CalendarDistrictUncheckedUpdateManyWithoutCalendarNestedInput
  }

  export type CalendarUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropId?: StringFieldUpdateOperationsInput | string
    sourceCalendarId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    zoneName?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    fileType?: EnumCalendarFileTypeFieldUpdateOperationsInput | $Enums.CalendarFileType
    allowCenterUse?: BoolFieldUpdateOperationsInput | boolean
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageCreateManyCalendarInput = {
    id?: string
    name: string
    description?: string | null
    startMonth?: string | null
    startDecade?: $Enums.Decade | null
    endMonth?: string | null
    endDecade?: $Enums.Decade | null
    color?: string
    status?: $Enums.StageStatus
    coverUrl?: string | null
    coverName?: string | null
    coverThumbnail?: string | null
    coverSource?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarDistrictCreateManyCalendarInput = {
    cityId: string
    districtId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageUpdateWithoutCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: NullableStringFieldUpdateOperationsInput | string | null
    startDecade?: NullableEnumDecadeFieldUpdateOperationsInput | $Enums.Decade | null
    endMonth?: NullableStringFieldUpdateOperationsInput | string | null
    endDecade?: NullableEnumDecadeFieldUpdateOperationsInput | $Enums.Decade | null
    color?: StringFieldUpdateOperationsInput | string
    status?: EnumStageStatusFieldUpdateOperationsInput | $Enums.StageStatus
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverName?: NullableStringFieldUpdateOperationsInput | string | null
    coverThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thresholds?: StageThresholdUpdateManyWithoutStageNestedInput
    albums?: StageAlbumUpdateManyWithoutStageNestedInput
  }

  export type StageUncheckedUpdateWithoutCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: NullableStringFieldUpdateOperationsInput | string | null
    startDecade?: NullableEnumDecadeFieldUpdateOperationsInput | $Enums.Decade | null
    endMonth?: NullableStringFieldUpdateOperationsInput | string | null
    endDecade?: NullableEnumDecadeFieldUpdateOperationsInput | $Enums.Decade | null
    color?: StringFieldUpdateOperationsInput | string
    status?: EnumStageStatusFieldUpdateOperationsInput | $Enums.StageStatus
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverName?: NullableStringFieldUpdateOperationsInput | string | null
    coverThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thresholds?: StageThresholdUncheckedUpdateManyWithoutStageNestedInput
    albums?: StageAlbumUncheckedUpdateManyWithoutStageNestedInput
  }

  export type StageUncheckedUpdateManyWithoutCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: NullableStringFieldUpdateOperationsInput | string | null
    startDecade?: NullableEnumDecadeFieldUpdateOperationsInput | $Enums.Decade | null
    endMonth?: NullableStringFieldUpdateOperationsInput | string | null
    endDecade?: NullableEnumDecadeFieldUpdateOperationsInput | $Enums.Decade | null
    color?: StringFieldUpdateOperationsInput | string
    status?: EnumStageStatusFieldUpdateOperationsInput | $Enums.StageStatus
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverName?: NullableStringFieldUpdateOperationsInput | string | null
    coverThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    coverSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarDistrictUpdateWithoutCalendarInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutCalendarDistrictsNestedInput
    district?: DistrictUpdateOneRequiredWithoutCalendarDistrictsNestedInput
  }

  export type CalendarDistrictUncheckedUpdateWithoutCalendarInput = {
    cityId?: StringFieldUpdateOperationsInput | string
    districtId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarDistrictUncheckedUpdateManyWithoutCalendarInput = {
    cityId?: StringFieldUpdateOperationsInput | string
    districtId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DistrictCreateManyCityInput = {
    id: string
    name: string
  }

  export type CalendarDistrictCreateManyCityInput = {
    calendarId: string
    districtId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DistrictUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    calendarDistricts?: CalendarDistrictUpdateManyWithoutDistrictNestedInput
  }

  export type DistrictUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    calendarDistricts?: CalendarDistrictUncheckedUpdateManyWithoutDistrictNestedInput
  }

  export type DistrictUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CalendarDistrictUpdateWithoutCityInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendar?: CalendarUpdateOneRequiredWithoutDistrictsNestedInput
    district?: DistrictUpdateOneRequiredWithoutCalendarDistrictsNestedInput
  }

  export type CalendarDistrictUncheckedUpdateWithoutCityInput = {
    calendarId?: StringFieldUpdateOperationsInput | string
    districtId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarDistrictUncheckedUpdateManyWithoutCityInput = {
    calendarId?: StringFieldUpdateOperationsInput | string
    districtId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarDistrictCreateManyDistrictInput = {
    calendarId: string
    cityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarDistrictUpdateWithoutDistrictInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendar?: CalendarUpdateOneRequiredWithoutDistrictsNestedInput
    city?: CityUpdateOneRequiredWithoutCalendarDistrictsNestedInput
  }

  export type CalendarDistrictUncheckedUpdateWithoutDistrictInput = {
    calendarId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarDistrictUncheckedUpdateManyWithoutDistrictInput = {
    calendarId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageThresholdCreateManyStageInput = {
    id?: string
    indicatorId: string
    operator: $Enums.ThresholdOperator
    value: number
    durationDays?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageAlbumCreateManyStageInput = {
    id?: string
    url: string
    name?: string | null
    thumbnail?: string | null
    source?: string | null
    sortOrder?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageThresholdUpdateWithoutStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    operator?: EnumThresholdOperatorFieldUpdateOperationsInput | $Enums.ThresholdOperator
    value?: FloatFieldUpdateOperationsInput | number
    durationDays?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicator?: IndicatorUpdateOneRequiredWithoutThresholdsNestedInput
  }

  export type StageThresholdUncheckedUpdateWithoutStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    indicatorId?: StringFieldUpdateOperationsInput | string
    operator?: EnumThresholdOperatorFieldUpdateOperationsInput | $Enums.ThresholdOperator
    value?: FloatFieldUpdateOperationsInput | number
    durationDays?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageThresholdUncheckedUpdateManyWithoutStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    indicatorId?: StringFieldUpdateOperationsInput | string
    operator?: EnumThresholdOperatorFieldUpdateOperationsInput | $Enums.ThresholdOperator
    value?: FloatFieldUpdateOperationsInput | number
    durationDays?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageAlbumUpdateWithoutStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageAlbumUncheckedUpdateWithoutStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageAlbumUncheckedUpdateManyWithoutStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicatorCreateManyCategoryInput = {
    id?: string
    name: string
    source?: string
    unit: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndicatorUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thresholds?: StageThresholdUpdateManyWithoutIndicatorNestedInput
  }

  export type IndicatorUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thresholds?: StageThresholdUncheckedUpdateManyWithoutIndicatorNestedInput
  }

  export type IndicatorUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageThresholdCreateManyIndicatorInput = {
    id?: string
    stageId: string
    operator: $Enums.ThresholdOperator
    value: number
    durationDays?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageThresholdUpdateWithoutIndicatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    operator?: EnumThresholdOperatorFieldUpdateOperationsInput | $Enums.ThresholdOperator
    value?: FloatFieldUpdateOperationsInput | number
    durationDays?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stage?: StageUpdateOneRequiredWithoutThresholdsNestedInput
  }

  export type StageThresholdUncheckedUpdateWithoutIndicatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    operator?: EnumThresholdOperatorFieldUpdateOperationsInput | $Enums.ThresholdOperator
    value?: FloatFieldUpdateOperationsInput | number
    durationDays?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageThresholdUncheckedUpdateManyWithoutIndicatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    operator?: EnumThresholdOperatorFieldUpdateOperationsInput | $Enums.ThresholdOperator
    value?: FloatFieldUpdateOperationsInput | number
    durationDays?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CropCountOutputTypeDefaultArgs instead
     */
    export type CropCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CropCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CreatorCountOutputTypeDefaultArgs instead
     */
    export type CreatorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CreatorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CalendarCountOutputTypeDefaultArgs instead
     */
    export type CalendarCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CalendarCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CityCountOutputTypeDefaultArgs instead
     */
    export type CityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DistrictCountOutputTypeDefaultArgs instead
     */
    export type DistrictCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DistrictCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StageCountOutputTypeDefaultArgs instead
     */
    export type StageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IndicatorCategoryCountOutputTypeDefaultArgs instead
     */
    export type IndicatorCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IndicatorCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IndicatorCountOutputTypeDefaultArgs instead
     */
    export type IndicatorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IndicatorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CropDefaultArgs instead
     */
    export type CropArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CropDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CreatorDefaultArgs instead
     */
    export type CreatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CreatorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CalendarDefaultArgs instead
     */
    export type CalendarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CalendarDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CityDefaultArgs instead
     */
    export type CityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DistrictDefaultArgs instead
     */
    export type DistrictArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DistrictDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CalendarDistrictDefaultArgs instead
     */
    export type CalendarDistrictArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CalendarDistrictDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StageDefaultArgs instead
     */
    export type StageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StageAlbumDefaultArgs instead
     */
    export type StageAlbumArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StageAlbumDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StageThresholdDefaultArgs instead
     */
    export type StageThresholdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StageThresholdDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IndicatorCategoryDefaultArgs instead
     */
    export type IndicatorCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IndicatorCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IndicatorDefaultArgs instead
     */
    export type IndicatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IndicatorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GwlDefaultArgs instead
     */
    export type GwlArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GwlDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}